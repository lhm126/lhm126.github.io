[{"title":"Crash Course Computer Science","url":"/2022/10/23/Crash%20Course%20Computer%20Science/","content":"4. 二进制位，bit，即为二进制的一位， 位储存的信息大小为 。字节，byte​， 字节为  位。\nIEEE 754 标准，用来存储浮点数。如  写成 ， 为有效位数， 为指数。对于  位浮点数（float 型浮点数）， 位表示正负， 位存储指数， 位存储有效位数。\n5. 算术逻辑单元算术逻辑单元（ALU），含有算术单元和逻辑单元。\n算法单元：两个半加器（可以输入两个 ）组成全加器（可以输入三个 ，两个数字相加以及进位情况）， 个全加器可制作  位加法器。当  位加法器中最后一个全加器产生进位时，就是发生溢出（overflow）了。现代计算机使用超前进位加法器。\n6. 寄存器 &amp; 内存随机存取存储器（RAM），持久存储。\n AND-OR 锁存器（存储一位信息），八个组成一个  位寄存器。用矩阵来实现更高位的寄存器，有列地址和行地址。多路复用器用来找到对应的地址（寻址）。\nSRAM（静态随机存取存储器）。\n寄存器：很小的一块内存，能存一个值。\nRAM：一大块内存，能在不同地址存大量数字。\n7. 中央处理器(CPU)CPU 负责执行程序，程序由指令组成。数学指令：CPU 用 ALU 进行数学运算。内存指令：CPU 和内存通信，进行读值或写值。\n寄存器用来临时存数据和操作数据。\nCPU 状态：取指令，解码，执行。\n9. 高级CPU设计给 CPU 加一点 RAM，叫缓存（cache）。\n缓存命中（cache hit）：想要的数据已经在缓存。\n缓存未命中（cache miss）：想要的数据不在缓存。\n脏位（dirty bit）：同步一般发生在当缓存满了而 CPU 又要缓存时。在清理缓存腾出空间之前，会先检查”脏位“，如果是”脏“的，在加载新内容之前，会把数据写回 RAM。\n脏位的意义：修改数据时，为提高速度，会直接在缓存修改，而 RAM 未修改。\n指令流水线：并行处理，但要先弄清数据依赖性，必要时停止流水线。高端 CPU 会动态排序有依赖关系的指令，最小化流水线的停工时间，这叫做”乱序执行“。条件跳转会产生”岔路口“，高端 CPU 会猜那条路可能性大一些，然后提前把指令放进流水线，这叫做”推测执行“。\n多核处理器：同时运行多个指令流。\n11. 编程语言发展史二进制是处理器的“母语”，这叫“机器语言”或“机器码”。\n 汇编器读取用“汇编语言”写的程序，然后转成“机器码”。 \n高级编程语言：程序员只需创建代表内存地址的抽象，叫“变量”。   \n16. 软件工程把函数打包成层级，把相关代码都放在一起，打包成对象（objects）。把函数打包成对象的思想叫“面向对象编程”。\n程序编程接口，简称 API，帮助不同程序员合作。API 控制哪些函数和数据让外部访问，哪些仅供内部（设定 public 或 private）。\n集成开发环境，简称 IDE。\n源代码管理，也叫“版本控制”，比如 GIT，SVN。\n测试可以统称“质量保证测试”，检查 QA。\n17. 集成电路&amp;摩尔定律集成电路（IC），封装一定数量的常用电子元件，把分立元件封装成一个独立单元。\n印刷电路板，简称 PCB。\n光刻，用光把复杂图案印到材料上，比如半导体。\n18. 操作系统操作系统，简称 OS，充当软件和硬件之间的媒介。更具体地说，操作系统提供 API 来抽象硬件，叫“设备驱动程序”。\n虚拟内存，操作系统会自动处理虚拟内存和物理内存之间的映射（物理内存地址不连续，但虚拟内存地址连续）。 这种机制使程序的内存大小可以灵活增减，叫“动态内存分配”。对程序来说，内存看起来是连续的。这为操作系统同时运行多个程序提供了极大的灵活性。\n给程序分配专用的内存范围的另一个好处：程序出错后，只能捣乱自己的内存，不会影响到其它程序，这叫“内存保护”。\n分时操作系统，每个用户只能用一小部分处理器，内存等。\n19. 内存&amp;储存介质存储器，如硬盘，具有非易失性。\n20. 文件系统数据的数据，叫“元数据”（meta data），提供信息来正确读取数据，存在文件开头，在实际数据前面，因此也叫文件头（Header）。\n文件系统移动文件时，不用移动任何数据块，只需改两个目录文件，一个文件里删一条记录，另一个文件里加一条记录。\n21. 压缩游程编码（Run-Length Encoding），适合经常出现相同值的文件，压缩连续相同值。\nDFTBA，字典编码，紧凑代码，用霍夫曼树为出现频率高的数据分配长度短的代码（编号）。\n游程编码和字典编码实现了“无损压缩”，没有丢失任何数据。\n如果录音乐，超声波数据都可以扔掉。人对人声敏感，对低音不敏感，所以有损音频压缩利用这一点，用不同精度编码不同频段。这种删掉人类无法感知的数据的方法，叫“感知编码”（perceptual coding）。\n27. 3D 图形3D 投影，把 3D 坐标“拍平”显示到 2D 屏幕上。3D 转 2D 后用画 2D 线段的函数来连接点，这叫“线框渲染”。\n填充图形的经典算法叫扫描线渲染。\n抗锯齿，如果像素在多边形内部，就直接涂颜色，如果多边形划过像素，颜色就浅一些。\n实现遮挡，排序后从远到近渲染，这叫画家算法。还有一种方法叫深度缓冲，不用排序，对每个像素取距离的最小值，从而得到最前面的多边形。但距离相同时无法处理，不可预测哪个画在上面，导致出现 Z-fighting 效果。\n背面剔除，忽略多边形背面。\n明暗处理，多边形面对的方向叫“表面法线”，根据方向来进行平面着色。还有更多算法，如高落德着色和冯氏着色。\n纹理映射，查询纹理，从相应区域取平均颜色，并填充多边形。\nGPU，图形处理单元，在显卡上，周围有专用的 RAM。\n28. 计算机网络计算机近距离构成的小型网络，叫局域网，简称 LAN。\n为了知道数据传递方向，以太网需要每台计算机有唯一的媒体访问控制地址，简称 MAC 地址。\n多台电脑共享一个传输媒介，这种方法叫“载波侦听多路访问”，简称“CSMA”。很多计算机同时侦听载体，所以叫“侦听”和“多路访问”。载体传输数据的速度叫“带宽”。\n指数退避，发生冲突后等 1 秒。若仍冲突，等 2 秒。若仍冲突，等 4 秒……\n我们需要减少同一载体中设备的数量，载体和其中的设备总称“冲突域”。为了减少冲突，可以用交换机将一个冲突域拆成两个冲突域。\n大型网络中，从一个地点到另一个地点通常有多条路线。消息沿着路由跳转的次数，叫“跳数”（hop count）。\n29. 互联网WIFI 路由器连着的所有设备，组成了局域网，局域网再连到广域网（WAN），WAN 的路由器一般属于“互联网服务提供商”，简称 ISP。\n传输的数据会被拆成多个小数据包（packet）。数据包想在互联网上传输，要符合“互联网协议”的标准，简称 IP。为解决数据包传给哪个程序，还需更多协议，其中最简单最常见的叫“用户数据报协议”，简称 UDP。IP 负责把数据包送到正确的计算机，UDP 负责把数据包送到正确的程序。\n如果“所有数据必须到达”，就用“传输控制协议”，简称 TCP。1. TCP 数据包有序号。2. TCP 要求接收方的电脑收到数据包并且“校验和”检查无误后（数据没有损坏），给发送方发一个确认码（ACK），代表收到了。\n当计算机访问一个网站时，需要 IP 地址和端口号。域名系统（DNS）负责把域名和 IP 地址一一对应。\n30. 万维网为了使网页能相互连接，每个网页需要一个唯一的地址，这个地址叫“统一资源定位器”，简称 URL。\n超文本传输协议（HTTP）。\n超文本标记语言（HTML）。\n网络中立性，应该平等对待所有数据包。\n31. 计算机安全计算机安全是保护系统和数据的保密性，完整性和可用性。\n“保密性”是只有有权限的人才能读取计算机系统和数据。“完整性”是只有有权限的人才能使用和修改系统和数据。“可用性”是有权限的人应该随时可以访问系统和数据。\n拒绝服务攻击（DDOS）就是黑客发大量的假请求到服务器，让网站很慢或者挂掉。这就是攻击“可用性”。\n为了保护这三方面，安全专家会从抽象层面想象“敌人”可能是谁，这叫“威胁模型分析”。\n隔离，计划当程序被攻破后，如何限制损害，控制损害的最大程度，并且不让它危害到计算机上其他东西。可以用“沙盒”程序实现隔离，给每个程序独有的内存块，其他程序不能动。\n32. 黑客&amp;攻击“社会工程学”，欺骗别人让人泄密信息。最常见的攻击是网络钓鱼。\n远程攻击一般需要攻击者利用系统漏洞来获得某些能力或访问权限，这叫“漏洞利用”。一种常见的漏洞利用叫“缓冲区溢出”。“缓冲区”是一种概称，指预留的一块内存空间。可以利用缓冲区溢出来修改内存。\n为了防止缓冲区溢出被利用，最简单的方法是复制之前先检查长度，防止内存被修改，这叫“边界检查”。程序也会随机存放变量在内存中的位置，导致黑客更容易让程序崩溃，而不是获得访问权限。\n程序也可以在缓冲区后，留一些不用的空间，然后跟踪里面的值，看是否发生变化。如果发生了变化，说明有攻击者在乱来，这些不用的内存空间叫“金丝雀”。\n代码注入，最常用于攻击用数据库的网站。用“结构化查询语言”（SQL），一种流行的数据库 API。\n33. 加密把明文转成密文叫“加密”，把密文恢复回明文叫“解密”。\n密钥交换，是一种不发送密钥，但依然让两台计算机在密钥上达成共识的算法。“迪菲-赫尔曼密钥交换”（Diffie-Hellman），有公开的基数和模数，双方分别选一个指数 ，分别将  和  发给对方，共享密钥为 。双方用一样的密钥加密和解密消息，这叫“对称加密“。\n非对称加密，有两个不同的密钥，人们用公钥加密消息，只有有私钥的人能解密。知道公钥只能加密，但不能解密，这是”不对称“的。目前最流行的”非对称加密“技术是 RSA。\n34. 机器学习&amp;人工智能机器学习算法让计算机可以从数据中学习，然后自行做出预测和决定。\n分类，区分两个事物，做分类的算法叫“分类器”。很多算法会减少复杂性，把数据简化成“特征”，“特征”是用来帮助“分类”的值。为了训练“分类器”做出好的预测，我们需要“训练数据”。\n把决策空间切成几个盒子的简单方法，可以用“决策树”来表示。\n人工神经网络，人造神经元可以接受多个输入，然后整合并发出一个信号，被放成一层层，形成神经元网络，因此得名神经网络。一个输入层，一个输出层和多个隐藏层，因此得名“深度学习”。\n“弱 AI”或“窄 AI”，只能做特定任务。真正通用的，像人一样聪明的 AI，叫“强 AI”。\n学习什么管用，什么不管用，自己发现成功的策略，这叫“强化学习”。\n35. 计算机视觉 卷积神经网络，用一堆神经元处理图像数据，每个都会输出一个新图像 。\n36. 自然语言处理人类语言叫“自然语言”。自然语言处理，简称 NLP。\n分析树，用规则来讲句子划分为块，同时标明了句子的结构。\n语音识别，如今准确度最高的语音识别系统，用深度神经网络。\n波形转换为谱图，用快速傅里叶变换（FFT）实现波形到频率的转换。构成单词的声音片段叫“音素”。\n语音合成，让计算机输出语音。把一段文字，分解成多个声音，然后播放这些声音。\n37. 机器人机器人是由计算机控制，可以自动执行一系列动作的机器。\n比例-积分-微分控制器，简称 PID 控制器。比例值，实际值和理想值差多少。积分值，一段时间内误差的总和。导数值，期望值与实际值之间的变化率。三个值有不同权重，然后用来控制系统。\n","categories":["学习笔记"],"tags":["计算机基础知识"]},{"title":"7.17 组会","url":"/2023/07/16/7.17%20%E7%BB%84%E4%BC%9A/","content":"Chaitanya K. Joshi, Thomas Laurent, and Xavier Bresson. “An Efficient Graph Convolutional Network Technique for the Travelling Salesman Problem.”, Computing Research Repository abs/1906.01227 (2019)\n和  中的一样，神经网络的输出  表示该边在图的最优解中的概率，损失函数为  和最优解的交叉熵损失，即为将问题看作为一个分类问题。\n得到  后，通过束搜索来求解问题。\nWouter Kool, Herke van Hoof, and Max Welling. “Attention, Learn to Solve Routing Problems!”, arXiv: Machine Learning (2019)\n文章由  提出了一个基于注意力层的模型，并用  算法来训练模型。\n将  问题的解定义为 ，是节点的一个排列。基于问题实例  找到解  的随机策略：\nEncoder\n没有采用位置编码，输入的节点无次序之分。\n先将维度为  的节点坐标特征 $\\text{x}i嵌入到维度为d{\\text{h}}=128的向量\\text{h}_i^{(0)}中：然后\\text{h}_i^{(0)}通过N层注意力层来更新（实验中N=3），类似于\\text{Transformer}，注意力层每一层包含两个子层，一个8头注意力层（\\text{Multi-Head  Attention},M=8）和一个全连接层（\\text{Feed Forward}），每个子层中还有残差链接和批归一化：通过\\text{encoder}得到点嵌入\\text{h}i^{(N)}和图嵌入\\bar {\\text{h}}^{(N)}=\\frac{1}{n}\\sum{i=1}^n\\text{h}_i^{(N)}，都作为\\text{decoder}$ 的输入。\nAttention mechanism$$\\begin{aligned}\\text q_i &amp;= W^Q\\text h_i,\\text k_i=W^K \\text h_i,\\text v_i=W^V \\text h_i \\u_{ij}&amp;=\\begin{cases}\\frac{\\text q_i^T\\text k_j}{\\sqrt d_k} &amp; \\text{if}\\ i \\ \\text{adjacent to}\\ j\\\n\n\\infty &amp; \\text{otherwise}\\end{cases} \\a_{ij}&amp;=\\frac{e^{u_{ij}}}{\\sum_{j^{‘}}e^{u_{ij^{‘}}}} \\\\text{h}^{‘}i&amp;=\\sum_ja{ij}\\text v_j\\end{aligned}$$\n\nMulti-head attention$$\\text{MHA}i(\\text h_1,\\dots,\\text h_n)=\\sum{m=1}^M W_m^O \\text h_{im}^{‘}$$\nFeed-forward sublayer\nBatch normalization\nDecoder\n 由两层注意力层构成，一层多头注意力层，一层单头注意力，这里的注意力层没有采用残差连接、批归一化、全连接层操作，而是直接得到相关性分数。\n： 在  时刻的输入来自  和  之前其本身的输出：$${\\text{h}}^{(N)}{(c)}=\\begin{cases}[ \\bar {\\text{h}}^{(N)},\\text{h}^{(N)}{\\pi_{t-1}},\\text{h}^{(N)}{\\pi{t-1}}], &amp; t&gt;1\\[\\bar {\\text{h}}^{(N)},\\text{v}^\\text 1,\\text{v}^\\text f], &amp; t=1\\end{cases}$$其中  和  是维度为  的学习到的参数。\n将  和  计算：$$\\begin{aligned}\\text q_{(c)} &amp;= W^Q\\text h_{(c)},\\text k_i=W^K \\text h_i,\\text v_i=W^V \\text h_i \\u_{(c)j}&amp;=\\begin{cases}\\frac{\\text q_{(c)}^T\\text k_j}{\\sqrt d_k} &amp; \\text{if}\\ j \\not = \\pi_{t^{‘}}, \\forall t^{‘}&lt;t\\\n\n\\infty &amp; \\text{otherwise}\\end{cases} \\\\end{aligned}$$然后和上面  中一样求出  头注意力层输出结果 。\n\n最后用一个单头注意力层来求出输出概率 ，其中用  函数来将结果修正到 ：$$\\begin{aligned}u_{(c)j}&amp;=\\begin{cases}C \\cdot \\tanh(\\frac{\\text q_{(c)}^T\\text k_j}{\\sqrt d_k}) &amp; \\text{if}\\ j \\not = \\pi_{t^{‘}}, \\forall t^{‘}&lt;t\\\n\n\\infty &amp; \\text{otherwise}\\end{cases} \\p_i&amp;=p_\\theta(\\pi_t=i|s,\\pi_{1:t-1})=\\frac{e^{u_{(c)i}}}{\\sum_{j}e^{u_{(c)j}}}\\end{aligned}$$\n\nTrainpolicy gradient\n论文中的梯度计算公式为：$$\\nabla \\mathcal{L}(\\theta|s)=\\mathbb{E}{p{\\theta}(\\pi|s)}[(L(\\pi)-b(s))\\nabla \\ln p_\\theta(\\pi|s)]$$其中  是累计奖励函数，对于  即为路径长度。 是 ，减去  后能减少  的方差，利于梯度更新。\n\n 是采取采样策略， 的概率选择当前概率最大的点输出， 的概率随机选择一个点输出。\n 是采取贪心策略，每次都是选择当前概率最大的点输出。\n当  和  两个分布差异很大时，则用  来更新 。\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"ML for CO","url":"/2023/04/18/ML%20for%20CO/","content":"ML for CO 综述Yoshua Bengio, Andrea Lodi, and Antoine Prouvost. “Machine learning for combinatorial optimization: A methodological tour d’horizon”, European Journal of Operational Research 290.2 (2021): 405-421.\n不失一般性的，CO 问题可以被公式化为一个受约束的最小优化问题。如果目标和约束是线性的，则该问题称为线性规划（LP）问题。如果一些变量也被限制为只能为整数值，则问题被称为混合整数线性规划（MILP）问题。可用单纯形算法多项式复杂度求解 LP 问题。\n分支限界（branch and bound），分支是使用广度优先策略，依次生成扩展结点的所有分支，限界是在结点扩展过程中，计算结点的上界，搜索的同时剪掉某些分支。分支限界法就是把问题的可行解展开，再由各个分支寻找最佳解。\n对于 MILP 问题，分支限界算法为将问题松弛为实数变量后分解为小问题。\nEnd to end learning通过 ML，由 Problem defifinition 直接得到 Solution。ML 适合在较短的计算时间内获得准确的解决方案，因为一些复杂性是在学习阶段离线解决的。\nLearning meaningful properties of optimization problems通过 ML，为传统的运筹优化方法提供信息。\nMachine learning alongside optimization algorithms构建 CO 算法，在整个执行过程中反复调用 ML 模型。主算法控制高级结构，同时经常调用ML模型以协助较低级别决策。\n最大公共子图（MCS）Ciaran McCreesh, Patrick Prosser, and James Trimble. “A Partitioning Algorithm for Maximum Common Subgraph Problems.”, International Joint Conference on Artificial Intelligence (2017): 712-719.\nYanli Liu, Chumin Li, Hua Jiang, and Kun He. “A Learning Based Branch And Bound For Maximum Common Subgraph Related Problems”, AAAI Conference on Artificial Intelligence 34. (2020): 2392-2399.\nJianrong Zhou, Kun He, Jiongzhi Zheng, Chu-Min Li, and Yanli Liu. “A Strengthened Branch and Bound Algorithm for the Maximum Common (Connected) Subgraph Problem”, European Conference on Artificial Intelligence (2022): 1908-1914.\nThe McSplit Algorithm搜索过程中的当前状态为点对的映射 ，同时将还未考虑的点打上一个与已考虑的点集连通性的 ， 相同的点对才可加入映射，即选择处于同一标签类的点对。\n当前状态对应的答案上界为：启发式：选择标签类时，选择  最小的标签类，从  中选点时，选度数最大的点。\nMcSplit+RL\n因为预计的上界越小，越可能剪枝，因此考虑将上界的减少量作为奖励。\n\n同时，若考虑上界的减少率，则又得到一种变体方法。\n\n考虑点对的匹配作为奖励。\n\n\nMcSplit+LL AlgorithmLong-Short Memory (LSM)\n随着搜索的深入，当前状态会有很大的变化，均匀地累积分数会导致由大部分历史评估值引起的偏差。因此，需要一种能够消除历史评估的影响的机制。\n考虑短期阈值  （默认为 ）和长期阈值  （默认为 ）。若  大于 ，则所有  衰减到一半。若  大于 ，则所有  衰减到一半。\nLeaf vertex Union Match (LUM)\n叶节点定义为只跟一个点相邻的节点。一个点的叶子定义为与该点相邻的叶节点。\n定理：在进行  时，当一对点  匹配时，可以从  的不匹配的叶子中匹配尽可能多的点对，而不影响解的最优性。\n旅行商问题（TSP）LKH求解 TSP 的启发式算法可分为三类：回路构造算法、回路改进算法和复合算法。复合算法通常使用回路改进算法对回路构造算法得到的初始解进行改进。LKH 算法是一种利用 k-opt 来改进启发式构造的初始行程的复合算法。\nk-opt：替换当前解的  条边，得到一个更优的新解。\t\n\n\n1-tree 下界：从  中选出一个点 ，求出剩下点  的最小生成树，最小生成树的权值再加上  向最小生成树的不同两个点连出的最小权值的边的权值（一条边为进入最小生成树，一条边为离开最小生成树），即为 1-tree 下界。1-tree 下界不一定是可行解。当 1-tree 中每个点度数都为  时为可行解，且为最优解。\n定义 ，其中  为 1-tree 的权值， 为必须包含边  的 1-tree 的权值。一条边的  值可以看做必须包含该边的最小 1-tree 的额外权值。在 LKH 算法中，有更小的  值的边在搜索中有更高的优先级。\nHeld-Karp 下界：LKH 算法通过添加惩罚  来最大化最优 TSP 解的下界，边权变为：。这个变化不改变 TSP 的最优解，但改变了最小的 1-tree。最大化 ，即为 Held-Karp 下界。迭代为 ，其中  为点  在最小 1-tree 中的度数， 为迭代的参数， 为迭代的轮数。迭代即为让最小 1-tree 中的点的度数都变为 。\nVSR-LKHJiongzhi Zheng, Kun He, Jianrong Zhou, Yan Jin, and Chu-min Li. “Combining Reinforcement Learning With Lin-Kernighan-Helsgaun Algorithm For The Traveling Salesman Problem”, AAAI Conference on Artificial Intelligence 35 (2021): 12445-12452.\nVSR-LKH 中，k-opt 过程不再是遍历候选边集，而是通过强化学习来从候选边集选择添加的边。对于该强化学习，状态为当前需要加边的点，动作为加边，加边后状态转移为所加边的另一个端点，奖励为：定义  的初始  为： 影响选择边的优先级。\nNeuroLKHLiang Xin, Wen Song, Zhiguang Cao, and Jie Zhang. “NeuroLKH: Combining Deep Learning Model with Lin-Kernighan-Helsgaun Heuristic for Solving the Traveling Salesman Problem.”, Conference on Neural Information Processing Systems (2021): 7472-7483.\nLKH 中迭代  后能提升候选边集的质量，但仍有局限性，因此提出了 NeuroLKH 来构建候选边集。\n首先将原图转化为稀疏有向图 ，每个点所连的边只保留最短的  条，这  条看作是该点连出的有向边。实验中取了 。\n用稀疏图网络来预测边的权值  和点的惩罚 。 不是边权，其权值越大，搜索中越优先选择这条边， 即为上面改变边权的惩罚。\n\n先将边和点的信息转化为特征向量，维度为 ，用  层稀疏图卷积层来预测，实验中取  和 ，卷积层定义为：$$\\begin{aligned}attn^l_{i,j}&amp;=\\exp(W_a^le_{i,j}^{l-1})\\oslash \\sum_{(i,m)\\in E^*}\\exp(W_a^le_{i,m}^{l-1}) \\v^l_i&amp;=v^{l-1}i+ReLU(BN(W_s^lv_i^{l-1}+\\sum{(i,j)\\in E^*}attn^l_{i,j}\\odot W_n^l v_j^{l-1})) \\r^l_{i.j}&amp;= \\e^l_{i,j}&amp;=e^{l-1}{i,j}+ReLU(BN(W_f^lv_i^{l-1}+W_t^lv_j^{l-1}+W_o^le^{l-1}{i,j}+r^l_{i,j}))\\end{aligned}$$ 和  分别是按元素乘法和按元素除法， 是层数， 和  都是训练的参数。\n 经过两层线性层后再由  激活得到 。同样的， 经过两层线性层后再由  激活得到 。然后再计算  和 ： 是训练的参数，，使得  范围为 。\n边的权值  通过监督学习训练，点的惩罚  通过无监督学习训练。损失函数分别为：$$\\begin{aligned}\\mathcal{L}\\beta&amp;=-\\frac{1}{\\gamma|V|} \\sum{(i,j)\\in E^*} (\\mathbb{1}{(i,j)\\in E_o^* }\\log \\beta_{i,j}+\\mathbb{1}{(i,j)\\not \\in E_o^* }\\log (1-\\beta_{i,j})) \\\\mathcal{L}\\pi&amp;=-\\frac{1}{|V|}\\sum{i \\in V}(d_i(\\pi)-2)\\pi_i\\\\mathcal{L}&amp;=\\mathcal{L}_\\beta+\\eta_\\pi\\mathcal{L}\\pi\\end{aligned}$$，即为若一条边在最优解中，则增大其权值 $\\beta{i,j}$。\n 为点  在最小 1-tree 中的度数， 为平衡两个损失函数的系数。实验中取 。\n对于大规模的数据，边的权值  可以很好地泛化，但点的惩罚  不能直接泛化。因为  是通过无监督学习训练的。因此，对于  进行微调，进行  次迭代，批处理大小为 。\n图匹配Junchi Yan, Shuang Yang, and Edwin R. Hancock. “Learning for Graph Matching and Related Combinatorial Optimization Problems.”, International Joint Conference on Artificial Intelligence 5 (2020): 4988-4996.\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"Wasm","url":"/2023/11/01/Wasm/","content":"Bringing webassembly to resource-constrained iot devices for seamless device-cloud integrationBorui Li, Hongchang Fan, Yi Gao, and Wei Dong. “Bringing webassembly to resource-constrained iot devices for seamless device-cloud integration”, ACM SIGMOBILE International Conference on Mobile Systems, Applications, and Services (2022): 261-272.\n在资源有限的设备上支持 WebAssembly 的设备云集成仍具有挑战：\n如何支撑端云一体化应用并在资源受限的设备上高效执行？\n如何保证 WebAssembly 的沙盒执行？\n如何优化设备上执行的能耗？\n","categories":["学习笔记"],"tags":["论文","Wasm"]},{"title":"吴恩达机器学习","url":"/2022/10/23/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"课程 1 Supervised Machine Learning: Regression and ClassificationWeek 1: Introduction to Machine Learning监督学习监督学习是输入  到输出标签  映射的算法。算法从事先给的“正确答案”中学习。\n第一种监督学习算法，回归，从无限多个可能的数中预测出一个数。如预测房价。\n第二种监督学习算法，分类，预测类别在一个小的、有限的输出类别集合。如判断猫狗。\n无监督学习 在数据集中找到一些结构或者模式。不事先给“正确答案”。\n聚类算法，一种无监督学习算法，将未标记的数据放在不同的簇中。\n其他的无监督学习算法：异常检测，降维。\n线性回归方差代价函数：\n梯度下降\n这里的  是赋值。 为学习率，取值应适当，不能太小太大。因为在梯度下降的过程中，导数会自动变小，所以更新的步幅也会自动变小。 批量梯度下降指的是每一步梯度下降，都会考虑到所有的训练样本。\nWeek 2: Regression with multiple input variables多元线性回归\n特征缩放为了让特征  的取值范围接近 。\nWeek 3: Classification逻辑回归一种分类模型。\n sigmoid function：逻辑回归模型：决策边界：损失函数：代价函数：$$\\begin{aligned}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{m}\\sum_{i=1}^mL(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}),y^{(i)}) \\&amp;=-\\frac{1}{m}\\sum_{i=1}^my^{(i)}\\log (f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))+(1-y^{(i)})\\log (1-f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})) \\\\frac{\\partial}{\\partial w_j}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})x^{(i)}j \\\\frac{\\partial}{\\partial b}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{m}\\sum{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})\\end{aligned}$$\n过拟合高偏差的模型，欠拟合。高方差的模型，过拟合。\n解决过拟合的方法：1.收集更多的数据。2.选择并使用特征子集。3.利用正则化减小参数的大小。\n正则化线性回归的正则化：$$\\begin{aligned}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{2m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})^2 +\\frac{\\lambda}{2m}\\sum_{j=1}^n w_j^2 \\\\frac{\\partial}{\\partial w_j}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})x^{(i)}j +\\frac{\\lambda}{m}w_j\\\\frac{\\partial}{\\partial b}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{m}\\sum{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})\\end{aligned}逻辑回归的正则化：\\begin{aligned}J(\\overset{\\rightarrow}{w},b)&amp;=-\\frac{1}{m}\\sum_{i=1}^my^{(i)}\\log (f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))+(1-y^{(i)})\\log (1-f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})) +\\frac{\\lambda}{2m}\\sum_{j=1}^n w_j^2 \\\\frac{\\partial}{\\partial w_j}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})x^{(i)}j +\\frac{\\lambda}{m}w_j\\\\frac{\\partial}{\\partial b}J(\\overset{\\rightarrow}{w},b)&amp;=\\frac{1}{m}\\sum{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})\\end{aligned}$$\n课程 2 Advanced Learning AlgorithmsWeek 1: Neural Networks神经网络输入层，输出层，隐藏层。神经网络结构的问题就是，要有多少个隐藏层，每个隐藏层要有多少个神经元。\n对于神经网络的第  层的第  个神经元：其中  为激活函数。这个过程称为前向传播。\nWeek 2: Neural network training激活函数Linear activation function：\nSigmoid：\nReLU：\n对于输出层：\n二分类问题，使用 Sigmoid。\n 可正可负，使用 Linear activation function。\n 非负，使用 ReLU。\n对于隐藏层，使用 ReLU。\n多分类多分类问题，如数字识别，结果为  到 。\nSoftmax 回归算法是逻辑回归的推广，用来解决多分类问题。\n 可以取  个值：$$\\begin{aligned}z_j&amp;=\\overset{\\rightarrow}{w}j \\cdot \\overset{\\rightarrow}{x}+b_j&amp;j=1,\\dots,n \\a_j&amp;=\\frac{e^{z_j}}{\\sum{k=1}^n e^{z_k}}=P(y=j | \\overset{\\rightarrow}{x})\\end{aligned}$$\n 时即为逻辑回归。\n损失函数：\n多标签分类多标签分类，如判断图片上有无汽车，公交车，行人。\nAdam 算法自动调整学习率，过小时增大，过大时减小。\nWeek 3: Advice for applying machine learning模型评估解决方案：\n高偏差：增加特征，增加多项式特征（如 ），减小 。\n高方差：更多训练样本，减少特征，增大 。\nWeek 4: Decision trees决策树熵，对一组数据不纯度的衡量。\n信息增益：其中， 为左子树中带有正标签的样本的比例， 为根节点到左边子分支的样本的比例。\n停止条件：\n一个节点所有数据标签相同。\n树的深度大于某一阈值。\n最大信息增益小于某一阈值。\n一个节点数据数小于某一阈值。\nOne-hot 编码\n对多分类问题的决策树应用 One-hot 编码，即可转化为二分类问题。如耳朵为椭圆，尖角，耷拉转化为耳朵是否椭圆等。\n连续值\n若特征为连续值，则取阈值 ，阈值通常为 ，这里  有序。将特征转化为 ，变为 。\n回归树\n和决策树类似，不再预测分类，而是输出一个 。\n信息增益： 为方差函数。\n集成树\n使用集成树后，不用担心整体算法会对任何一棵树的预测过于敏感。\n通过有放回抽样，得到和原数据集大小相等的新数据集，用新数据集来构建集成树。\n随机森林算法\n对每个节点，当要选特征来分裂时，若有  个特征可选，则随机选  个特征来考虑。通常取 。\nboosting 指再构建一棵新树时，优先选取在当前决策树森林中被错误分类的样本。\n课程 2 Unsupervised Learning, Recommenders, Reinforcement LearningWeek 1: Unsupervised learning聚类K-means\n第一步是将点分配给簇质心（簇的中心），第二步是移动簇质心。\n代价函数（distortion 函数）： 为第  个簇质心， 表示第  个点  当前对应的簇（最近的簇质心）。\n第一步是固定 ，通过调整  来让  最小，第一步是固定 ，通过调整  来让  最小。在每一次迭代中，代价函数下降或不变。\n一开始随机选样本点来作为簇质心。\n异常检测通过观察正常事件的未标记数据集，从而学会检测异常或在异常事件发生时发出危险信号。\n密度估计\n对于  个样本，每个样本有  个特征：等式右边的  为高斯（正态）分布。若 ，则认为异常。\nWeek 2: Recommender systems协同过滤代价函数： 表示用户  有给商品  评分， 为对应的评分， 为用户  评分商品的数量， 为有  个特征的向量。\n 是常量，可以去掉：用来学习  的代价函数：用来学习  的代价函数：合并到一起：用梯度下降来迭代。\n对于二元分类，类似逻辑回归处理即可。\n基于内容过滤用深度学习实现。\n代价函数：\nWeek 3: Reinforcement learning强化学习有若干概念，状态，行动，奖励，折扣因子，回报，策略，马尔可夫决策过程。\n状态动作价值函数， 表示在状态  时，采取行动  后行动最优所得到的回报。\n贝尔曼方程：其中  表示状态  的奖励， 是状态  采取行动  后转移到的状态。感觉就是动态规划转移方程。\n实际情况中，状态不一定能顺利转移，因此考虑的回报是期望回报：\n","categories":["学习笔记"],"tags":["人工智能","机器学习"]},{"title":"强化学习","url":"/2023/04/28/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"基本概念\nPolicy function: \nPolicy function 是一个概率密度函数。\n\nenvironment 的随机性：\n Two Sources of Randomness:\naction: \nstate: \nReturn: \nDiscounted return: \ndiscount factor:  （超参数）\n\n价值学习Action-value function: \nOptimal action-value function: \nbest action: \n用神经网络来近似 。\nTemporal Difference (TD) Learning\n\n用  来近似 。 是神经网络的参数。\n\nTD target: $y_t=r_t + \\gamma Q(s_{t+1},a_{t+1};\\text{w}t)=r_t + \\gamma \\max\\limits_aQ(s{t+1},a;\\text{w}_t)$\nLoss: \nGradient descent: $\\text{w}_{t+1}=\\text{w}t-\\alpha\\frac{\\partial L_t}{\\partial \\text{w}}|{\\text{w}=\\text{w}_t}$\n策略学习State-value function:\n （离散）\n （连续）\n用 $\\mathbb{E}S[V{\\pi}(S)]来评估\\pi$。\n用策略网络  来近似 ， 为需要训练的参数。同时，。\n学习  来最大化 。\n更新策略：\n策略梯度：\n形式一：\n形式二：\n设 ，得 $\\frac{\\partial V(s;\\theta)}{\\partial \\theta}=\\mathbb{E}A[g(A,\\theta)]。这里用蒙特卡洛近似来计算期望：随机抽样a \\sim \\pi(\\cdot|s_t;\\theta_t)来计算g(a,\\theta_t)，从而进行更新，\\theta{t+1}=\\theta_t+\\beta g(a,\\theta_t)$。\nActor-Critic Methods\nPolicy network (actor): \nValue network (critic): \n\n更新  来增大 ，监督基于 value network (critic)。\n更新  来更好的估计回报 return。\n蒙特卡洛随机抽样，可以用来求 ，求定积分，求期望。\nSarsa 算法\n直接求不了期望，所以用蒙特卡洛近似，用观测值  来近似，近似值  即为 TD target 。\n用价值神经网络  来近似 ：\nTD target: \nTD error: \nLoss: \nGradient: \nGradient descent: \nQ-Learning 算法Q-learing 用来训练最优动作价值函数 。然后用蒙特卡洛近似：\nTD target: \n通过 DQN  来近似 ：\nTD target: \nTD error: \nUpdate: \nMulti-Step TD Target考虑多个奖励：对于 Sarsa：对于 Q-learning：\nPolicy Gradient with Baseline如果  和  独立，则有：$$\\begin{aligned}&amp;\\mathbb{E}{A \\sim \\pi}\\left[b \\cdot\\frac{\\partial \\ln\\pi(A|s;\\theta)}{\\partial \\theta}\\right] \\=&amp;b \\cdot \\sum_a \\pi(a|s;\\theta) \\cdot \\left[\\frac{1}{\\pi(a|s;\\theta)}\\cdot\\frac{\\partial \\pi(a|s;\\theta)}{\\partial \\theta}\\right] \\=&amp;b \\cdot \\frac{\\partial\\sum_a \\pi(a|s;\\theta)}{\\partial \\theta} \\=&amp;b \\cdot \\frac{\\partial1}{\\partial \\theta} \\=&amp;0\\end{aligned}可改写为：\\begin{aligned}\\frac{\\partial V_\\pi(s)}{\\partial \\theta}&amp;=\\mathbb{E}{A \\sim \\pi}\\left[\\frac{\\partial \\ln\\pi(A|s;\\theta)}{\\partial \\theta}Q_\\pi(s,A)\\right] \\&amp;=\\mathbb{E}_{A \\sim \\pi}\\left[\\frac{\\partial \\ln\\pi(A|s;\\theta)}{\\partial \\theta}(Q_\\pi(s,A)-b)\\right] \\\\end{aligned}$$\n","categories":["学习笔记"],"tags":["人工智能","强化学习"]},{"title":"指针网络","url":"/2023/09/03/%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C/","content":"Pointer NetworksOriol Vinyals, Meire Fortunato, and Navdeep Jaitly. “Pointer Networks.”, Conference on Neural Information Processing Systems abs/1506.03134. (2015): 2692-2700.\n 的输出类别是固定的，比如对于  问题，每次的输出是从固定大的词汇表中输出一个单词。但对于组合优化问题，比如 ，对于不同规模大小的问题，其点数  不同，输出不是固定的。 就是为了解决这种输出不固定的问题。\nSequence-to-Sequence Model问题描述：比如对于 ：输入是  个点，输出是一个长为  的排列。\n 模型对于训练数据 ，拟合条件概率：其中  为参数。\nContent Based Input Attention 和  都是 。 和  的隐藏状态分别定义为  和 。 模型第  次输出为 ，注意力机制额外求出注意力向量 ，将二者连接后， 作为隐藏状态来实现预测。 表示  和  的距离。\nPtr-Net用  作为指向输入元素的指针。将输入作为查找的词典，而不是用事先固定的词典。\nCombinatorial Optimization by Graph Pointer Networks and Hierarchical Reinforcement LearningMa Qiang, Ge Suwen, He Danyang, Thaker Darshan, and Drori Iddo. “Combinatorial Optimization by Graph Pointer Networks and Hierarchical  Reinforcement Learning”, arXiv preprint arXiv 1911.04936 (2019)\n 即为找到一个最佳排列 ，使得路径长度最小：\nReinforcement Learning for TSP奖励的期望为：$$\\begin{aligned}&amp;\\mathbb E_{(s_t,a_t) \\sim \\pi_\\theta (s_t,a_t)} \\left[ \\sum_{i=1}^N r(s_t,a_t) \\right] \\=&amp;\\mathbb E_{\\sigma \\sim p_\\theta (\\Gamma),X \\sim \\mathcal X} \\left[ \\sum_{i=1}^N-||x_{\\sigma(i)}-x_{\\sigma(i+1)}||2 \\right]\\=&amp;-\\mathbb E{\\sigma \\sim p_\\theta (\\Gamma),X \\sim \\mathcal X} \\left[ L(\\sigma,X) \\right]\\end{aligned}$$ 是城市集合的空间， 是  上所有可能排列  的空间。 是  上的分布，由神经网络预测。用策略梯度算法最大化奖励函数来训练。\nHierarchical RL for TSP第  层中，动作  由策略 $\\pi_{\\theta_k}(a^{(k)}t | s_t^{(k)},h_t^{(k)})采样得到。h_t^{(k)}是前一层提供的潜在变量，该层为下一层提供潜在变量h_t^{(k+1)}，即为a_t^{(k)},h_t^{(k+1)}\\sim \\pi{\\theta_k}(\\cdot | s_t^{(k)},h_t^{(k)})$。\n\nHierarchical Policy Gradient第  层的目标函数为 。由  算法得，其策略梯度为：其中  为批量大小， 为第  层的 。用梯度下降来更新参数 。动作  是用贪心采样得到。\n对于这个  层的分层策略 ，每个策略用一个  表示。\nGPN ArchitectureEncoder\n包含两部分， 和 。\n 将节点  映射到  维向量 ，并且所有节点共享映射变换的参数，然后通过  进一步编码得到隐藏变量 ， 会传递给  和下一时刻的 。\n 对  进行编码后输入到  里。\n\nGraph Embedding Layer\n 的每一层为：Missing or unrecognized delimiter for \\left x_i^l=\\gamma x_i^{l-1}\\Theta +(1-\\gamma)\\phi_\\theta\\left( \\frac{1}{|\\mathcal N(i)|} \\left{ x_j^{l-1} \\right}_{j\\in \\mathcal N(i) \\cup { i }} \\right)  是一个可训练的参数，用来正则化权重矩阵的特征值， 是可训练的权重矩阵， 是聚合函数，用神经网络来拟合。\n 考虑的是完全图，将每一层写成矩阵的形式为：具体实验中使用的聚合函数是单层的全连接神经网络，图嵌入层即为：Vector Context\n一般的  都是用城市的二维坐标，即 ，但这篇文章用的是一个城市指向其他城市的向量，称为 。\n设 ， 为 。图嵌入层就改为：Decoder\n 生成指针向量 ，定义为：$$\\begin{aligned}u_i^{(j)}&amp;=\\begin{cases}v^\\top \\cdot \\tanh(W_r r_j + W_q q) &amp;\\text{if}\\ j \\not = \\sigma(k),\\forall k&lt;j \\\n\n\\infty &amp; \\text{otherwise}\\end{cases} \\\\pi_\\theta(a_i | s_i)&amp;=p_i=\\text{softmax}(u_i)\\end{aligned}$$其中  和  是可训练矩阵， 为  的隐藏变量 ， 为  中的 ，即 。根据策略  来抽样或者贪心来得到动作 。\n\nExperiments小规模的问题：\n\n大规模的问题：\n\nPointerformer: Deep Reinforced Multi-Pointer Transformer for the Traveling Salesman ProblemYan Jin, Yuandong Ding, Xuanhao Pan, Kun He, Li Zhao, Tao Qin, Lei Song, and Jiang Bian. “Pointerformer: Deep Reinforced Multi-Pointer Transformer for the  Traveling Salesman Problem”, CoRR abs/2304.09407 (2023): 8132-8140.\n目标为最大化奖励：$$\\begin{aligned}J(\\theta | s)&amp;= \\mathbb E_{\\tau \\sim p_\\theta (\\tau|s)}R(\\tau) \\&amp;=-\\mathbb E_{\\tau \\sim p_\\theta (\\tau|s)}L(\\tau) \\p_\\theta(\\tau | s)&amp;=\\prod {i=1}^N \\pi_\\theta(\\tau{[i]}|s,\\tau[:i])\\end{aligned}根据策略梯度定理得：\\nabla_\\theta J(\\theta| s)=\\mathbb E_{p_\\theta (\\tau|s)}[\\nabla_\\theta \\log p_\\theta (\\tau | s)R(\\tau)]$$\nReversible residual network based encoder采取特征增强，将每个节点从  表示改为 ，其中 。同时翻转和旋转整张图，得到原图的  个等效的图，得到的每个图节点的特征也作为节点的特征。这样每个节点就有  个特征来作为初始嵌入层的输入了。\n\n使用可逆残差网络，不同于剩余网络，其不需要存储所有剩余层的激活值来计算反向传播中的梯度。\n因为可以从输出嵌入  可以直接计算出输入嵌入 ，所以不需要存储所有激活值。\nMulti-pointer network based decoderEnhanced Context Embedding 是第一个节点的嵌入。 是当前最后一个节点的嵌入。 是对整张图的嵌入，， 是第  个节点嵌入。 是当前已考虑节点的嵌入，。\n 被用作查询 ，，\nA Multi-pointer Network\n在每一步中， 用于和和所有要访问的节点交互，来得到它们的概率分布。其中  是当前得到的部分路径中的最后一个节点。这里减去  能鼓励每次选择最近的节点来作为下一个访问的节点。 是平衡探索和利用的一个参数。最后用  来计算概率。\nA modified REINFORCE algorithm用  算法来训练模型。\n对于一个  个节点的  实例 ，将每个点都作为起始点来得到  条可行路径 ，然后对这  条路径进行蒙特卡洛采样。\n对于一个包含  个  实例的批次，可以得到  个路径。训练前进行归一化处理，这样能提高收敛速度和保证稳定训练。\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"图神经网络","url":"/2023/08/12/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"Thomas N. Kipf, and Max Welling. “Semi-Supervised Classification with Graph Convolutional Networks.”, International Conference on Learning Representations abs/1609.02907. (2017)\n其中  为加上自环的邻接矩阵， 为其对应的度矩阵， 为激活函数。这里分别左乘和右乘上其中 。\nSpatial-based ConvolutionNN4G（Neural Networks for Graph）$$\\begin{aligned}h_i^0&amp;= \\overline w_0 \\cdot x_i \\h^{l+1}i&amp;= \\hat w {l+1,l}\\sum{(i,j)\\in E} h^l_j + \\overline w_1 \\cdot x_i \\X_l&amp;=MEAN(h^l) \\y&amp;=\\sum{l=1}^L w_l \\cdot X_l\\end{aligned}$$\nDCNN（Diffusion-Convolution Neural Network）$$\\begin{aligned}h^l_i&amp;=w^l_i MEAN(d(i,\\cdot)=l+1) \\ \n &amp;\\times \\text W = y_i\\end{aligned}$$\n其中  表示所有和  距离为  的点。\nDGC（Diffusion Graph Convolution）跟上一个一样，只是最后不是 ，而是全部相加：\nMoNET（Mixture Model Networks）$$\\begin{aligned}u(x,y)&amp;=\\left ( \\frac{1}{\\sqrt{\\text{deg}(x)}},\\frac{1}{\\sqrt{\\text{deg}(y)}} \\right )^\\top \\h^{l+1}i&amp;=\\sum{y \\in \\mathcal N(x)}w(\\hat u_{x,y}) \\cdot h^l_y \\D_j(x)f_l&amp;=\\sum_{y \\in \\mathcal N(x)}e^{-\\frac{1}{2}(\\tilde{\\text {u}}(x,y)-\\mu_j)^\\top\\sum_j^{-1}(\\tilde{\\text {u}}(x,y)-\\mu_j)}f_l(y)\\end{aligned}$$\nGraphSAGEaggregation: mean, max-pooling, or LSTM\nGAT（Graph Attention Networks）\nGIN（Graph Isomorphism Network）$$h^{(k)}_v=\\text{MLP}^{(k)}\\left( \\left( 1+\\epsilon^{(k)} \\right) \\cdot h^{(k-1)}v +\\sum{u\\in \\mathcal N(v)}h^{(k-1)}_u \\right)$$\nSpectral-based ConvolutionChebNet","categories":["学习笔记"],"tags":["论文","人工智能","图神经网络"]},{"title":"日记 2023.5","url":"/2023/05/05/%E6%97%A5%E8%AE%B0%202023.5/","content":"5.1健身，吃秀玉。\n看马里奥大电影，碧姬公主很帅！！蓝龟壳，马里奥赛车，“猫对抗强”，“人拿到无敌星就会本能的冲”，要素挺多。想起自己高二高三天天看超级小桀的马造视频，感觉自己还是懂点马里奥的。\n5.2健身，和 wyk 吃九轮，体验挺好。\n5.4第一次做义工，益路华中大，把非机动车赶到非机动车道上。好几个同学一开始没明白我向非机动车道挥旗子的意思，骑过去后才明白，然后哈哈笑，感觉挺有意思。同学们也都很配合，“OK”，微笑，竖大拇指。\nyz 把照片盒出来了，🦐。\n5.5😥 这段时间我好摆啊，效率好低，得多注意了。\n5.6😰 依旧摆，早上九点四十起，直接睡过微积分，下午又睡一下午，晚上多学会儿吧。\n5.7中午班级东湖烧烤团建，感觉办的挺成功的。烧烤吃的挺开心，桌游也有两三桌，希望大家吃的烤串都是熟的 🙏，也别太熟成黑炭。\n蛋白粉到了，我要大我要大我要大 🤤。喝起来没啥味儿，饱腹感挺强。\n晚上去看银河护卫队 3，好看！每个角色最后都有自己的归途。火箭的故事很饱满，至高进化和他创造的反地球的设定都挺有意思。反地球——福瑞控天堂。\n5.8下午完成了公选课作业，采访了大萝卜。萝卜比我们预期的能说，问一个问题，直接把我们接下来要问的问题也给回答了。最后又他谈到了卷，“不是逼着你们卷，但大一还是要努努力，不要丢了那股劲儿，不然以后找都找不回来”。\n5.9上午找 hk 面谈，约了好几次，终于约上了。给她讲了讲我这段时间看的论文，说了四十分钟。我一直以为之后是找个学长带我，但今天交流完，我才知道老师对我的期望是主要我自己来做，老师和学长提供帮助。这下直接幻想时间了 🤤，不过工作量也挺多，本来以为这次谈完后，到暑假前这边就没啥事了，这下直接事儿更多了 😨。\n5.11去“梦系红楼”音乐会当志愿者，那句“天尽头，何处有香丘”很震撼，最后我们志愿者还跟吴碧霞老师一起合照了。\n5.12这次时机比较巧。\n5.15听了安全教育报告，感觉国内管理 AIGC 确实很难，希望逐步完善吧。\n5.18盖亚过生日，吃了东北乱炖，好吃 😋。\n逼宫大成功。\n😭 但我大失败。\n5.19去看室友唱歌，集成十大歌手。冠军唱的李健的歌，巨牛。\n😥 然后又失败。\n5.22事儿好多，hk 那边也开始催组会了。是真没 idea 啊，各种意义上。\n感觉太内耗了，还是弃了吧 😞。\n5.23语文结课了，写小作文，“我的阅读小史”，上学期还是读了挺多小说的，有东西写。\n5.24考英语口语，我们组最后一个，全班都走了我们才上 😭。\n5.25考离散，感觉复习时间多了，没必要战线拉这么长，考的还是偏简单的，虽然分应该不怎么高吧 😕。\n5.26根儿过生日。然后晚上给高中他们讲课，七点到十点半，讲了三个半小时。没想到讲这么长时间，并且还是线上，但同学们还是挺积极的。\n5.28去吃赤牧，体验挺好。第一次坐轮渡，吹风挺舒服，然后去江滩，继续吹风。\n🤤🤤\n5.30认识了 🌋，早上简单聊了聊，下午一起自习，她挺有意思的，也很有自己的想法，并且社交属性很强。她加入了冰岩，猛猛学前端，想搞 HCI，比口口大部分只懂卷加权的人强。BBHust 里全是她的帖子，什么个人博客。\n","categories":["生活"],"tags":["日记"]},{"title":"日记 2023.6","url":"/2023/06/02/%E6%97%A5%E8%AE%B0%202023.6/","content":"6.1图书馆楼下有六一活动，给小朋友写回信，小学生的想法很有趣，很童真。\n😰 图书馆电梯里碰见了 ______，还好人家没认出来我，不然有点尴尬。\n新馆四楼看见本书，《没有男朋友又怎样》——山内麻里子，感觉挺有意思。\n6.2网格员制度有点逆天。\n6.3看天空之城，然后……\n🥺 呜呜呜，我没了。\n😰 一点半到快四点。\n问是 ________，还是 ___，得到的答案是“不知道”，但我也不知道啊。\n6.4我以为很稳的。\n6.5我超，🕷 蜘蛛侠真好看，未完待续真 **，导致了一些鬼叫。\n6.6去讲了数据结构，感觉挺成功，但来的人比我预期的少。然后和大伙去吃川菜，很正宗，老板都是四川人，但确实辣 🥵。\n在一起了。\n6.7粉裙子有点像小羽毛球，有点嘉然孕妇装的感觉。\n6.9逆天 lhw，“哈喽嫂子😁”。\n6.10晚上告诉 yz 他们了，说去吃夜宵，逛了半天，发现海底捞人巨多，最后一人一笼小笼包。\n6.11考完近代史了，她也考完细生了，出去玩，官宣了。\n6.14碰见了 dcn 拔草。帮 xjr 上课，她睡大觉。她睡一下午，完全失联，“😭 xjr 别似啊”。\n我们俩碰见了 zhy，她直接“嫂子好！”。\n6.16逆天啊，保研群聊了一下午我，真字面意思。一帮人匿名讨论“刘队”。\n6.17萝卜说了说下一届的图论班，还说加权没有 ％ 的同学不让进萝卜班 😨。\n6.18😋 xjr 怒骂 yz，来点攻击性震撼。\n巨大雨，我在紫菘渡江，水没到膝盖 😰。耳机盒不见了 😢。\n6.19考微积分，感觉还好。耳机盒找到了 😋。\n6.21大物考的血崩，希望成绩不要  开头 😭。\n6.22去蹭光电请李开丁老师讲的概率论，他讲的确实好 👍。\n6.24😭 我晚上备考第二天的概率论，她晚上去 club 看表演。\n6.25教 xjr 骑 🚲，学挺好！\n6.26搬寝室第一波，在韵苑各个寝室来回跑，逛了个遍。\n出去玩，看了消失的她，我们俩一致认为后半段很怪，她严厉批评了彩蛋。\n6.27吃一绪，爽喝旺仔牛奶！\n6.28搬寝室第二波，回来吧紫菘十栋 😭。\n6.29去了猫咖 🐱，猫猫可爱捏。\n6.30收到了如如的染卡和手写信 🥰。\n","categories":["生活"],"tags":["日记"]},{"title":"日记 2023.7","url":"/2023/07/12/%E6%97%A5%E8%AE%B0%202023.7/","content":"7.1去逛了湖北省美术馆，感受了艺术，但小孩儿好多啊，我们俩逛的都挺累。\n7.4给如如送了碎冰蓝 🌹。\n7.5送她去火车站。整理了一下她给我的零食，发现有好多啊。\n结果后来发现零食要么是临期的，要么是过期的，我还吃了一些过期的零食 😰。\n7.11和 jdk 去打舞萌碰见了 lg。\n爽跑三公里。\n7.13爽跑五公里。\n","categories":["生活"],"tags":["日记"]},{"title":"李宏毅机器学习","url":"/2023/07/14/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"Self-Attention\nMulti-head Self-attention\nTransformerEncoder\nDecoder\n\nEncoder-Decoder\nLSTM\n\n","categories":["学习笔记"],"tags":["人工智能","机器学习"]},{"title":"端到端组合优化","url":"/2023/09/03/%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/","content":"Memory-efficient Transformer-based network model for TravelingSalesman ProblemHua Yang, Minghao Zhao, Lei Yuan, Yang Yu, Zhenhua Li, and Ming Gu. “Memory-efficient Transformer-based network model for Traveling Salesman Problem.”, Neural Networks 161 (2023): 589-597.\n 模型在解决  中存在局限性：\n计算复杂度是二次的， 中的操作导致时间和空间的复杂度为 。（ 是输入序列的长度）\n内存需求过高，导致内存不足。\n强化学习中马尔可夫决策过程的变量为：状态， 为当前已访问的节点的有序序列。动作， 为下一个访问的节点。奖励，$r(a_i,s_i)=-||x_{\\pi_i}-x_{\\pi_{i+1}}||2。转移，从当前为访问过的节点集合中选择一个点，加入到已访问的节点集合中。策略，p_\\theta (\\pi | s)为一个神经网络，\\theta是网络的可训练权值。$p_\\theta (\\pi | s)=\\prod{i=1}^n p_\\theta (\\pi_i|\\pi_{1 \\dots i-1}, s)$$\nTspformer architecture\n 中的  被定义为：， 是序列长度， 是头的个数， 是嵌入维度。（实验中 ）\n其中主要的注意力来自于点积值，可以对查询数据进行采样，从而使得矩阵乘法运算的数据减少。\n采样  的个数为 ， 是一个微调参数，。采样  表示为 。\n用矩阵乘法来求  和  的兼容性： 取概率最高的前  个值为 ，即为值最大的前  个值。然后根据  对数据查询进行采样，得到 。\n再次计算  和  的兼容性：屏蔽访问过的节点后，计算注意力值：这里  都是可学习的矩阵。这里假定线性投影的隐藏维度都一样大，。（实验中 ）\n\nEncoder  的  和  的  的区别只有将  换为了 。\nDecoder  的  去掉了  的  中的第一个组件，即 。用自回归来每一次预测节点，用贪婪搜索和束搜索来改善解空间。\nModel training with reinforcement learning损失函数：用随机梯度下降和策略梯度方法来优化参数，用  算法来计算梯度的更新：用贪婪算法来作为 。\n为了构造  和单次采样，用蒙特卡洛抽样来采样 ：\nLearning to Iteratively Solve Routing Problems with Dual-Aspect Collaborative TransformerYining Ma, Jingwen Li, Zhiguang Cao, Wen Song, Le Zhang, Zhenghua Chen, and Jing Tang. “Learning to Iteratively Solve Routing Problems with Dual-Aspect Collaborative Transformer.”, Conference on Neural Information Processing Systems abs/2110.02544 (2021): 11096-11107.\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"第 29 次 CCF 计算机软件能力认证","url":"/2023/03/30/%E7%AC%AC%2029%20%E6%AC%A1%20CCF%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/","content":"T1 100:\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,x,y,ans;int main(){    read(n),read(x),read(y);    for(int i=1;i&lt;=n;++i)    {        ll a,b,c,d;        read(a),read(b),read(c),read(d);        a=max(a,(ll)0);        b=max(b,(ll)0);        c=max(c,(ll)0);        d=max(d,(ll)0);        a=min(a,x);        c=min(c,x);        b=min(b,y);        d=min(d,y);        ans+=(c-a)*(d-b);    }    cout&lt;&lt;ans;    return 0;}\n\nT2 100:\n#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,k,ans,l,r;ll t[maxn],c[maxn];bool check(ll x){\tll res=m;    for(int i=1;i&lt;=n;++i)    {        ll v=t[i]-x;        if(v&lt;=0) continue;        res-=v*c[i];        if(res&lt;0) return false;    }    return true;}int main(){    read(n),read(m),read(k),l=k;    for(int i=1;i&lt;=n;++i) read(t[i]),read(c[i]),r=max(r,t[i]);    while(l&lt;=r)    {        ll mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,r=mid-1;        else l=mid+1;    }    cout&lt;&lt;ans;    return 0;}\n\nT3 100:\n#include&lt;bits/stdc++.h&gt;#define maxn 2510using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,q;int dn[maxn];char s[maxn];unordered_map&lt;int,int&gt; mp[maxn];bitset&lt;maxn&gt; f(int l,int r){    if(s[l]=='&amp;'||s[l]=='|')    {        int l1,r1,l2,r2;        l1=l+1,r1=l1;        int num=0;        while(r1&lt;=r)        {            if(s[r1]=='(') num++;            if(s[r1]==')') num--;            if(num==0) break;            r1++;        }        l2=r1+1,r2=r;        if(s[l]=='&amp;') return f(l1+1,r1-1)&amp;f(l2+1,r2-1);        else return f(l1+1,r1-1)|f(l2+1,r2-1);    }    else    {        int pos;        for(int i=l;i&lt;=r;++i)            if(!isdigit(s[i]))                pos=i;        int x=0,y=0;        for(int i=l;i&lt;=pos-1;++i) x=s[i]-'0'+x*10;        for(int i=pos+1;i&lt;=r;++i) y=s[i]-'0'+y*10;        bitset&lt;maxn&gt; b;        if(s[pos]==':')        {            for(int i=1;i&lt;=n;++i)            {                if(!mp[i].count(x)) b[i]=0;                else                {                    if(mp[i][x]==y) b[i]=1;                    else b[i]=0;                }            }        }        else        {            for(int i=1;i&lt;=n;++i)            {                if(!mp[i].count(x)) b[i]=0;                else                {                    if(mp[i][x]!=y) b[i]=1;                    else b[i]=0;                }            }        }        return b;    }}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        read(dn[i]);        int num;        read(num);        while(num--)        {            int x,y;            read(x),read(y);            mp[i][x]=y;        }    }    read(q);    while(q--)    {        scanf(\"%s\",s+1);        int len=strlen(s+1);        bitset&lt;maxn&gt; ans=f(1,len);        vector&lt;int&gt; v;        for(int i=1;i&lt;=n;++i)            if(ans[i])                v.push_back(dn[i]);        sort(v.begin(),v.end());        for(int i=0;i&lt;v.size();++i) printf(\"%d \",v[i]);        puts(\"\");    }    return 0;}\n\nT4 60:\n#include&lt;bits/stdc++.h&gt;#define maxn using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,q;struct node{    int id;    vector&lt;int&gt; l,r;};set&lt;node&gt; s;bool operator &lt; (const node &amp;a,const node &amp;b){    int siz=a.r.size();    for(int i=0;i&lt;m;++i)        if(a.r[i]!=b.r[i])            return a.r[i]&lt;b.r[i];    return false;}bool operator == (const node &amp;a,const node &amp;b){    return a.id==b.id&amp;&amp;a.l==b.l&amp;&amp;a.r==b.r;}vector&lt;int&gt; operator - (const vector&lt;int&gt; &amp;a,const int &amp;b){    vector&lt;int&gt; c=a;    for(int i=m-1;i&gt;=0;--i)    {        if(c[i])        {            c[i]-=b;            return c;        }        else        {            c[i]+=16;            c[i]-=b;        }    }    return c;}vector&lt;int&gt; get(string str){    vector&lt;int&gt; v;    int len=str.size();    for(int i=0;i&lt;len;i+=5)    {        int val=0;        for(int j=i;j&lt;i+4;++j)        {            int x;            if(isdigit(str[j])) x=str[j]-'0';            else            {                if(str[j]=='a') x=10;                if(str[j]=='b') x=11;                if(str[j]=='c') x=12;                if(str[j]=='d') x=13;                if(str[j]=='e') x=14;                if(str[j]=='f') x=15;            }            val=val*16+x;        }        v.push_back(val);    }    return v;}vector&lt;int&gt; R(){    string str;    cin&gt;&gt;str;    return get(str);}set&lt;node&gt;::iterator find(vector&lt;int&gt; &amp;x){    return s.lower_bound((node){0,x,x});}void work1(){    int x;    vector&lt;int&gt; l,r;    set&lt;node&gt;::iterator t1,t2,it;    read(x),l=R(),r=R();    t1=find(l),t2=find(r);    if(t1==s.end()&amp;&amp;t2==s.end())    {        puts(\"YES\");        s.insert((node){x,l,r});        return;    }    if(r&lt;(*t1).l)    {        puts(\"YES\");        s.insert((node){x,l,r});        return;    }    if((*t1)==(*t2)&amp;&amp;!(l&lt;(*t1).l))    {        puts(\"NO\");        return;    }    vector&lt;node&gt; v;    for(set&lt;node&gt;::iterator it=t1;it!=s.end();++it)    {        if(it==s.end()) break;        if(x!=(*it).id)        {            puts(\"NO\");            return;        }        v.push_back(*it);        if(it==t2) break;    }    for(int i=0;i&lt;v.size();++i) s.erase(v[i]);    if(v[0].l&lt;l) l=v[0].l;    if(r&lt;v[v.size()-1].r) r=v[v.size()-1].r;    puts(\"YES\");    node tmp=(node){x,l,r},ttmp;    s.insert(tmp);    it=find(r);    if(it!=s.begin())    {        t1=it,t1--;        if((*t1).r==tmp.l-1&amp;&amp;(*t1).id==x)        {            ttmp=(node){x,(*t1).l,tmp.r};            s.erase(t1),s.erase(tmp);            tmp=ttmp;            s.insert(tmp);        }    }    it=find(r);    t1=it,t1++;    if(t1!=s.end())    {        if(tmp.r==(*t1).l-1&amp;&amp;(*t1).id==x)        {            ttmp=(node){x,tmp.l,(*t1).r};            s.erase(t1),s.erase(tmp);            tmp=ttmp;            s.insert(tmp);        }    }}void work2(){    vector&lt;int&gt; x;    x=R();    set&lt;node&gt;::iterator it;    it=find(x);    if(it==s.end())    {        puts(\"0\");        return;    }    if(x&lt;(*it).l)    {        puts(\"0\");        return;    }    printf(\"%d\\n\",(*it).id);}void work3(){    vector&lt;int&gt; l,r;    set&lt;node&gt;::iterator t1,t2;    l=R(),r=R();    t1=find(l),t2=find(r);    if(t1==s.end()||t2==s.end())    {        puts(\"0\");        return;    }    if(t1!=t2)    {        puts(\"0\");        return;    }    if(l&lt;(*t1).l)    {        puts(\"0\");        return;    }    printf(\"%d\\n\",(*t1).id);}int main(){    read(n),read(q),m=n/16;    while(q--)    {        int opt;        read(opt);        if(opt==1) work1();        if(opt==2) work2();        if(opt==3) work3();    }    return 0;}\n\nT5 60:\n#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;ll ans;int l[maxn],r[maxn],id[maxn];set&lt;pair&lt;int,int&gt; &gt; s;map&lt;pair&lt;int,int&gt;,bool&gt; mp;bool vis[maxn],V[maxn],vis2[maxn];ll calc(int R){    if(V[R]) return 0;    V[R]=true;    ll val=0;    for(int i=1;i&lt;=m;++i) vis[i]=false;    for(int i=1;i&lt;=n;++i) vis2[i]=false;    int pos=0,id=0,mx=0;    for(int i=1;i&lt;=m;++i)    {        if(l[i]&gt;pos&amp;&amp;r[i]==R)        {            pos=l[i];            id=i;        }    }    vis[id]=true;    vis2[pos]=true;    val++;    priority_queue&lt;pair&lt;int,int&gt; &gt; q;    for(int i=1;i&lt;=m;++i)    {        if(vis[i]) continue;        if(r[i]&lt;=R)        {            q.push(make_pair(l[i],r[i]));        }    }    while(!q.empty())    {        int l=q.top().first,r=q.top().second;        q.pop();        if(r&gt;=pos-1&amp;&amp;l&lt;pos)        {            pos=l;            if(!vis2[pos])            {                vis2[pos]=true;                val++;            }        }    }    return val;}int main(){    read(n),read(m);    for(int i=1;i&lt;=m;++i) read(l[i]),read(r[i]);    for(int i=1;i&lt;=m;++i) ans+=calc(r[i]);    cout&lt;&lt;ans;    return 0;}\n","categories":["题解"],"tags":["CSP"]},{"title":"边缘计算","url":"/2023/09/24/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/","content":"Edge IntelligencePyramid: Enabling Hierarchical Neural Networks with Edge ComputingQiang He, Zeqian Dong, Feifei Chen, Shuiguang Deng, Weifa Liang, and Yun Yang. “Pyramid: Enabling Hierarchical Neural Networks with Edge Computing”, The Web Conference (2022): 1860-1870.\n云端的  模型存在固有的局限性。首先，其对于延迟敏感的应用，很难保持低延迟。其次，它会在已经承受很对压力的回程网络上产生过多的流量。（回程指核心网或骨干网与网络边缘的小子网之间的中间链路）\n边缘计算提供一种新的计算模式，使网络边缘的  克服了上述限制。在边缘计算环境中，配置了计算资源的边缘服务器被部署在基站或者接入点。这使得  模型可以在边缘服务器而不是远程的云服务器上进行训练和部署。\n本篇论文提出了一种新的框架，，来在边缘服务器实现 ，在云服务器实现 。\nPROBLEM STATEMENT\n 个地区被  条高速相连。第  个地区有  个道路传感器，。所有的道路传感器为 。每条高速上至少有  个高速传感器，两个端点各一个，中点一个，。总共有  个高速传感器，总共为 。\n用邻接矩阵来表示距离，$A^{rr}k \\in \\mathbb R ^{N_k \\times N_k},A^{rf}l \\in \\mathbb R ^{(N{k_1} \\times N{k_2}) \\times 3},A^{ff}$。\n在时间  内传感器采集的历史交通数据为 ，总共为 $\\mathcal X =(\\mathcal{X}1,\\dots,\\mathcal{X}N,\\mathcal{X}{N+1},\\dots,\\mathcal{X}{N+M})$。\n分层交通预测的目标是预测  时间的道路交通状况 $\\mathcal{X}{T+1}^r和高速交通状况\\mathcal{X}{T+1}^f$。\nPYRAMID NEURAL NETWORK 由部署在边缘服务器上的  和部署在云服务器上的  两个主要部分组成。\n\nLocal Prediction\n\n 由  三部分组成。\n之前获取时空道路交通相关性的方法都是采用了两个时间块和中间一个空间块的“三明治”结构。但堆叠三明治之间的时间块会产生额外的开销。针对该问题， 采用了“双层三明治”结构，由三个时间块与两个空间块交织组成。\nData Modeling\n将道路传感器收集到的历史交通数据放入  可读的矩阵中：Feature Extraction\n 采用时间块从输入矩阵  中提取时间道路交通特征。时间块中包含 ，其可以将线性和非线性特征都传输到后续层：其中  是  激活层。\n空间块的主要组成部分是 ，通过图卷积来获取空间道路交通相关性：其中  是  激活层，。\nPrediction\n最后用一个全连接层来实现预测：同时， 也将被传输到  来方便全局预测。\nGlobal Prediction\n\n 由  两部分组成。\nFeature Extraction\n输入是  提取的道路交通特征： 从  中获取道路与高速的空间相关性，高速之间的空间相关性，高速的时间相关性。\n 采用了转换块来将道路交通特征  转换为高速交通特征 。其由两个稀疏层和中间的批量归一化层组成。\n第一个稀疏层将  维道路交通特征  转换为  维中间特征： 是嵌入矩阵。\n第二个稀疏层将  维中间特征转换为  维高速交通特征 ： 是嵌入矩阵。\n根据  来构建  的全局道路高速邻接矩阵 。其中  表示第  个道路传感器是否与第  个道路传感器相关。然后将  分解为  的  和  的 ，其中 。\nPrediction\n最后用一个全连接层来实现预测：\nFedEdge: Accelerating Edge-Assisted Federated LearningKaibin Wang, Qiang He, Feifei Chen, Hai Jin, and Yun Yang. “FedEdge: Accelerating Edge-Assisted Federated Learning”, WWW 2023 (2023): 2895-2904.\n\n 存在三个缺陷：\n两阶段训练期间浪费了大量时间，客户端在发送本地模型进行聚合后停止模型训练，直到使用接收到的全局模型更新本地模型。他们的等待时间可以用来加速模型训练。\n缺乏模型多样性，而数据存在多样性。\n存在模型受到中毒袭击的漏洞，边缘服务器容易受到损害。\n本文提出了  来解决以上问题。\nPRELIMINARIESFederated Learning\n研究重点是在  方案下以有限和目标训练神经网络模型：其中  是  系统中客户端的数量，每个客户端都有一个本地训练数据集 。 是第 k 个客户的局部损失函数，衡量  的局部经验风险：其中  是训练样本， 是交叉熵损失函数。\nEdge-Assisted Federated Learning\n考虑一个  系统，客户端用 ， 表示，以及一组覆盖这些客户端的  个边缘服务器，用  表示，以及云服务器 。每个边缘服务器  覆盖客户端的一个子集 。 每个客户端  都拥有一个本地数据集 $D_{u_i}={(x_i,y_i)}{j=1}^{|D{u_i}|}。其中x_j表示第j个输入样本，y_j是x_j$ 的相应标记输出。\n 与现有的边缘辅助  方案有着相同的基本训练流程：\n，客户端在自己的数据集上训练本地模型，然后将本地模型传输到相应的边缘服务器。\n，每个边缘服务器通过聚合其客户端的本地模型来生成中间模型，并将中间模型传输到云服务器。\n，云服务器通过聚合从边缘服务器接收到的中间模型来生成全局模型。\n，云服务器将全局模型发送至边缘服务器；边缘服务器将全局模型发送给其客户端；最后，客户更新他们的本地模型并进入下一轮训练。\nFINDINGS OF OUR EXPLORATIONTraining Time Wasting\n\nLack of Model Diversity Consideration\n利用模型多样性后，模型精度和模型收敛性均有提升。\nVulnerability to Model Poisoning Attacks\nFEDEDGE DESIGNAsynchronous Local Federated Training\n\nAdaptive Model Aggregation\nPhase 1: Filtering Anomalous Models\n\nPhase 2: Aggregating Models\nEdgeMove: Pipelining Device-Edge Model Training for Mobile IntelligenceZeqian Dong, Qiang He, Feifei Chen, Hai Jin, Tao Gu, and Yun Yang. “EdgeMove: Pipelining Device-Edge Model Training for Mobile Intelligence”, WWW 2023 (2023): 3142-3153.\n","categories":["学习笔记"],"tags":["论文","边缘计算"]},{"title":"算法竞赛模板","url":"/2023/07/30/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%A8%A1%E6%9D%BF/","content":"数据结构线段树合并#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 20000010#define all 100000#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot;int ans[maxn],f[maxn][19],dep[maxn],rt[maxn],mx[maxm],id[maxm],ls[maxm],rs[maxm];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void dfs_pre(int x,int fa){    dep[x]=dep[f[x][0]=fa]+1;    for(int i=1;i&lt;=16;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_pre(y,x);    }}int lca(int x,int y){\tif(dep[x]&lt;dep[y]) swap(x,y);\tfor(int i=16;i&gt;=0;--i)\t\tif(f[x][i]&amp;&amp;dep[f[x][i]]&gt;=dep[y])\t\t\tx=f[x][i];\tif(x==y) return x;\tfor(int i=16;i&gt;=0;--i)\t\tif(f[x][i]&amp;&amp;f[x][i]!=f[y][i])\t\t\tx=f[x][i],y=f[y][i];\treturn f[x][0];}void pushup(int cur){\tif(mx[ls[cur]]&gt;=mx[rs[cur]]) mx[cur]=mx[ls[cur]],id[cur]=id[ls[cur]];\telse mx[cur]=mx[rs[cur]],id[cur]=id[rs[cur]];}void modify(int l,int r,int pos,int v,int &amp;cur){\tif(!cur) cur=++tot;\tif(l==r)\t{\t\tmx[cur]+=v,id[cur]=l;\t\treturn;\t}\tif(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);\telse modify(mid+1,r,pos,v,rs[cur]);\tpushup(cur);}int merge(int x,int y,int l,int r){\tif(!x||!y) return x+y;\tif(l==r)\t{\t\tmx[x]+=mx[y];\t\treturn x;\t}\tls[x]=merge(ls[x],ls[y],l,mid);\trs[x]=merge(rs[x],rs[y],mid+1,r);\tpushup(x);\treturn x;}void dfs_ans(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==f[x][0]) continue;\t\tdfs_ans(y),rt[x]=merge(rt[x],rt[y],1,all);\t}\tans[x]=mx[rt[x]]?id[rt[x]]:0;}int main(){    read(n),read(m);    for(int i=1;i&lt;n;++i)    {    \tint x,y;    \tread(x),read(y);    \tadd(x,y),add(y,x);    }    dfs_pre(1,0);    for(int i=1;i&lt;=m;++i)    {    \tint x,y,v,anc;    \tread(x),read(y),read(v),anc=lca(x,y);    \tmodify(1,all,v,1,rt[x]),modify(1,all,v,1,rt[y]);    \tmodify(1,all,v,-1,rt[anc]),modify(1,all,v,-1,rt[f[anc][0]]);    }    dfs_ans(1);    for(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]);    return 0;}\n\n线段树分裂维护若干个可重集。\n#include&lt;bits/stdc++.h&gt;#define maxn 80000010#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot,num=1;int rt[maxn],ls[maxn],rs[maxn];ll cnt[maxn];void pushup(int cur){    cnt[cur]=cnt[ls[cur]]+cnt[rs[cur]];}void modify(int l,int r,int pos,ll v,int &amp;cur){    if(!cur) cur=++tot;    if(l==r)    {        cnt[cur]+=v;        return;    }    if(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);    else modify(mid+1,r,pos,v,rs[cur]);    pushup(cur);}ll query(int L,int R,int l,int r,int cur){    if(!cur) return 0;    if(L&lt;=l&amp;&amp;R&gt;=r) return cnt[cur];    ll v=0;    if(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);    if(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);    return v;}int kth(int l,int r,ll k,int cur){    if(l==r) return l;    if(cnt[ls[cur]]&gt;=k) return kth(l,mid,k,ls[cur]);    else return kth(mid+1,r,k-cnt[ls[cur]],rs[cur]);}int merge(int x,int y){    if(!x||!y) return x+y;    int p=++tot;    cnt[p]=cnt[x]+cnt[y];    ls[p]=merge(ls[x],ls[y]);    rs[p]=merge(rs[x],rs[y]);    return p;}void split(int L,int R,int l,int r,int &amp;x,int &amp;y){    if(!x) return;    if(L&lt;=l&amp;&amp;R&gt;=r)    {        y=x,x=0;        return;    }    y=++tot;    if(L&lt;=mid) split(L,R,l,mid,ls[x],ls[y]);    if(R&gt;mid) split(L,R,mid+1,r,rs[x],rs[y]);    pushup(x),pushup(y);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i)    {        ll x;        read(x),modify(1,n,i,x,rt[1]);    }    while(m--)    {        int opt,p;        ll x,y,k;        read(opt),read(p);        if(opt==1||opt==4) read(k);        else read(x),read(y);        if(opt==0) split(x,y,1,n,rt[p],rt[++num]);        if(opt==1) rt[p]=merge(rt[p],rt[k]);        if(opt==2) modify(1,n,y,x,rt[p]);        if(opt==3) printf(\"%lld\\n\",query(x,y,1,n,rt[p]));        if(opt==4)        {            if(cnt[rt[p]]&lt;k) puts(\"-1\");            else printf(\"%d\\n\",kth(1,n,k,rt[p]));        }    }    return 0;}\n\n吉司机线段树区间加，区间取 ，区间求和，区间最大值，区间历史最大值。\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010#define inf 20000000000#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,root=1;ll a[maxn],ma[maxn],hma[maxn],se[maxn],cnt[maxn],sum[maxn];ll tag[maxn],htag[maxn],add[maxn],hadd[maxn];void pushup(int cur){    sum[cur]=sum[ls]+sum[rs],ma[cur]=max(ma[ls],ma[rs]),hma[cur]=max(hma[ls],hma[rs]);    if(ma[ls]==ma[rs]) se[cur]=max(se[ls],se[rs]),cnt[cur]=cnt[ls]+cnt[rs];    else if(ma[ls]&gt;ma[rs]) se[cur]=max(se[ls],ma[rs]),cnt[cur]=cnt[ls];    else se[cur]=max(ma[ls],se[rs]),cnt[cur]=cnt[rs];}void pushtag(int cur,int l,int r,ll v,ll hv,ll w,ll hw){    sum[cur]+=v*cnt[cur]+w*(r-l+1-cnt[cur]);    hma[cur]=max(hma[cur],ma[cur]+hv),ma[cur]+=v;    htag[cur]=max(htag[cur],tag[cur]+hv),tag[cur]+=v;    hadd[cur]=max(hadd[cur],add[cur]+hw),add[cur]+=w;    if(se[cur]!=-inf) se[cur]+=w;}void pushdown(int cur,int l,int r){    ll maxv=max(ma[ls],ma[rs]);    if(ma[ls]==maxv) pushtag(ls,l,mid,tag[cur],htag[cur],add[cur],hadd[cur]);    else pushtag(ls,l,mid,add[cur],hadd[cur],add[cur],hadd[cur]);    if(ma[rs]==maxv) pushtag(rs,mid+1,r,tag[cur],htag[cur],add[cur],hadd[cur]);    else pushtag(rs,mid+1,r,add[cur],hadd[cur],add[cur],hadd[cur]);    tag[cur]=htag[cur]=add[cur]=hadd[cur]=0;}void build(int l,int r,int cur){    if(l==r)    {        sum[cur]=ma[cur]=hma[cur]=a[l],se[cur]=-inf,cnt[cur]=1;        return;    }    build(l,mid,ls),build(mid+1,r,rs),pushup(cur);}void modify_add(int L,int R,int l,int r,ll v,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        pushtag(cur,l,r,v,v,v,v);        return;    }    pushdown(cur,l,r);    if(L&lt;=mid) modify_add(L,R,l,mid,v,ls);    if(R&gt;mid) modify_add(L,R,mid+1,r,v,rs);    pushup(cur);}void modify_min(int L,int R,int l,int r,ll v,int cur){    if(v&gt;=ma[cur]) return;    if(L&lt;=l&amp;&amp;R&gt;=r&amp;&amp;v&gt;se[cur])    {        pushtag(cur,l,r,v-ma[cur],v-ma[cur],0,0);        return;    }    pushdown(cur,l,r);    if(L&lt;=mid) modify_min(L,R,l,mid,v,ls);    if(R&gt;mid) modify_min(L,R,mid+1,r,v,rs);    pushup(cur);}ll query_sum(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];    pushdown(cur,l,r);    ll ans=0;    if(L&lt;=mid) ans+=query_sum(L,R,l,mid,ls);    if(R&gt;mid) ans+=query_sum(L,R,mid+1,r,rs);    return ans;}ll query_max(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return ma[cur];    pushdown(cur,l,r);    ll ans=-inf;    if(L&lt;=mid) ans=max(ans,query_max(L,R,l,mid,ls));    if(R&gt;mid) ans=max(ans,query_max(L,R,mid+1,r,rs));    return ans;}ll query_his(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return hma[cur];    pushdown(cur,l,r);    ll ans=-inf;    if(L&lt;=mid) ans=max(ans,query_his(L,R,l,mid,ls));    if(R&gt;mid) ans=max(ans,query_his(L,R,mid+1,r,rs));    return ans;}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    build(1,n,root);    while(m--)    {        int opt,l,r,v;        read(opt),read(l),read(r);        if(opt==1||opt==2) read(v);        if(opt==1) modify_add(l,r,1,n,v,root);        if(opt==2) modify_min(l,r,1,n,v,root);        if(opt==3) printf(\"%lld\\n\",query_sum(l,r,1,n,root));        if(opt==4) printf(\"%lld\\n\",query_max(l,r,1,n,root));        if(opt==5) printf(\"%lld\\n\",query_his(l,r,1,n,root));    }    return 0;}\n\n线段树优化建图void build_in(int L,int R,int &amp;cur){    cur=++tree_cnt;    if(L==R)    {        in_num[L]=cur;        return;    }    int mid=(L+R)&gt;&gt;1;    build_in(L,mid,ls[cur]);    build_in(mid+1,R,rs[cur]);    add(ls[cur],cur,0),add(rs[cur],cur,0);}void build_out(int L,int R,int &amp;cur){    cur=++tree_cnt;    if(L==R)    {        out_num[L]=cur;        return;    }    int mid=(L+R)&gt;&gt;1;    build_out(L,mid,ls[cur]);    build_out(mid+1,R,rs[cur]);    add(cur,ls[cur],0),add(cur,rs[cur],0);}void modify_in(int L,int R,int l,int r,int pos,int val,int &amp;cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        add(cur,pos,val);        return;    }    int mid=(l+r)&gt;&gt;1;    if(L&lt;=mid) modify_in(L,R,l,mid,pos,val,ls[cur]);    if(R&gt;mid) modify_in(L,R,mid+1,r,pos,val,rs[cur]);}void modify_out(int L,int R,int l,int r,int pos,int val,int &amp;cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        add(pos,cur,val);        return;    }    int mid=(l+r)&gt;&gt;1;    if(L&lt;=mid) modify_out(L,R,l,mid,pos,val,ls[cur]);    if(R&gt;mid) modify_out(L,R,mid+1,r,pos,val,rs[cur]);}\n\n线段树分治删去无向连通图一些边后，询问原图是否连通。将删边转化为边存在的区间，用带权并查集维护连通块大小。\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 400010#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,k,top;int fa[maxn],siz[maxn],pre[maxn];bool ans[maxn];vector&lt;int&gt; ve[maxm];struct node{    int x,y;    node(int a=0,int b=0)    {    \tx=a,y=b;    }}e[maxn],st[maxn];int find(int x){    return fa[x]==x?x:find(fa[x]);}void merge(int x,int y){    x=find(x),y=find(y);    if(x==y) return;    if(siz[x]&lt;siz[y]) swap(x,y);    st[++top]=node(x,y),fa[y]=x,siz[x]+=siz[y];}void insert(int L,int R,int l,int r,int id,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        ve[cur].push_back(id);        return;    }    if(L&lt;=mid) insert(L,R,l,mid,id,ls);    if(R&gt;mid) insert(L,R,mid+1,r,id,rs);}void del(int id){    int x=st[id].x,y=st[id].y;    fa[y]=y,siz[x]-=siz[y];}void dfs(int l,int r,int cur){    int now=top;    for(int i=0;i&lt;ve[cur].size();++i)\t\tmerge(e[ve[cur][i]].x,e[ve[cur][i]].y);    if(l==r) ans[l]=siz[find(1)]==n;    else dfs(l,mid,ls),dfs(mid+1,r,rs);    while(top&gt;now) del(top--);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) siz[fa[i]=i]=1;    for(int i=1;i&lt;=m;++i) read(e[i].x),read(e[i].y),pre[i]=1;    read(k);    for(int i=1;i&lt;=k;++i)    {        int c;        read(c);        while(c--)        {            int id;            read(id);            if(pre[id]&lt;i) insert(pre[id],i-1,1,k,id,1);            pre[id]=i+1;        }    }    for(int i=1;i&lt;=m;++i)        if(pre[i]&lt;=k)            insert(pre[i],k,1,k,i,1);    dfs(1,k,1);    for(int i=1;i&lt;=k;++i) puts(ans[i]?\"Connected\":\"Disconnected\");\treturn 0;}\n\n李超线段树支持插入直线，查询单点最值。\n，斜率优化，维护下凸壳。\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 4000010#define all 1000000#define inf 1000000000000#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot,root;int ls[maxm],rs[maxm],num[maxm];ll h[maxn],s[maxn],k[maxn],b[maxn],f[maxn];ll y(int id,ll x){    return k[id]*x+b[id];}void insert(int l,int r,int id,int &amp;cur){    if(!cur)\t{\t\tnum[cur=++tot]=id;\t\treturn;\t}\tif(y(id,mid)&lt;y(num[cur],mid)) swap(id,num[cur]);\tif(y(id,l)&gt;=y(num[cur],l)&amp;&amp;y(id,r)&gt;=y(num[cur],r)) return;\tif(y(id,l)&lt;y(num[cur],l)) insert(l,mid,id,ls[cur]);\telse insert(mid+1,r,id,rs[cur]);}ll query(int l,int r,int x,int cur){    if(!cur) return inf;    ll v=y(num[cur],x);    if(x&lt;=mid) v=min(v,query(l,mid,x,ls[cur]));    else v=min(v,query(mid+1,r,x,rs[cur]));    return v;}int main(){    read(n);    for(int i=1;i&lt;=n;++i) read(h[i]);    for(int i=1;i&lt;=n;++i) read(s[i]),s[i]+=s[i-1];    for(int i=1;i&lt;=n;++i)    {        if(i!=1) f[i]=query(0,all,h[i],root)+h[i]*h[i]+s[i-1];        k[i]=-2*h[i],b[i]=f[i]+h[i]*h[i]-s[i],insert(0,all,i,root);    }    printf(\"%lld\",f[n]);    return 0;}\n\n重链剖分#include&lt;bits/stdc++.h&gt;#define maxn 400010#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,rt,root=1,cnt;ll p;int siz[maxn],fa[maxn],dfn[maxn],top[maxn],son[maxn],dep[maxn],rev[maxn];ll a[maxn],sum[maxn],tag[maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void pushup(int cur){\tsum[cur]=(sum[ls]+sum[rs])%p;}void pushtag(int cur,int l,int r,ll v){\tsum[cur]=(sum[cur]+v*(r-l+1)%p)%p,tag[cur]=(tag[cur]+v)%p;}void pushdown(int cur,int l,int r){\tif(!tag[cur]) return;\tpushtag(ls,l,mid,tag[cur]),pushtag(rs,mid+1,r,tag[cur]),tag[cur]=0;}void build(int l,int r,int cur){\tif(l==r)\t{\t\tsum[cur]=a[rev[l]];\t\treturn;\t}\tbuild(l,mid,ls),build(mid+1,r,rs),pushup(cur);}void modify(int L,int R,int l,int r,int v,int cur){\tif(L&lt;=l&amp;&amp;R&gt;=r)\t{\t\tpushtag(cur,l,r,v);\t\treturn;\t}\tpushdown(cur,l,r);\tif(L&lt;=mid) modify(L,R,l,mid,v,ls);\tif(R&gt;mid) modify(L,R,mid+1,r,v,rs);\tpushup(cur);}ll query(int L,int R,int l,int r,int cur){\tif(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];\tll v=0;    pushdown(cur,l,r);\tif(L&lt;=mid) v=(v+query(L,R,l,mid,ls))%p;\tif(R&gt;mid) v=(v+query(L,R,mid+1,r,rs))%p;\treturn v;}void update(int x,int y,int v){\twhile(top[x]!=top[y])\t{\t\tif(dep[top[x]]&lt;dep[top[y]]) swap(x,y);\t\tmodify(dfn[top[x]],dfn[x],1,n,v,root),x=fa[top[x]];\t}\tif(dep[x]&gt;dep[y]) swap(x,y);\tmodify(dfn[x],dfn[y],1,n,v,root);}ll ask(int x,int y){\tll v=0;\twhile(top[x]!=top[y])\t{\t\tif(dep[top[x]]&lt;dep[top[y]]) swap(x,y);\t\tv=(v+query(dfn[top[x]],dfn[x],1,n,root))%p,x=fa[top[x]];\t}\tif(dep[x]&gt;dep[y]) swap(x,y);\treturn (v+query(dfn[x],dfn[y],1,n,root))%p;}void dfs_son(int x,int fath){\tfa[x]=fath,dep[x]=dep[fath]+1,siz[x]=1;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fath) continue;\t\tdfs_son(y,x),siz[x]+=siz[y];\t\tif(siz[y]&gt;siz[son[x]]) son[x]=y;\t}}void dfs_chain(int x,int tp){\tdfn[x]=++cnt,rev[cnt]=x,top[x]=tp;\tif(son[x]) dfs_chain(son[x],tp);\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(dfn[y]) continue;\t\tdfs_chain(y,y);\t}}int main(){ \tread(n),read(m),read(rt),read(p);\tfor(int i=1;i&lt;=n;++i) read(a[i]);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs_son(rt,0),dfs_chain(rt,rt),build(1,n,root);\twhile(m--)\t{\t\tint opt,x,y,v;\t\tread(opt),read(x);\t\tif(opt==1) read(y),read(v),update(x,y,v);\t\tif(opt==2) read(y),printf(\"%lld\\n\",ask(x,y));\t\tif(opt==3) read(v),modify(dfn[x],dfn[x]+siz[x]-1,1,n,v,root);\t\tif(opt==4) printf(\"%lld\\n\",query(dfn[x],dfn[x]+siz[x]-1,1,n,root));\t}\treturn 0;}\n\n主席树静态区间第  小。\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot,num;int a[maxn],s[maxn],rt[maxn],cnt[maxm],ls[maxm],rs[maxm];void modify(int l,int r,int pos,int &amp;cur){    int x=++tot;    ls[x]=ls[cur],rs[x]=rs[cur],cnt[x]=cnt[cur]+1,cur=x;    if(l==r) return;    if(pos&lt;=mid) modify(l,mid,pos,ls[cur]);    else modify(mid+1,r,pos,rs[cur]);}int query(int l,int r,int k,int x,int y){    if(l==r) return l;    if(k&gt;cnt[ls[y]]-cnt[ls[x]]) return query(mid+1,r,k-cnt[ls[y]]+cnt[ls[x]],rs[x],rs[y]);    return query(l,mid,k,ls[x],ls[y]);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]),s[i]=a[i];    sort(s+1,s+n+1),num=unique(s+1,s+n+1)-s-1;    for(int i=1;i&lt;=n;++i) rt[i]=rt[i-1],modify(1,num,lower_bound(s+1,s+num+1,a[i])-s,rt[i]);    while(m--)    {        int l,r,k;        read(l),read(r),read(k);        printf(\"%d\\n\",s[query(1,num,k,rt[l-1],rt[r])]);    }    return 0;}\n\n可持久化并查集合并不采用路径压缩，保证每次合并只修改一个节点的父亲，使当前版本与上一版本共用的节点尽可能的多。为防止并查集退化成链，采取按秩合并。\n#include&lt;bits/stdc++.h&gt;#define maxn 10000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,tree_cnt;int ls[maxn],rs[maxn],root[maxn],a[maxn],fa[maxn],de[maxn];void build(int L,int R,int &amp;cur){\tcur=++tree_cnt;\tif(L==R)\t{\t\tfa[cur]=L;\t\treturn;\t}\tint mid=(L+R)&gt;&gt;1;\tbuild(L,mid,ls[cur]);\tbuild(mid+1,R,rs[cur]);}void merge(int L,int R,int pos,int fath,int pre,int &amp;cur){\tcur=++tree_cnt;\tif(L==R)\t{\t\tfa[cur]=fath;\t\tde[cur]=de[pre];\t\treturn;\t}\tls[cur]=ls[pre],rs[cur]=rs[pre];\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) merge(L,mid,pos,fath,ls[pre],ls[cur]);\tif(pos&gt;mid) merge(mid+1,R,pos,fath,rs[pre],rs[cur]);}int query(int L,int R,int pos,int cur){\tif(L==R) return cur;\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) return query(L,mid,pos,ls[cur]);\tif(pos&gt;mid) return query(mid+1,R,pos,rs[cur]);}void add(int L,int R,int pos,int cur){\tif(L==R)\t{\t\tde[cur]++;\t\treturn;\t}\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) add(L,mid,pos,ls[cur]);\telse add(mid+1,R,pos,rs[cur]);}int find(int pos,int cur){\tint fath=query(1,n,pos,cur);\tif(pos==fa[fath]) return fath;\treturn find(fa[fath],cur);}int main(){\tread(n),read(m);\tbuild(1,n,root[0]);\tfor(int i=1;i&lt;=m;i++)\t{\t\tint flag,a,b;\t\tread(flag);\t\tif(flag==1)\t\t{\t\t\tread(a),read(b);\t\t\troot[i]=root[i-1];\t\t\tint u=find(a,root[i]),v=find(b,root[i]);\t\t\tif(fa[u]==fa[v]) continue;\t\t\tif(de[u]&gt;de[v]) swap(u,v);\t\t\tmerge(1,n,fa[u],fa[v],root[i-1],root[i]);\t\t\tif(de[u]==de[v]) add(1,n,fa[v],root[i]);\t\t}\t\tif(flag==2)\t\t{\t\t\tread(a);\t\t\troot[i]=root[a];\t\t}\t\tif(flag==3)\t\t{\t\t\tread(a),read(b);\t\t\troot[i]=root[i-1];\t\t\tint u=find(a,root[i]),v=find(b,root[i]);\t\t\tif(fa[u]==fa[v]) puts(\"1\");\t\t\telse puts(\"0\");\t\t}\t}\treturn 0;}\n\n平衡树插入 ，删除 ，查  的排名，查排名为  的数，查  的前驱，查  的后继。\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,last,ans,tot,root;int ls[maxn],rs[maxn],siz[maxn],key[maxn],val[maxn];int add(int v){\tval[++tot]=v,key[tot]=rand(),siz[tot]=1;\treturn tot;}void pushup(int x){\tsiz[x]=siz[ls[x]]+siz[rs[x]]+1;}void merge(int &amp;p,int x,int y){\tif(!x||!y)\t{\t\tp=x+y;\t\treturn;\t}\tif(key[x]&lt;key[y]) p=x,merge(rs[x],rs[x],y);\telse p=y,merge(ls[y],x,ls[y]);\tpushup(p);}void split(int p,int k,int &amp;x,int &amp;y){\tif(!p)\t{\t\tx=y=0;\t\treturn;\t}\tif(val[p]&lt;=k) x=p,split(rs[p],k,rs[x],y);\telse y=p,split(ls[p],k,x,ls[y]);\tpushup(p);}void insert(int v){\tint x,y;    split(root,v,x,y),merge(x,x,add(v)),merge(root,x,y);}void del(int v){\tint x,y,z;    split(root,v,x,y),split(x,v-1,x,z);    merge(z,ls[z],rs[z]),merge(x,x,z),merge(root,x,y);}int kth(int v){\tint x,y;    split(root,v-1,x,y);    int ans=siz[x]+1;    merge(root,x,y);    return ans;}int get(int p,int k){    if(k==siz[ls[p]]+1) return val[p];    if(k&lt;=siz[ls[p]]) return get(ls[p],k);    else return get(rs[p],k-siz[ls[p]]-1);}int pre(int v){\tint x,y;    split(root,v-1,x,y);    int ans=get(x,siz[x]);    merge(root,x,y);    return ans;}int nxt(int v){\tint x,y;    split(root,v,x,y);    int ans=get(y,1);    merge(root,x,y);    return ans;}int main(){    read(n),read(m);    for(int i=1,a;i&lt;=n;++i) read(a),insert(a);\twhile(m--)\t{\t\tint opt,a;\t\tread(opt),read(a),a^=last;\t\tif(opt==1) insert(a);\t\tif(opt==2) del(a);\t\tif(opt==3) last=kth(a);\t\tif(opt==4) last=get(root,a);\t\tif(opt==5) last=pre(a);\t\tif(opt==6) last=nxt(a);        if(opt!=1&amp;&amp;opt!=2) ans^=last;\t}    printf(\"%d\",ans);\treturn 0;}\n\n插入多个数，删除多个数，区间赋值，区间翻转，区间求和，区间最大子序列。\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010#define inf 500000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,tot,root,top;int fa[maxn],siz[maxn],ch[maxn][2],tag[maxn],rev[maxn],st[maxn];int val[maxn],sum[maxn],ma[maxn],a[maxn],lm[maxn],rm[maxn],c[maxn];string opt;bool check(int x){    return ch[fa[x]][1]==x;}void pushup(int x){    int ls=ch[x][0],rs=ch[x][1];    siz[x]=siz[ls]+siz[rs]+1;    sum[x]=sum[ls]+sum[rs]+val[x];    lm[x]=max(lm[ls],sum[ls]+val[x]+lm[rs]);    rm[x]=max(rm[rs],sum[rs]+val[x]+rm[ls]);    ma[x]=max(val[x]+lm[rs]+rm[ls],max(ma[ls],ma[rs]));}void pushr(int x){    rev[x]^=1,swap(ch[x][0],ch[x][1]),swap(lm[x],rm[x]);}void pushv(int x,int v){    if(!x) return;    tag[x]=1,val[x]=v,sum[x]=v*siz[x];    lm[x]=rm[x]=max(sum[x],0),ma[x]=max(sum[x],val[x]);}void pushdown(int x){    int ls=ch[x][0],rs=ch[x][1];    if(tag[x]) pushv(ls,val[x]),pushv(rs,val[x]);    if(rev[x]) pushr(ls),pushr(rs);    tag[x]=rev[x]=0;}int add(){    int x=top?st[top--]:++tot;    fa[x]=ch[x][0]=ch[x][1]=rev[x]=siz[x]=tag[x]=0;    return x;}void build(int l,int r,int &amp;x,int *a){    x=add();    int mid=(l+r)&gt;&gt;1;    lm[x]=rm[x]=max(a[mid],0);    val[x]=ma[x]=sum[x]=a[mid];    if(l&lt;mid) build(l,mid-1,ch[x][0],a);    if(r&gt;mid) build(mid+1,r,ch[x][1],a);    fa[ch[x][0]]=fa[ch[x][1]]=x;    pushup(x);}void rotate(int x){    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];    ch[z][check(y)]=x,fa[x]=z;    ch[y][k]=w,fa[w]=y;    ch[x][k^1]=y,fa[y]=x;    pushup(y),pushup(x);}void splay(int x,int goal){    for(int y;fa[x]!=goal;rotate(x))        if(fa[y=fa[x]]!=goal)            rotate(check(x)^check(y)?x:y);    if(!goal) root=x;}int kth(int x){    int p=root;    while(1)    {        pushdown(p);        int ls=ch[p][0],rs=ch[p][1];        if(ls&amp;&amp;x&lt;=siz[ls]) p=ls;        else        {            x-=siz[ls]+1;            if(!x) return p;            p=rs;        }    }}void split(int l,int r){    l=kth(l-1),r=kth(r+1),splay(l,0),splay(r,l);}void insert(int x,int num){    int t,p;    build(1,num,t,c);    split(x+1,x);    p=ch[root][1];    ch[p][0]=t,fa[t]=p;    pushup(p),pushup(root);}void del(int x){    if(!x) return;    st[++top]=x;    del(ch[x][0]),del(ch[x][1]);}void erase(int l,int r){    int p;    split(l,r);    p=ch[root][1];    del(ch[p][0]),ch[p][0]=0;    pushup(p),pushup(root);}void cover(int l,int r,int v){    int p;    split(l,r);    p=ch[root][1];    pushv(ch[p][0],v);    pushup(p),pushup(root);}void reverse(int l,int r){    int p;    split(l,r);    p=ch[root][1];    pushr(ch[p][0]);    pushup(p),pushup(root);}int query(int l,int r){    int p;    split(l,r);    p=ch[root][1];    return sum[ch[p][0]];}int main(){\tread(n),read(m);    ma[0]=a[1]=a[n+2]=-inf;    for(int i=2;i&lt;=n+1;++i) read(a[i]);    build(1,n+2,root,a);    while(m--)    {        cin&gt;&gt;opt;        int x,num,v;        if(opt==\"MAX-SUM\") printf(\"%d\\n\",ma[root]);        else read(x),read(num),x++;        if(opt==\"INSERT\")        {            for(int i=1;i&lt;=num;++i) read(c[i]);            insert(x,num);        }        if(opt==\"DELETE\") erase(x,x+num-1);        if(opt==\"MAKE-SAME\") read(v),cover(x,x+num-1,v);        if(opt==\"REVERSE\") reverse(x,x+num-1);        if(opt==\"GET-SUM\") printf(\"%d\\n\",query(x,x+num-1));    }\treturn 0;}\n\n可持久化平衡树#include&lt;bits/stdc++.h&gt;#define maxn 25000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,flag,tot,v,x,y,z;int ls[maxn],rs[maxn],siz[maxn],key[maxn],val[maxn],root[maxn];int build(int x){\tval[++tot]=x;\tsiz[tot]=1;\tkey[tot]=rand();\treturn tot;}void pushup(int x){\tsiz[x]=siz[ls[x]]+siz[rs[x]]+1;}int cpy(int x){\ttot++;\tval[tot]=val[x];\tsiz[tot]=siz[x];\tkey[tot]=key[x];\tls[tot]=ls[x];\trs[tot]=rs[x];\treturn tot;}void merge(int &amp;p,int x,int y){    if(!x||!y)    {           p=x+y;        return;    }    if(key[x]&lt;key[y]) p=cpy(x),merge(rs[p],rs[p],y);    else p=cpy(y),merge(ls[p],x,ls[p]);    pushup(p);}void split(int p,int k,int &amp;x,int &amp;y){\tif(!p)\t{\t\tx=y=0;\t\treturn;\t}\tif(val[p]&lt;=k)\t{\t\tx=cpy(p);\t\tsplit(rs[x],k,rs[x],y);\t\tpushup(x);\t}\telse\t{\t\ty=cpy(p);\t\tsplit(ls[y],k,x,ls[y]);\t\tpushup(y);\t}}int query(int p,int k){\tif(k==siz[ls[p]]+1) return val[p];\tif(k&lt;=siz[ls[p]]) return query(ls[p],k);\telse return query(rs[p],k-siz[ls[p]]-1);}int main(){\tread(n);\tfor(int i=1;i&lt;=n;++i)\t{\t\tint a;\t\tread(v),read(flag),read(a);\t\troot[i]=root[v];\t\tif(flag==1)\t\t{\t\t\tsplit(root[i],a,x,y);\t\t\tmerge(x,x,build(a));\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==2)\t\t{\t\t\tsplit(root[i],a,x,y);\t\t\tsplit(x,a-1,x,z);\t\t\tmerge(z,ls[z],rs[z]);\t\t\tmerge(x,x,z);\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==3)\t\t{\t\t\tsplit(root[i],a-1,x,y);\t\t\tprintf(\"%d\\n\",siz[x]+1);\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==4)\t\t\tprintf(\"%d\\n\",query(root[i],a));\t\tif(flag==5)\t\t{\t\t \tsplit(root[i],a-1,x,y);\t\t\tif(!siz[x]) puts(\"-2147483647\");\t\t\tprintf(\"%d\\n\",query(x,siz[x]));\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==6)\t\t{\t\t \tsplit(root[i],a,x,y);\t\t\tif(!siz[y]) puts(\"2147483647\");\t\t\telse printf(\"%d\\n\",query(y,1));\t\t\tmerge(root[i],x,y);\t\t}\t \t}\treturn 0;}\n\nLCT#include&lt;bits/stdc++.h&gt;#define maxn 300010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int fa[maxn],ch[maxn][2],rev[maxn],val[maxn],sum[maxn];bool check(int x){\treturn ch[fa[x]][1]==x;}bool notroot(int x){\treturn ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void pushup(int x){\tsum[x]=sum[ch[x][0]]^sum[ch[x][1]]^val[x];\t}void pushrev(int x){\tswap(ch[x][0],ch[x][1]),rev[x]^=1;}void pushdown(int x){\tif(rev[x]) pushrev(ch[x][0]),pushrev(ch[x][1]),rev[x]=0;}void rotate(int x){\tint y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];\tif(notroot(y)) ch[z][check(y)]=x;\tch[x][k^1]=y,ch[y][k]=w;\tif(w) fa[w]=y;\tfa[x]=z,fa[y]=x;\tpushup(y),pushup(x);}void all(int x){\tif(notroot(x)) all(fa[x]);\tpushdown(x);}void splay(int x){\tall(x);\tfor(int y;notroot(x);rotate(x))\t\tif(notroot(y=fa[x]))\t\t\trotate(check(x)^check(y)?x:y);\tpushup(x);}void access(int x){\tfor(int y=0;x;y=x,x=fa[x])\t\tsplay(x),ch[x][1]=y,pushup(x);}void makeroot(int x){\taccess(x),splay(x),pushrev(x);}void split(int x,int y){\tmakeroot(x),access(y),splay(y);}int findroot(int x){\taccess(x),splay(x);\twhile(ch[x][0]) pushdown(x),x=ch[x][0];\tsplay(x);\treturn x;}void link(int x,int y){\tmakeroot(x);\tif(findroot(y)!=x) fa[x]=y;}void cut(int x,int y){\tsplit(x,y);\tif(ch[y][0]==x&amp;&amp;!ch[x][1]) fa[x]=ch[y][0]=0;}int query(int x,int y){\tsplit(x,y);\treturn sum[y];}int main(){\tread(n),read(m);\tfor(int i=1;i&lt;=n;++i) read(val[i]);\twhile(m--)\t{\t\tint opt,x,y;\t\tread(opt),read(x),read(y);\t\tif(opt==0) printf(\"%d\\n\",query(x,y));\t\tif(opt==1) link(x,y);\t\tif(opt==2) cut(x,y);\t\tif(opt==3) splay(x),val[x]=y;\t}    return 0;}\n\n树套树三维偏序，线段树套树状数组。\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define lowbit(x) (x&amp;(-x))#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt,tot;int ans[maxn],rt[maxn],sum[maxm],ls[maxm],rs[maxm];struct node{    int a,b,c,val;}p[maxn];bool cmp(const node &amp;x,const node &amp;y){    if(x.a==y.a)    {        if(x.b==y.b) return x.c&lt;y.c;        return x.b&lt;y.b;    }    return x.a&lt;y.a;}void modify(int l,int r,int pos,int v,int &amp;cur){\tif(!cur) cur=++tot;\tsum[cur]+=v;\tif(l==r) return;\tif(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);\telse modify(mid+1,r,pos,v,rs[cur]);}int query(int L,int R,int l,int r,int cur){\tif(!cur) return 0;\tif(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];\tint v=0;\tif(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);\tif(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);\treturn v;}void update(int x,int c,int v){\twhile(x&lt;=m) modify(1,m,c,v,rt[x]),x+=lowbit(x);}int ask(int x,int c){\tint v=0;\twhile(x) v+=query(1,c,1,m,rt[x]),x-=lowbit(x);\treturn v;}void init(){    int pos;    sort(p+1,p+n+1,cmp);    for(int i=1;i&lt;=n;i=pos+1)    {        pos=i;        while(pos&lt;n&amp;&amp;p[i].a==p[pos+1].a&amp;&amp;p[i].b==p[pos+1].b&amp;&amp;p[i].c==p[pos+1].c) pos++;        p[++cnt]=p[i],p[cnt].val=pos-i+1;    }}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(p[i].a),read(p[i].b),read(p[i].c);    init();    for(int i=1;i&lt;=cnt;++i)\t{\t\tans[ask(p[i].b,p[i].c)+p[i].val-1]+=p[i].val;\t\tupdate(p[i].b,p[i].c,p[i].val);\t}    for(int i=0;i&lt;n;++i) printf(\"%d\\n\",ans[i]);    return 0;}\n\n线段树套平衡树。\n#include&lt;bits/stdc++.h&gt;#define maxn 20000010#define inf 2147483647using namespace std;typedef long long ll; template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}template&lt;typename T&gt; inline void write(T x){    short st[30],tp=0;    if(x&lt;0) putchar('-'),x=-x;    do st[++tp]=x%10,x/=10; while(x);    while(tp) putchar('0'|st[tp--]);}int n,m,tot;int a[maxn],val[maxn],key[maxn],siz[maxn],ls[maxn],rs[maxn];struct FHQ_Treap{    int root,x,y,z;    int add(int x)    {        val[++tot]=x;        siz[tot]=1;        key[tot]=rand();        return tot;    }    void pushup(int x)    {        siz[x]=siz[ls[x]]+siz[rs[x]]+1;    }    void merge(int &amp;p,int x,int y)    {        if(!x||!y)        {               p=x+y;            return;        }        if(key[x]&lt;key[y]) p=x,merge(rs[p],rs[p],y);        else p=y,merge(ls[p],x,ls[p]);        pushup(p);    }    void split(int p,int k,int &amp;x,int &amp;y)    {        if(!p)        {            x=y=0;            return;        }        if(val[p]&lt;=k) x=p,split(rs[p],k,rs[p],y);        else y=p,split(ls[p],k,x,ls[p]);        pushup(p);    }    void insert(int v)    {        split(root,v,x,y);        merge(x,x,add(v));        merge(root,x,y);    }    void del(int v)    {        split(root,v,x,y);        split(x,v-1,x,z);        merge(z,ls[z],rs[z]);        merge(x,x,z);        merge(root,x,y);    }    void build(int l,int r)    {        for(int i=l;i&lt;=r;++i) insert(a[i]);    }    int kth(int v)    {        split(root,v-1,x,y);        int ans=siz[x]+1;        merge(root,x,y);        return ans;    }    int get(int p,int k)    {        if(k==siz[ls[p]]+1) return val[p];        if(k&lt;=siz[ls[p]]) return get(ls[p],k);        else return get(rs[p],k-siz[ls[p]]-1);    }    int pre(int v)    {        split(root,v-1,x,y);        int ans;        if(siz[x]) ans=get(x,siz[x]);        else ans=-inf;        merge(root,x,y);        return ans;    }    int nxt(int v)    {        split(root,v,x,y);        int ans;        if(siz[y]) ans=get(y,1);        else ans=inf;        merge(root,x,y);        return ans;    }}treap[maxn];int tree_cnt,root;int lc[maxn],rc[maxn];struct Segment_Tree{    void build(int l,int r,int &amp;cur)    {        cur=++tree_cnt;        treap[cur].build(l,r);        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(l,mid,lc[cur]),build(mid+1,r,rc[cur]);    }    int q_rnk(int L,int R,int l,int r,int k,int cur)    {        if(L&lt;=l&amp;&amp;R&gt;=r)  return treap[cur].kth(k)-1;        int mid=(l+r)&gt;&gt;1,ans=0;        if(L&lt;=mid) ans+=q_rnk(L,R,l,mid,k,lc[cur]);        if(R&gt;mid) ans+=q_rnk(L,R,mid+1,r,k,rc[cur]);        return ans;    }    int q_val(int L,int R,int rnk)    {        int l=0,r=1e8,ans;        while(l&lt;=r)        {            int mid=(l+r)&gt;&gt;1;            if(q_rnk(L,R,1,n,mid,root)+1&lt;=rnk) ans=mid,l=mid+1;            else r=mid-1;        }        return ans;    }    void modify(int l,int r,int pos,int k,int cur)    {        treap[cur].del(a[pos]),treap[cur].insert(k);        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        if(pos&lt;=mid) modify(l,mid,pos,k,lc[cur]);        if(pos&gt;mid) modify(mid+1,r,pos,k,rc[cur]);    }    int lower(int L,int R,int l,int r,int k,int cur)    {        if(L&gt;r||R&lt;l) return -inf;        if(L&lt;=l&amp;&amp;R&gt;=r) return treap[cur].pre(k);        int mid=(l+r)&gt;&gt;1;        return max(lower(L,R,l,mid,k,lc[cur]),lower(L,R,mid+1,r,k,rc[cur]));    }    int upper(int L,int R,int l,int r,int k,int cur)    {        if(L&gt;r||R&lt;l) return inf;        if(L&lt;=l&amp;&amp;R&gt;=r) return treap[cur].nxt(k);        int mid=(l+r)&gt;&gt;1;        return min(upper(L,R,l,mid,k,lc[cur]),upper(L,R,mid+1,r,k,rc[cur]));    }}tree;int main(){\tread(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    tree.build(1,n,root);    for(int i=1;i&lt;=m;++i)    {        int opt,l,r,p,k;        read(opt);        if(opt==1)        {            read(l),read(r),read(k);            write(tree.q_rnk(l,r,1,n,k,root)+1),puts(\"\");        }        if(opt==2)        {            read(l),read(r),read(k);            write(tree.q_val(l,r,k)),puts(\"\");        }        if(opt==3)        {            read(p),read(k);            tree.modify(1,n,p,k,root),a[p]=k;        }        if(opt==4)        {            read(l),read(r),read(k);            write(tree.lower(l,r,1,n,k,root)),puts(\"\");        }        if(opt==5)        {            read(l),read(r),read(k);            write(tree.upper(l,r,1,n,k,root)),puts(\"\");        }    }\treturn 0;}\n\nCDQ 分治三维偏序。\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define lowbit(x) (x&amp;(-x))using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,k,cnt,tot;int num[maxn],tree[maxn];struct node{\tint a,b,c,val,ans;}p[maxn],q[maxn];bool cmp1(node x,node y){    if(x.a==y.a)    {        if(x.b==y.b) return x.c&lt;y.c;        return x.b&lt;y.b;    }    return x.a&lt;y.a;}bool cmp2(node x,node y){    if(x.b==y.b) return x.c&lt;y.c;    return x.b&lt;y.b;}void update(int x,int v){\twhile(x&lt;=k)\t{\t\ttree[x]+=v;\t\tx+=lowbit(x);\t}}int query(int x){\tint sum=0;\twhile(x)\t{\t\tsum+=tree[x];\t\tx-=lowbit(x);\t}\treturn sum;}void cdq(int l,int r){\tif(l==r) return;\tint mid=(l+r)&gt;&gt;1;\tcdq(l,mid),cdq(mid+1,r);\tsort(q+l,q+mid+1,cmp2);\tsort(q+mid+1,q+r+1,cmp2);\tint j=l;\tfor(int i=mid+1;i&lt;=r;++i)\t{\t\twhile(q[j].b&lt;=q[i].b&amp;&amp;j&lt;=mid)\t\t{\t\t\tupdate(q[j].c,q[j].val);\t\t\tj++;\t\t}\t\tq[i].ans+=query(q[i].c);\t}\tfor(int i=l;i&lt;j;++i) update(q[i].c,-q[i].val);}int main(){\tread(n),read(k);\tfor(int i=1;i&lt;=n;++i)\t\tread(p[i].a),read(p[i].b),read(p[i].c);\tsort(p+1,p+n+1,cmp1);\tfor(int i=1;i&lt;=n;++i)\t{\t\tcnt++;\t\tif(p[i].a!=p[i+1].a||p[i].b!=p[i+1].b||p[i].c!=p[i+1].c)\t\t{\t\t\tq[++tot]=p[i];\t\t\tq[tot].val=cnt;\t\t\tcnt=0;\t\t}\t}\tcdq(1,tot);\tfor(int i=1;i&lt;=tot;++i)\t\tnum[q[i].ans+q[i].val-1]+=q[i].val;\tfor(int i=0;i&lt;n;++i) printf(\"%d\\n\",num[i]);\treturn 0;}\n\n分块void modify(int l,int r,ll v){    for(int i=l;i&lt;=min(S*bel[l],r);++i) a[i]+=v,sum[bel[l]]+=v;    if(bel[l]!=bel[r])        for(int i=S*(bel[r]-1)+1;i&lt;=r;++i)            a[i]+=v,sum[bel[r]]+=v;    for(int i=bel[l]+1;i&lt;=bel[r]-1;++i) add[i]+=v;}ll query(int l,int r){    ll ans=0;    for(int i=l;i&lt;=min(S*bel[l],r);++i) ans+=a[i]+add[bel[l]];    if(bel[l]!=bel[r])        for(int i=S*(bel[r]-1)+1;i&lt;=r;++i)            ans+=a[i]+add[bel[r]];    for(int i=bel[l]+1;i&lt;=bel[r]-1;++i) ans+=sum[i]+S*add[i];    return ans;}......for(int i=1;i&lt;=n;++i)\tread(a[i]),bel[i]=(i-1)/S+1,sum[bel[i]]+=a[i];\n\n点分治求出树上两点距离小于等于  的点对数量。\n#include&lt;bits/stdc++.h&gt;#define maxn 80010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,k,root,tot,cnt;ll ans;int siz[maxn],mx[maxn],len[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void dfs_root(int x,int fa){    siz[x]=1,mx[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa||vis[y]) continue;        dfs_root(y,x),siz[x]+=siz[y];        mx[x]=max(mx[x],siz[y]);    }    mx[x]=max(mx[x],tot-siz[x]);    if(mx[x]&lt;mx[root]) root=x;}void dfs_get(int x,int fa,int dis){    len[++cnt]=dis;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa||vis[y]) continue;        dfs_get(y,x,dis+e[i].v);    }}ll calc(int x,int dis){    cnt=0,dfs_get(x,0,dis),sort(len+1,len+cnt+1);    ll v=0,pos=cnt;    for(int i=1;i&lt;=cnt;++i)    {        while(pos&amp;&amp;len[i]+len[pos]&gt;k) pos--;        v+=pos-(i&lt;=pos);    }    return v/2;}void solve(int x){    int now=tot;    vis[x]=true,ans+=calc(x,0);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]) continue;        ans-=calc(y,e[i].v);        root=0,tot=siz[y]&gt;siz[x]?now-siz[x]:siz[y];        dfs_root(y,x),solve(root);    }}int main(){    read(n);    for(int i=1;i&lt;n;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    read(k),tot=mx[0]=n,dfs_root(1,0),solve(root),printf(\"%lld\",ans);    return 0;}\n\n点分树#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,dfn_cnt,tot,root,ans;int v[maxn],de[maxn],fa[maxn],ma[maxn],siz[maxn],si[maxn];int pos[maxn],f[maxn][20],lg[maxn];bool vis[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}struct node{    int tree_cnt;    int ls[maxm],rs[maxm],rt[maxn],sum[maxm];    void modify(int l,int r,int pos,int v,int &amp;cur)    {        if(!cur) cur=++tree_cnt;        sum[cur]+=v;        if(l==r) return;        if(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);        else modify(mid+1,r,pos,v,rs[cur]);    }    int query(int L,int R,int l,int r,int cur)    {        if(L&gt;R||!cur) return 0;        if(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];        int v=0;        if(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);        if(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);        return v;    }}T1,T2;void dfs_pre(int x,int fa){    de[x]=de[fa]+1,f[++dfn_cnt][0]=de[x],pos[x]=dfn_cnt;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_pre(y,x),f[++dfn_cnt][0]=de[x];    }}void st(){    lg[0]=-1;    for(int i=1;i&lt;=dfn_cnt;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int j=1;j&lt;=18;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=dfn_cnt;++i)            f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);}int ask(int x,int y){    int l=pos[x],r=pos[y],len;    if(l&gt;r) swap(l,r);    len=lg[r-l+1];    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);}int dis(int x,int y){    return de[x]+de[y]-2*ask(x,y);}void dfs_root(int x,int fath){    siz[x]=1,ma[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]||y==fath) continue;        dfs_root(y,x),siz[x]+=siz[y],ma[x]=max(ma[x],siz[y]);    }    ma[x]=max(ma[x],tot-siz[x]);    if(ma[x]&lt;ma[root]) root=x;}void solve(int x){    int now=tot;    vis[x]=true,si[x]=now;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]) continue;        root=0,tot=siz[y];        if(siz[y]&gt;siz[x]) tot=now-siz[x];        dfs_root(y,x),fa[root]=x,solve(root);    }}void update(int x,int val){    T1.modify(0,si[x],0,val,T1.rt[x]);    for(int i=x;fa[i];i=fa[i])    {        T1.modify(0,si[fa[i]],dis(x,fa[i]),val,T1.rt[fa[i]]);        T2.modify(0,si[fa[i]],dis(x,fa[i]),val,T2.rt[i]);    }}int query(int x,int k){    int v=T1.query(0,k,0,si[x],T1.rt[x]);    for(int i=x;fa[i];i=fa[i])    {        v+=T1.query(0,k-dis(x,fa[i]),0,si[fa[i]],T1.rt[fa[i]]);        v-=T2.query(0,k-dis(x,fa[i]),0,si[fa[i]],T2.rt[i]);    }    return v;}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(v[i]);    for(int i=1;i&lt;n;++i)    {        int x,y;        read(x),read(y);        add(x,y),add(y,x);    }    dfs_pre(1,0),st(),tot=ma[0]=n,dfs_root(1,0),solve(root);    for(int i=1;i&lt;=n;++i) update(i,v[i]);    while(m--)    {        int opt,x,k;        read(opt),read(x),read(k),x^=ans,k^=ans;        if(!opt) printf(\"%d\\n\",ans=query(x,k));        else update(x,k-v[x]),v[x]=k;    }    return 0;}\n\n笛卡尔树void build(){    for(int i=1;i&lt;=n;++i)    {        while(top&amp;&amp;a[st[top]]&gt;a[i]) ls[i]=st[top--];        if(top) rs[st[top]]=i;        st[++top]=i;    }}\n\n左偏树维护  个小根堆，支持堆的合并，查询最小值。\n#include&lt;bits/stdc++.h&gt;#define maxn 100010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int fa[maxn],ls[maxn],rs[maxn],dis[maxn],val[maxn];int find(int x){    return fa[x]==x?x:fa[x]=find(fa[x]);}int merge(int x,int y){\tif(!x||!y) return x+y;\tif(val[x]&gt;val[y]) swap(x,y);\trs[x]=merge(rs[x],y),fa[rs[x]]=x;\tif(dis[ls[x]]&lt;dis[rs[x]]) swap(ls[x],rs[x]);\tdis[x]=dis[rs[x]]+1;\treturn x;}void del(int x){    val[x]=-1,fa[ls[x]]=ls[x],fa[rs[x]]=rs[x];    fa[x]=merge(ls[x],rs[x]);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(val[i]),fa[i]=i;    while(m--)    {        int opt,x,y;        read(opt);        if(opt==1)        {            read(x),read(y);            if(val[x]==-1||val[y]==-1) continue;            x=find(x),y=find(y);            if(x!=y) merge(x,y);        }        else        {            read(x);            if(val[x]==-1) puts(\"-1\");            else x=find(x),printf(\"%d\\n\",val[x]),del(x);        }    }    return 0;}\n\nK-D Tree查询二维平面上欧氏距离下的第  远点对。\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010#define inf 200000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,k,root,type;struct KD_tree{    ll d[2];    int mi[2],ma[2],ls,rs,id;}t[maxn];bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }}void build(int l,int r,int k,int &amp;cur){    int mid=(l+r)&gt;&gt;1;    cur=mid,type=k;    nth_element(t+l+1,t+mid+1,t+r+1,cmp);    if(l&lt;mid) build(l,mid-1,k^1,t[mid].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[mid].rs);    pushup(cur);}ll calc(ll x){    return x*x;}ll dis(int cur,ll x,ll y){    return calc(t[cur].d[0]-x)+calc(t[cur].d[1]-y);}ll dist(int cur,ll x,ll y){    return max(calc(t[cur].ma[0]-x),calc(t[cur].mi[0]-x))+max(calc(t[cur].ma[1]-y),calc(t[cur].mi[1]-y));}priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q;void query(int cur,ll x,ll y){    ll d,dl,dr;    int ls=t[cur].ls,rs=t[cur].rs;    d=dis(cur,x,y);    if(d&gt;q.top()) q.pop(),q.push(d);    if(ls) dl=dist(ls,x,y);    else dl=-inf;    if(rs) dr=dist(rs,x,y);    else dr=-inf;    if(dl&gt;q.top()) query(ls,x,y);    if(dr&gt;q.top()) query(rs,x,y);}int main(){\tread(n),read(k);    for(int i=1;i&lt;=n;++i)        read(t[i].d[0]),read(t[i].d[1]);    build(1,n,0,root);    for(int i=1;i&lt;=2*k;++i) q.push(0);    for(int i=1;i&lt;=n;++i)        query(root,t[i].d[0],t[i].d[1]);    printf(\"%lld\",q.top());\treturn 0;}\n\n查询二维平面上满足 （每次询问给出 ）的点的权值和。\nstruct KD_tree{    int d[2],mi[2],ma[2],ls,rs,id;    ll val,sum;}t[maxn],dat[maxn];bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }    t[cur].sum=t[ls].sum+t[rs].sum+t[cur].val;}void build(int l,int r,int k,int &amp;cur){    cur=++tot,type=k;    int mid=(l+r)&gt;&gt;1;    nth_element(dat+l,dat+mid,dat+r+1,cmp);    t[cur]=dat[mid];    if(l&lt;mid) build(l,mid-1,k^1,t[cur].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[cur].rs);    pushup(cur);}bool check(ll x,ll y){    return a*x+b*y&lt;c;}ll query(int cur){    ll ans=0;    int ls=t[cur].ls,rs=t[cur].rs,cnt=0;    cnt+=check(t[cur].ma[0],t[cur].ma[1]);    cnt+=check(t[cur].ma[0],t[cur].mi[1]);    cnt+=check(t[cur].mi[0],t[cur].mi[1]);    cnt+=check(t[cur].mi[0],t[cur].ma[1]);    if(cnt==4) return t[cur].sum;    if(!cnt) return 0;    if(check(t[cur].d[0],t[cur].d[1])) ans+=t[cur].val;    if(ls) ans+=query(ls);    if(rs) ans+=query(rs);    return ans;}\n\n支持插入点和查询二维平面上矩形内所有点的权值和，强制在线，用  实现，当不平衡时，像替罪羊树一样重构。\nstruct KD_tree{    int d[2],mi[2],ma[2],ls,rs,val,sum,siz;}t[maxn],dat[maxn],p;bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}int add(){    if(top) return st[top--];    return ++tot;}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }    t[cur].sum=t[ls].sum+t[rs].sum+t[cur].val;    t[cur].siz=t[ls].siz+t[rs].siz+1;}void build(int l,int r,int k,int &amp;cur){    cur=add(),type=k;    int mid=(l+r)&gt;&gt;1;    nth_element(dat+l,dat+mid,dat+r+1,cmp);    t[cur]=dat[mid];    t[cur].ls=t[cur].rs=0;    if(l&lt;mid) build(l,mid-1,k^1,t[cur].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[cur].rs);    pushup(cur);}void del(int cur){    if(!cur) return;    dat[++now]=t[cur];    st[++top]=cur;    del(t[cur].ls),del(t[cur].rs);}void check(int &amp;cur,int k){    int ls=t[cur].ls,rs=t[cur].rs;    if(t[cur].siz*alpha&lt;max(t[ls].siz,t[rs].siz))        now=0,del(cur),build(1,t[cur].siz,k,cur);}void insert(KD_tree p,int k,int &amp;cur){    if(!cur)    {        cur=add();        t[cur]=p;        t[cur].ls=t[cur].rs=0;        pushup(cur);        return;    }    if(p.d[k]&lt;=t[cur].d[k]) insert(p,k^1,t[cur].ls);    else insert(p,k^1,t[cur].rs);    pushup(cur);    check(cur,k);}bool check_p(KD_tree p){    return p.d[0]&lt;=bx&amp;&amp;p.d[0]&gt;=ax&amp;&amp;p.d[1]&lt;=by&amp;&amp;p.d[1]&gt;=ay;}bool check_in(KD_tree p){    return p.mi[0]&gt;=ax&amp;&amp;p.ma[0]&lt;=bx&amp;&amp;p.mi[1]&gt;=ay&amp;&amp;p.ma[1]&lt;=by;}bool check_out(KD_tree p){    return p.mi[0]&gt;bx||p.ma[0]&lt;ax||p.mi[1]&gt;by||p.ma[1]&lt;ay;}int query(int cur){    int ls=t[cur].ls,rs=t[cur].rs,val=t[cur].val,sum=t[cur].sum,ans=0;    if(check_in(t[cur])) return sum;    if(check_out(t[cur])) return 0;    if(check_p(t[cur])) ans+=val;    if(ls) ans+=query(ls);    if(rs) ans+=query(rs);    return ans;}\n\n图论强连通分量#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt,top,tot,ans;int dfn[maxn],low[maxn],col[maxn],st[maxn],d[maxn];int v[maxn],val[maxn],f[maxn];bool vis[maxn];struct Edge{\tint x,y;}ed[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]},head[from]=edge_cnt;}void tarjan(int x){\tdfn[x]=low[x]=++cnt,vis[st[++top]=x]=true;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);\t\telse if(vis[y]) low[x]=min(low[x],dfn[y]);\t}\tif(dfn[x]==low[x])\t{\t\ttot++;\t\tint now;\t\tdo\t\t{\t\t\tvis[now=st[top--]]=false;\t\t\tval[col[now]=tot]+=v[now]; \t\t}while(now!=x);\t}}void clear(){\tfor(int i=1;i&lt;=n;++i) head[i]=0;\tfor(int i=1;i&lt;=edge_cnt;++i) e[i].nxt=e[i].to=0;\tedge_cnt=0;}void dp(){\tqueue&lt;int&gt; q;\tfor(int i=1;i&lt;=tot;++i)\t{\t\tf[i]=val[i];\t\tif(!d[i]) q.push(i);\t}\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\td[y]--,f[y]=max(f[y],f[x]+val[y]);\t\t\tif(!d[y]) q.push(y);\t\t}\t}\tfor(int i=1;i&lt;=tot;++i) ans=max(ans,f[i]);}int main(){    read(n),read(m);\tfor(int i=1;i&lt;=n;++i) read(v[i]);\tfor(int i=1;i&lt;=m;++i)\t{\t\tread(ed[i].x),read(ed[i].y);\t\tadd(ed[i].x,ed[i].y);\t}\tfor(int i=1;i&lt;=n;++i)\t\tif(!dfn[i])\t\t\ttarjan(i);\tclear();\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x=col[ed[i].x],y=col[ed[i].y];\t\tif(x==y) continue;\t\tadd(x,y),d[y]++;\t}\tdp(),printf(\"%d\",ans);\t    return 0;}\n\n2-SATvoid tarjan(int x){    dfn[x]=low[x]=++dfn_cnt;    st[++top]=x;    vis[x]=true;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(!dfn[y])        {            tarjan(y);            low[x]=min(low[x],low[y]);        }        else if(vis[y])            low[x]=min(low[x],dfn[y]);    }    if(low[x]==dfn[x])    {        co_cnt++;        int now;        do        {            now=st[top--];            vis[now]=false;            co[now]=co_cnt;        }while(now!=x);    }}bool check(){    for(int i=1;i&lt;=2*n;++i)        if(!dfn[i])            tarjan(i);    for(int i=1;i&lt;=n;++i)        if(co[i]==co[i+n])            return false;    return true;}......add(x+(a^1)*n,y+b*n),add(y+(b^1)*n,x+a*n);\n\n点双连通分量void tarjan(int x,int root){\tint son=0;\tdfn[x]=low[x]=++dfn_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y])\t\t{\t\t\ttarjan(y,root),low[x]=min(low[x],low[y]);\t\t\tif(x!=root&amp;&amp;dfn[x]&lt;=low[y]) cut[x]=true;\t\t\tif(x==root) son++;\t\t}\t\telse low[x]=min(low[x],dfn[y]);\t}\tif(son&gt;1) cut[x]=true;}......for(int i=1;i&lt;=n;++i)    if(!dfn[i])        tarjan(i,i);\n\n求割点时维护一个栈即可求出每个点双连通分量。当  满足为割点时，就依次弹栈，直到弹出  就停止， 还需留在栈中，因为割点  可能属于多个点双连通分量。\nvoid tarjan(int x){    dfn[x]=low[x]=++dfn_cnt,st[++top]=x;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(!dfn[y])        {            tarjan(y),low[x]=min(low[x],low[y]);            if(dfn[x]&lt;=low[y])            {                col_cnt++;                int now;                do now=st[top--],col[now]=col_cnt; while(now!=y);            }        }        else low[x]=min(low[x],dfn[y]);    }}\n\n边双连通分量void tarjan(int x,int link){\tdfn[x]=low[x]=++dfn_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y])\t\t{\t\t\ttarjan(y,i),low[x]=min(low[x],low[y]);\t\t\tif(dfn[x]&lt;low[y]) bri[i]=bri[i^1]=true;\t\t}\t\telse if(i!=(link^1)) low[x]=min(low[x],dfn[y]);\t}}void dfs_col(int x){\tcol[x]=co_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(col[y]||bri[i]) continue;\t\tdfs_col(y);\t}}......for(int i=1;i&lt;=n;++i)\tif(!dfn[i])\t\ttarjan(i,0);for(int i=1;i&lt;=n;++i)    if(!col[i])\t    col_cnt++,dfs_col(i);\n\n最短路spfa\n#include&lt;bits/stdc++.h&gt;#define maxn 15010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void spfa(){    queue&lt;int&gt; q;    for(int i=1;i&lt;=n;++i) dis[i]=inf;    q.push(s),dis[s]=0,vis[s]=true;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)            {                dis[y]=dis[x]+v;                if(!vis[y]) q.push(y),vis[y]=true;            }        }    }}int main(){    read(n),read(m),read(s),read(t);    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    spfa(),printf(\"%lld\",dis[t]);    return 0;}\n\ndijkstra\n#include&lt;bits/stdc++.h&gt;#define maxn 15010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void dij(){    priority_queue&lt;pair&lt;ll,int&gt; &gt; q;    for(int i=1;i&lt;=n;++i) dis[i]=inf;    q.push({0,s}),dis[s]=0;    while(!q.empty())    {        int x=q.top().second;        q.pop();        if(vis[x]) continue;        vis[x]=true;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)                dis[y]=dis[x]+v,q.push({-dis[y],y});        }    }}int main(){    read(n),read(m),read(s),read(t);    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    dij(),printf(\"%lld\",dis[t]);    return 0;}\n\n负环#include&lt;bits/stdc++.h&gt;#define maxn 10010#define inf 1000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int T,n,m;int cnt[maxn],dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;    if(val&gt;=0) e[++edge_cnt]={from,head[to],val},head[to]=edge_cnt;}bool spfa(){    for(int i=1;i&lt;=n;++i) cnt[i]=vis[i]=0,dis[i]=inf;    queue&lt;int&gt; q;    q.push(1),vis[1]=true,dis[1]=0;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        if(++cnt[x]&gt;n) return true;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)            {                dis[y]=dis[x]+v;                if(!vis[y]) q.push(y),vis[y]=true;            }        }    }    return false;}int main(){    read(T);    while(T--)    {        read(n),read(m);        edge_cnt=0,memset(head,0,sizeof(head));        for(int i=1;i&lt;=m;++i)        {            int x,y,v;            read(x),read(y),read(v);            add(x,y,v);        }        puts(spfa()?\"YES\":\"NO\");    }    return 0;}\n\nLCA重链剖分\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s;struct edge{\tint to;\tint nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=(edge){to,head[from]};\thead[from]=edge_cnt;}int fa[maxn],siz[maxn],de[maxn],son[maxn];void dfs_son(int x,int fath){\tfa[x]=fath;\tsiz[x]=1;\tde[x]=de[fath]+1;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fath) continue;\t\tdfs_son(y,x);\t\tsiz[x]+=siz[y];\t\tif(siz[y]&gt;siz[son[x]]) son[x]=y;\t}}int top[maxn],dfn[maxn];int dfn_cnt;void dfs_chain(int x,int tp){\ttop[x]=tp;\tdfn[x]=++dfn_cnt;\tif(son[x]) dfs_chain(son[x],tp);\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(dfn[y]) continue;\t\tdfs_chain(y,y);\t}}int lca(int x,int y){\twhile(top[x]!=top[y])\t{\t\tif(de[top[x]]&lt;de[top[y]]) swap(x,y);\t\tx=fa[top[x]];\t}\tif(de[x]&gt;de[y]) swap(x,y);\treturn x;}int main(){\tread(n),read(m),read(s);\tfor(int i=1;i&lt;n;++i)\t{\t\tint a,b;\t\tread(a),read(b);\t\tadd(a,b),add(b,a);\t}\tdfs_son(s,0);\tdfs_chain(s,s);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint a,b;\t\tread(a),read(b);\t\tprintf(\"%d\\n\",lca(a,b));\t}\treturn 0;}\n\nST 表\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,rt,cnt;int pos[maxn],dep[maxn],lg[maxn];pair&lt;int,int&gt; f[22][maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void dfs(int x,int fa){\tdep[x]=dep[fa]+1,f[0][pos[x]=++cnt]={dep[x],x};\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fa) continue;\t\tdfs(y,x),f[0][++cnt]={dep[x],x};\t}}void ST(){\tlg[0]=-1;\tfor(int i=1;i&lt;=cnt;++i) lg[i]=lg[i&gt;&gt;1]+1;\tfor(int j=1;j&lt;=19;++j)\t\tfor(int i=1;i+(1&lt;&lt;j)-1&lt;=cnt;++i)\t\t\tf[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);\t}int ask(int l,int r){\tl=pos[l],r=pos[r];\tif(l&gt;r) swap(l,r);\tint len=lg[r-l+1];\treturn min(f[len][l],f[len][r-(1&lt;&lt;len)+1]).second;}int main(){\tread(n),read(m),read(rt);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs(rt,0),ST();\twhile(m--)\t{\t\tint x,y;\t\tread(x),read(y),printf(\"%d\\n\",ask(x,y));\t}    return 0;}\n\n最大流#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;int d[maxn],cur[maxn];struct edge{\tint to,nxt;\tll v;\tedge(int a=0,int b=0,ll c=0)\t{\t\tto=a,nxt=b,v=c;\t}}e[maxn];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=edge(to,head[from],val),head[from]=edge_cnt;\te[++edge_cnt]=edge(from,head[to],0),head[to]=edge_cnt;}bool bfs(){\tfor(int i=1;i&lt;=n;++i) cur[i]=head[i],d[i]=0;\tqueue&lt;int&gt; q;\tq.push(s),d[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\tif(d[y]||!e[i].v) continue;\t\t\td[y]=d[x]+1,q.push(y);\t\t}\t}\treturn d[t];}ll dfs(int x,ll lim){\tif(x==t) return lim;\tll res=lim,flow;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tll v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(flow=dfs(y,min(res,v)))\t\t{\t\t\tres-=flow,e[i].v-=flow,e[i^1].v+=flow;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}ll dinic(){\tll v=0,flow;\twhile(bfs())\t\twhile(flow=dfs(s,inf))\t\t\tv+=flow;\treturn v;}int main(){\tread(n),read(m),read(s),read(t);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y,v;\t\tread(x),read(y),read(v),add(x,y,v);\t}\tprintf(\"%lld\",dinic());    return 0;}\n\n最小费用最大流#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll ans,sum;ll dis[maxn];bool vis[maxn];struct edge{\tint to,nxt;\tll v,c;\tedge(int x=0,int y=0,ll z=0,ll w=0)\t{\t\tto=x,nxt=y,v=z,c=w;\t}}e[maxn];int head[maxn],edge_cnt=1;void add(int from,int to,int val,int cost){\te[++edge_cnt]=edge(to,head[from],val,cost),head[from]=edge_cnt;\te[++edge_cnt]=edge(from,head[to],0,-cost),head[to]=edge_cnt;}bool bfs(){\tfor(int i=1;i&lt;=n;++i) dis[i]=inf,vis[i]=false;\tqueue&lt;int&gt; q;\tq.push(s),dis[s]=0,vis[s]=true;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop(),vis[x]=false;\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\tll c=e[i].c;\t\t\tif(dis[y]&lt;=dis[x]+c||!e[i].v) continue;\t\t\tdis[y]=dis[x]+c;\t\t\tif(!vis[y]) vis[y]=true,q.push(y);\t\t}\t}\treturn dis[t]!=inf;}ll dfs(int x,ll lim){\tif(x==t) return lim;\tvis[x]=true;\tll res=lim,flow;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tll v=e[i].v;\t\tif(dis[y]!=dis[x]+e[i].c||!v||vis[y]) continue;\t\tif(flow=dfs(y,min(res,v)))\t\t{\t\t\tres-=flow,e[i].v-=flow,e[i^1].v+=flow;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}void dinic(){\tll flow;\twhile(bfs())\t\twhile(flow=dfs(s,inf))\t\t\tans+=flow,sum+=flow*dis[t];}int main(){\tread(n),read(m),s=1,t=n;\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y,v,w;\t\tread(x),read(y),read(v),read(w);\t\tadd(x,y,v,w);\t}\tdinic(),printf(\"%lld %lld\",ans,sum);    return 0;}\n\n无源汇有上下界可行流#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 1002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn],low[maxn];bool bfs(){\tfor(int i=s;i&lt;=t;++i) cur[i]=head[i];\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(res&lt;=0) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,ans=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tans+=k; \t\t}\t}\treturn ans;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,high;        read(a),read(b),read(low[i]),read(high);        in[a]-=low[i],in[b]+=low[i];        add(a,b,high-low[i]);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    dinic();    if(check())     {        puts(\"YES\");        for(int i=1;i&lt;=m;i++) printf(\"%d\\n\",e[(i&lt;&lt;1)^1].v+low[i]);    }    else puts(\"NO\");\treturn 0;}\n\n有源汇有上下界最大流#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 1002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t,S,T,ans;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn],low[maxn];bool bfs(){\tmemcpy(cur,head,sizeof(head));\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(res&lt;=0) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,flow=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tflow+=k; \t\t}\t}\treturn flow;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),read(S),read(T),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,up;        read(a),read(b),read(low[i]),read(up);        in[a]-=low[i],in[b]+=low[i];        add(a,b,up-low[i]);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    add(T,S,inf);    dinic();    ans=e[edge_cnt].v;    e[edge_cnt].v=e[edge_cnt^1].v=0;    if(check())     {        s=S,t=T;        printf(\"%d\",ans+dinic());    }    else puts(\"please go home to sleep\");\treturn 0;}\n\n有源汇有上下界最小流#include&lt;bits/stdc++.h&gt;#define maxn 500010#define maxm 5002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t,S,T;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn];bool bfs(){\tfor(int i=0;i&lt;=n+1;++i) cur[i]=head[i];\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,flow=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tflow+=k; \t\t}\t}\treturn flow;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),read(S),read(T),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,up,low;        read(a),read(b),read(low),read(up);        in[a]-=low,in[b]+=low;        add(a,b,up-low);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    dinic();    add(T,S,inf);    dinic();    if(!check())    {        puts(\"please go home to sleep\");        return 0;    }    printf(\"%d\",e[edge_cnt].v);\treturn 0;}\n\n最大费用循环流对于边 ，若费用为正，则将其先流满，记录费用总和 ，通过建立源汇点来实现补流，边正常连。若费用为负，则连边 。然后跑最小费用最大流得出费用 ，最终最大费用循环流求解的答案为 。\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define maxm 5000010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int T,n,m,s,t;ll ans;int in[maxn],de[maxn];ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;    ll c;}e[maxm];int head[maxn],edge_cnt;void add(int from,int to,int val,int cost){    e[++edge_cnt]=(edge){to,head[from],val,cost};\thead[from]=edge_cnt;    e[++edge_cnt]=(edge){from,head[to],0,-cost};\thead[to]=edge_cnt;}void Add(int from,int to,int val,ll cost){    in[from]+=val,in[to]-=val,ans+=cost,add(from,to,val,cost);}struct Edge{    int to,nxt,v;}ed[maxn];int hd[maxn],e_cnt;void link(int from,int to,int val){    ed[++e_cnt]=(Edge){to,hd[from],val};    hd[from]=e_cnt;}void dfs_pre(int x,int fa){\tde[x]=de[fa]+1;\tfor(int i=hd[x];i;i=ed[i].nxt)\t{\t\tint y=ed[i].to;\t\tif(y==fa) continue;        Add(x,y,ed[i].v,0),dfs_pre(y,x);\t}\t}bool spfa(){    for(int i=s;i&lt;=t;++i) vis[i]=0,dis[i]=inf;    queue&lt;int&gt; q;    q.push(s),dis[s]=0,vis[s]=true;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to;            ll v=e[i].v,c=e[i].c;            if(dis[y]&gt;dis[x]+c&amp;&amp;v)            {                dis[y]=dis[x]+c;                if(!vis[y])                {                    vis[y]=true;                    q.push(y);                }            }        }    }    return dis[t]!=inf;}ll dfs(int x,ll lim){    if(x==t) return lim;    vis[x]=true;    ll res=lim,flow;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v,c=e[i].c;        if(dis[y]!=dis[x]+c||!v||vis[y]) continue;        if(flow=dfs(y,min(res,v)))        {            res-=flow;            e[i].v-=flow;            e[i^1].v+=flow;            if(!res) break;        }    }    return lim-res;}ll dinic(){    ll flow,sum=0;    while(spfa())        while(flow=dfs(s,inf))            sum+=flow*dis[t];    return sum;}void clear(){    e_cnt=ans=0,edge_cnt=1;    memset(in,0,sizeof(in));    memset(hd,0,sizeof(hd));    memset(head,0,sizeof(head));}int main(){    read(T);    while(T--)    {        clear(),read(n),read(m),t=n+1;        for(int i=1;i&lt;n;++i)        {            int x,y,v;            read(x),read(y),read(v);            link(x,y,v),link(y,x,v);        }        dfs_pre(1,0);        for(int i=1;i&lt;=m;++i)        {            int x,y,v;            read(x),read(y),read(v);            if(de[x]&lt;de[y]) swap(x,y);            Add(x,y,1,v);        }        for(int i=1;i&lt;=n;++i)        {            if(in[i]&gt;0) add(s,i,in[i],0);            else add(i,t,-in[i],0);        }        printf(\"%lld\\n\",ans-dinic());    }    return 0;}\n\n最小割树通过建最小割树来快速求解无向图中两点间的最小割。最小割树中的一条边的权值，为其两端点的最小割，那么任意两点之间的最小割即为路径上的最小值。通过递归建树即可。\nvoid build(int l,int r){    if(l==r) return;    s=p[l],t=p[l+1];    int v=F.dinic(),cnt1=0,cnt2=0;    add(s,t,v),add(t,s,v);    for(int i=l;i&lt;=r;++i)    {        int x=p[i];        if(F.d[x]) p1[++cnt1]=x;        else p2[++cnt2]=x;    }    for(int i=1;i&lt;=cnt1;++i) p[l+i-1]=p1[i];    for(int i=1;i&lt;=cnt2;++i) p[l+cnt1+i-1]=p2[i];    build(l,l+cnt1-1),build(l+cnt1,r);}\n\n树的直径可以通过两次  或  求出树的直径，从任意结点出发，搜索得出直径的一个端点，然后从这个端点继续搜索，得出另一个端点，但无法处理负边权。也可以用树形求直径，考虑每个结点，求出经过结点的最长链长度，则树的直径长度就是这些最长链长度的最大值，但无法求出直径的端点。\nvoid dp(int x,int fa){    for(int i=head[x];i;i=e[i].nxt)\t{        int y=e[i].to,v=e[i].v;\t\tif(y==fa) continue;        dp(y,x);        maxd=max(maxd,dis[x]+dis[y]+v);        dis[x]=max(dis[x],dis[y]+v);    }}\n\n树上 k 级祖先#include&lt;bits/stdc++.h&gt;#define maxn 500010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,q,root,cnt;ll ans,last;int son[maxn],top[maxn],de[maxn],dep[maxn];int lg[maxn],f[maxn][22],u[maxn],d[maxn],dfn[maxn];unsigned int s;struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}unsigned int get(){    s^=s&lt;&lt;13,s^=s&gt;&gt;17,s^=s&lt;&lt;5;\treturn s; }void dfs_son(int x){    de[x]=dep[x]=de[f[x][0]]+1;    for(int i=1;i&lt;=19;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        dfs_son(y),dep[x]=max(dep[x],dep[y]);        if(dep[y]&gt;dep[son[x]]) son[x]=y;    }}void dfs_dfn(int x,int tp,int anc){    top[x]=tp,dfn[x]=++cnt,u[cnt]=anc,d[cnt]=x;    if(son[x]) dfs_dfn(son[x],tp,f[anc][0]);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==son[x]) continue;        dfs_dfn(y,y,y);    }}int ask(int x,int k){    if(!k) return x;    x=f[x][lg[k]],k-=(1&lt;&lt;lg[k])+de[x]-de[top[x]],x=top[x];    if(k&gt;=0) return u[dfn[x]+k];    else return d[dfn[x]-k];}int main(){    read(n),read(q),read(s),lg[0]=-1;    for(int i=1;i&lt;=n;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int i=1;i&lt;=n;++i)    {        read(f[i][0]);        if(!f[i][0]) root=i;        else add(f[i][0],i);    }    dfs_son(root),dfs_dfn(root,root,root);    for(int i=1;i&lt;=q;++i)    {        int x=(get()^last)%n+1,k=(get()^last)%de[x];        last=ask(x,k),ans^=last*i;    }    printf(\"%lld\",ans);    return 0;}\n\n无向图三元环计数for(int i=1;i&lt;=m;++i){    int x=ed[i].x,y=ed[i].y;    if(deg[x]&gt;deg[y]||(deg[x]==deg[y]&amp;&amp;x&gt;y)) swap(x,y);    add(x,y);}for(int x=1;x&lt;=n;++x){    for(int i=head[x];i;i=e[i].nxt) vis[e[i].to]=x;    for(int i=head[x];i;i=e[i].nxt)        for(int j=head[e[i].to];j;j=e[j].nxt)            if(vis[e[j].to]==x)                ans++;}\n\n欧拉回路 为无向图， 为有向图。\n#include&lt;bits/stdc++.h&gt;#define maxn 400010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t,cnt;int deg[maxn],p[maxn];bool vis[maxn];struct edge{    int to,nxt;    edge(int a=0,int b=0)    {        to=a,nxt=b;    }}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void dfs1(int x){    for(int &amp;i=head[x];i;i=e[i].nxt)    {        if(vis[i]) continue;        int l=i;        vis[i]=vis[i^1]=true,dfs1(e[i].to),p[++cnt]=l&amp;1?-(l&gt;&gt;1):(l&gt;&gt;1);    }}void dfs2(int x){    for(int &amp;i=head[x];i;i=e[i].nxt)    {        if(vis[i]) continue;        int l=i;        vis[i]=true,dfs2(e[i].to),p[++cnt]=l;    }}bool check(){    for(int i=1;i&lt;=n;++i)        if(deg[i])            return false;    return true;}int main(){    read(t),read(n),read(m),edge_cnt=t==1;    for(int i=1;i&lt;=m;++i)    {        int x,y;        read(y),read(x),add(x,y),s=x;        if(t==1) add(y,x),deg[x]^=1,deg[y]^=1;        else deg[x]++,deg[y]--;    }    if(!check())    {        puts(\"NO\");        return 0;    }       if(t==1) dfs1(s);    else dfs2(s);    if(cnt!=m)    {        puts(\"NO\");        return 0;    }    puts(\"YES\");    for(int i=1;i&lt;=m;++i) printf(\"%d \",p[i]);    return 0;}\n\nKruskal 重构树用  构建生成树的顺序来构建  重构树。两个连通块合并时，新建一个节点，点权为联通这两个连通块边的边权，新节点向两个连通块的根连边，新节点为合并后的连通块的根。得到的树为有  个叶子节点的二叉树，其满足堆的性质。求一个点  在只经过边权不大于  的边所能到达的点。边权从小到大排序，建  重构树，得到的是一个大根堆，从  向上倍增，到达满足点权不大于  深度最浅的节点，该节点子树中的所有叶子节点  都可到达。\nfor(int i=1;i&lt;=m;++i){    int x=find(ed[i].x),y=find(ed[i].y);    if(x==y) continue;    val[++tot]=ed[i].v,add(tot,x),add(tot,y);    fa[x]=fa[y]=f[x][0]=f[y][0]=tot;    if(tot==2*n-1) break;}\n\n静态仙人掌询问两点最短路。\n#include&lt;bits/stdc++.h&gt;#define maxn 40010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,q,tot,dfn_cnt;int dfn[maxn],low[maxn],fa[maxn],pre[maxn],sum[maxn],dis[maxn],de[maxn],f[maxn][18];struct node{    struct edge    {        int to,nxt,v;    }e[maxn];    int head[maxn],edge_cnt;    void add(int from,int to,int val)    {        e[++edge_cnt]=(edge){to,head[from],val};        head[from]=edge_cnt;    }}T1,T2;void build(int x,int y,int v){    int s=v;    for(int i=y;i!=fa[x];i=fa[i]) sum[i]=s,s+=pre[i];    sum[++tot]=sum[x],sum[x]=0;    for(int i=y;i!=fa[x];i=fa[i])        T2.add(tot,i,min(sum[i],sum[tot]-sum[i])),T2.add(i,tot,min(sum[i],sum[tot]-sum[i]));}void tarjan(int x,int fath){    dfn[x]=low[x]=++dfn_cnt;    for(int i=T1.head[x];i;i=T1.e[i].nxt)    {        int y=T1.e[i].to,v=T1.e[i].v;        if(y==fath) continue;        if(!dfn[y])        {            fa[y]=x,pre[y]=v,tarjan(y,x);            low[x]=min(low[x],low[y]);        }        else low[x]=min(low[x],dfn[y]);        if(dfn[x]&lt;low[y]) T2.add(x,y,v),T2.add(y,x,v);    }    for(int i=T1.head[x];i;i=T1.e[i].nxt)    {        int y=T1.e[i].to;        if(fa[y]!=x&amp;&amp;dfn[x]&lt;dfn[y])            build(x,y,T1.e[i].v);    }}void dfs(int x,int fath){    f[x][0]=fath,de[x]=de[fath]+1;    for(int i=1;i&lt;=15;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=T2.head[x];i;i=T2.e[i].nxt)    {        int y=T2.e[i].to;        if(y==fath) continue;        dis[y]=dis[x]+T2.e[i].v,dfs(y,x);    }}int lca(int x,int y){    if(de[x]&lt;de[y]) swap(x,y);    for(int i=15;i&gt;=0;--i)        if(de[f[x][i]]&gt;=de[y])            x=f[x][i];    if(x==y) return x;    for(int i=15;i&gt;=0;--i)        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    return f[x][0];}int find(int x,int k){    for(int i=0;i&lt;=15;++i)        if(k&amp;(1&lt;&lt;i))            x=f[x][i];    return x;}int main(){    read(n),read(m),read(q),tot=n;    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        T1.add(x,y,v),T1.add(y,x,v);    }    tarjan(1,0),dfs(1,0);    while(q--)    {        int x,y,anc;        read(x),read(y),anc=lca(x,y);        if(anc&lt;=n) printf(\"%d\\n\",dis[x]+dis[y]-dis[anc]*2);        else        {            int sx=find(x,de[x]-de[anc]-1),sy=find(y,de[y]-de[anc]-1);            if(sum[sx]&lt;sum[sy]) swap(sx,sy);            printf(\"%d\\n\",dis[x]-dis[sx]+dis[y]-dis[sy]+min(sum[sx]-sum[sy],sum[anc]+sum[sy]-sum[sx]));        }    }    return 0;}\n\n虚树给出一棵单位边权的树和若干关键点，求出每两个关键点间的距离之和以及距离最大、最小值。\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010#define inf 200000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,q;ll ans,tot,maxd,mind;ll dma[maxn],dmi[maxn];bool flag;int query[maxn];struct edge{    int to,nxt;    ll v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,ll val=0){    e[++edge_cnt]=(edge){to,head[from],val};    head[from]=edge_cnt;}int dfn_cnt;int dfn[maxn],top_fa[maxn],fa[maxn],son[maxn];ll de[maxn],siz[maxn];void dfs_son(int x,int fath){    siz[x]=1;    fa[x]=fath;    de[x]=de[fath]+1;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fath) continue;        dfs_son(y,x);        siz[x]+=siz[y];        if(siz[son[x]]&lt;siz[y]) son[x]=y;    }}void dfs_chain(int x,int tp){    dfn[x]=++dfn_cnt,top_fa[x]=tp;    if(son[x]) dfs_chain(son[x],tp);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(dfn[y]) continue;        dfs_chain(y,y);    }}int lca(int x,int y){    while(top_fa[x]!=top_fa[y])    {        if(de[top_fa[x]]&lt;de[top_fa[y]]) swap(x,y);        x=fa[top_fa[x]];    }    if(dfn[x]&gt;dfn[y]) swap(x,y);    return x;}ll dis(int x,int y){    return de[x]+de[y]-de[lca(x,y)]*2;}bool cmp(const int &amp;a,const int &amp;b){    return dfn[a]&lt;dfn[b];}int st[maxn],top;void insert(int x){    if(x==1) return;    if(top==1)    {        st[++top]=x;        return;    }    int anc=lca(x,st[top]);    if(anc==st[top])    {        st[++top]=x;        return;    }    while(top&gt;1&amp;&amp;dfn[anc]&lt;=dfn[st[top-1]])         add(st[top-1],st[top],dis(st[top-1],st[top])),top--;    if(anc!=st[top]) add(anc,st[top],dis(anc,st[top])),st[top]=anc;    st[++top]=x;}bool vis[maxn];void dp(int x){    dma[x]=-inf,dmi[x]=inf;    if(vis[x]) dma[x]=dmi[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        dp(y);        maxd=max(maxd,dma[x]+dma[y]+v);        dma[x]=max(dma[x],dma[y]+v);        mind=min(mind,dmi[x]+dmi[y]+v);        dmi[x]=min(dmi[x],dmi[y]+v);    }}void dfs_ans(int x){    if(vis[x]) siz[x]=1;    else siz[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        dfs_ans(y);        siz[x]+=siz[y];        ans+=siz[y]*(tot-siz[y])*v;    }    head[x]=0;}void clear(){    edge_cnt=0;    memset(siz,0,sizeof(siz));    memset(head,0,sizeof(head));}int main(){\tread(n);    for(int i=1;i&lt;n;++i)    {        int a,b;        read(a),read(b);        add(a,b),add(b,a);    }    dfs_son(1,0),dfs_chain(1,1),clear();    read(q);    while(q--)    {        int k;        read(k);        tot=k;        edge_cnt=ans=0;        mind=inf,maxd=-inf;        for(int i=1;i&lt;=k;++i)        {            read(query[i]);            vis[query[i]]=true;        }        sort(query+1,query+k+1,cmp);        st[top=1]=1;        for(int i=1;i&lt;=k;++i) insert(query[i]);        while(top) add(st[top-1],st[top],dis(st[top-1],st[top])),top--;        dp(1),dfs_ans(1);        for(int i=1;i&lt;=k;++i) vis[query[i]]=false;        printf(\"%lld %lld %lld\\n\",ans,mind,maxd);    }\treturn 0;}\n\n最小树形图给定包含  个结点，  条有向边的一个图。试求一棵以结点  为根的最小树形图，并输出最小树形图每条边的权值之和，如果没有以  为根的最小树形图，输出 。\n#include&lt;bits/stdc++.h&gt;#define maxn 20010#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,root;struct edge{    int x,y,v;}e[maxn];int id[maxn],pre[maxn],ine[maxn],vis[maxn];int zhuliu(){    int ans=0,cnt;    while(1)    {        cnt=0;        for(int i=1;i&lt;=n;++i) ine[i]=inf,id[i]=vis[i]=0;        for(int i=1;i&lt;=m;++i)        {            int x=e[i].x,y=e[i].y,v=e[i].v;            if(x!=y&amp;&amp;v&lt;ine[y]) ine[y]=v,pre[y]=x;        }        for(int i=1;i&lt;=n;++i)            if(i!=root&amp;&amp;ine[i]==inf)                return -1;        for(int i=1;i&lt;=n;++i)        {            if(i==root) continue;            ans+=ine[i];            int y=i;            while(vis[y]!=i&amp;&amp;!id[y]&amp;&amp;y!=root)            {                vis[y]=i;                y=pre[y];            }            if(!id[y]&amp;&amp;y!=root)            {                id[y]=++cnt;                for(int x=pre[y];x!=y;x=pre[x]) id[x]=cnt;            }        }        if(!cnt) break;        for(int i=1;i&lt;=n;++i)            if(!id[i])                id[i]=++cnt;        for(int i=1;i&lt;=m;++i)        {            int x=e[i].x,y=e[i].y;            e[i].x=id[x],e[i].y=id[y];            if(id[x]!=id[y]) e[i].v-=ine[y];        }        root=id[root];        n=cnt;    }    return ans;}int main(){\tread(n),read(m),read(root);    for(int i=1;i&lt;=m;++i)        read(e[i].x),read(e[i].y),read(e[i].v);    printf(\"%d\",zhuliu());\treturn 0;}\n\n支配树给定一张有向图，求从  号点出发，每个点能支配的点的个数（包括自己）。\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 600010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m;struct node{\tstruct edge\t{\t\tint to,nxt;\t}e[maxm];\tint head[maxn],edge_cnt;\tvoid add(int from,int to)\t{\t\te[++edge_cnt]=(edge){to,head[from]};\t\thead[from]=edge_cnt;\t}}a,b,c,d;int dfn_cnt;int dfn[maxn],id[maxn],fa[maxn];int sdom[maxn],idom[maxn],fath[maxn],val[maxn],ans[maxn];void dfs_dfn(int x){\tdfn[x]=++dfn_cnt;\tid[dfn_cnt]=x;\tfor(int i=a.head[x];i;i=a.e[i].nxt)\t{\t\tint y=a.e[i].to;\t\tif(dfn[y]) continue;\t\tfa[y]=x;\t\tdfs_dfn(y);\t}}int find(int x){\tif(x==fath[x]) return x;\tint tmp=find(fath[x]);\tif(dfn[sdom[val[fath[x]]]]&lt;dfn[sdom[val[x]]])\t\tval[x]=val[fath[x]];\treturn fath[x]=tmp;}void tarjan(){\tfor(int i=1;i&lt;=n;++i) sdom[i]=fath[i]=val[i]=i;\tfor(int i=dfn_cnt;i&gt;1;--i)\t{\t\tint x=id[i];\t\tfor(int i=b.head[x];i;i=b.e[i].nxt)\t\t{\t\t\tint y=b.e[i].to;\t\t\tif(!dfn[y]) continue;\t\t\tfind(y);\t\t\tif(dfn[sdom[val[y]]]&lt;dfn[sdom[x]])\t\t\t\tsdom[x]=sdom[val[y]];\t\t}\t\tc.add(sdom[x],x);\t\tfath[x]=fa[x];\t\tx=fa[x];\t\tfor(int i=c.head[x];i;i=c.e[i].nxt)\t\t{\t\t\tint y=c.e[i].to;\t\t\tfind(y);\t\t\tif(sdom[val[y]]==x) idom[y]=x;\t\t\telse idom[y]=val[y];\t\t}\t\tc.head[x]=0;\t}\tfor(int i=2;i&lt;=dfn_cnt;++i)\t{\t\tint x=id[i];\t\tif(idom[x]!=sdom[x])\t\t\tidom[x]=idom[idom[x]];\t}\tfor(int i=2;i&lt;=n;++i) d.add(idom[i],i);}void dfs_ans(int x){\tans[x]=1;\tfor(int i=d.head[x];i;i=d.e[i].nxt)\t{\t\tint y=d.e[i].to;\t\tdfs_ans(y);\t\tans[x]+=ans[y];\t}}int main(){\tread(n),read(m);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\ta.add(x,y),b.add(y,x);\t}\tdfs_dfn(1);\ttarjan();\tdfs_ans(1);\tfor(int  i=1;i&lt;=n;++i) printf(\"%d \",ans[i]);\treturn 0;}\n\n动态规划单调队列优化 DP优化形如  的  方程。\n\nwhile(h&lt;=t&amp;&amp;f[x][y]&gt;q[t].val+dis(x,y,q[t].x,q[t].y)) t--;q[++t]=(que){f[x][y],x,y};while(h&lt;=t&amp;&amp;(abs(x-q[h].x)&gt;len||abs(y-q[h].y)&gt;len)) h++;f[x][y]=max(f[x][y],q[h].val+dis(x,y,q[h].x,q[h].y));ans=max(ans,f[x][y]);\n\n数位 DP不含前导零且相邻两个数字之差至少为  的正整数被称为 windy 数。windy 想知道，在  和  之间，包括  和  ，总共有多少个 windy 数？\n#include&lt;bits/stdc++.h&gt;#define maxn 15using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll a,b,cnt;ll num[maxn],f[maxn][maxn][2][2][2];ll dp(int pos,int las,bool lim,bool lead,bool flag){    if(!pos) return flag;    if(f[pos][las][lim][lead][flag]!=-1) return f[pos][las][lim][lead][flag];    ll v=0,ma=9;    if(lim) ma=num[pos];    for(int i=0;i&lt;=ma;++i)    {        if(!i&amp;&amp;lead) v+=dp(pos-1,12,0,1,1);        else v+=dp(pos-1,i,lim&amp;&amp;i==ma,0,flag&amp;&amp;(abs(las-i)&gt;=2));    }    return f[pos][las][lim][lead][flag]=v;}ll solve(ll x){    cnt=0,memset(f,-1,sizeof(f));    while(x) num[++cnt]=x%10,x/=10;    return dp(cnt,12,1,1,1);}int main(){    read(a),read(b),printf(\"%lld\",solve(b)-solve(a-1));    return 0;}\n\n斜率优化最小值\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,h,t;ll f[maxn],p[maxn],s[maxn],c[maxn],dis[maxn],q[maxn];double x(int i){    return p[i];}double y(int i){    return f[i]+s[i];}double slope(int j,int k){    return (y(j)-y(k))/(x(j)-x(k));}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        read(dis[i]),read(p[i]),read(c[i]);        s[i]=s[i-1]+dis[i]*p[i],p[i]+=p[i-1];    }    for(int i=1;i&lt;=n;++i)    {        while(h&lt;t&amp;&amp;slope(q[h],q[h+1])&lt;dis[i]) h++;        f[i]=f[q[h]]+dis[i]*(p[i]-p[q[h]])-(s[i]-s[q[h]])+c[i];        while(h&lt;t&amp;&amp;slope(q[t],q[t-1])&gt;slope(q[t],i)) t--;        q[++t]=i;    }    printf(\"%lld\",f[n]);\treturn 0;}\n\n最大值\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,h,t,a,b,c;ll f[maxn],s[maxn],q[maxn];ll calc(ll x){    return x*x;}double x(int i){    return s[i];}double y(int i){    return f[i]+a*calc(s[i])-b*s[i];}double slope(int j,int k){    return (y(j)-y(k))/(x(j)-x(k));}int main(){    read(n),read(a),read(b),read(c);    for(int i=1;i&lt;=n;++i) read(s[i]),s[i]+=s[i-1];    for(int i=1;i&lt;=n;++i)    {        while(h&lt;t&amp;&amp;slope(q[h],q[h+1])&gt;2*a*s[i]) h++;        f[i]=f[q[h]]+a*calc(s[i]-s[q[h]])+b*(s[i]-s[q[h]])+c;        while(h&lt;t&amp;&amp;slope(q[t],q[t-1])&lt;slope(q[t],i)) t--;        q[++t]=i;    }    printf(\"%lld\",f[n]);\treturn 0;}\n\n决策单调性\n二分栈：\ndouble calc(int i,int j){    return a[j]-a[i]+sqrt(i-j);}int find(node t,int x){\tint l=t.l,r=t.r,ans=t.r+1;\twhile(l&lt;=r)\t{\t\tint mid=(l+r)&gt;&gt;1;\t\tif(calc(mid,x)&gt;=calc(mid,t.pos)) r=mid-1,ans=mid;\t\telse l=mid+1;\t}\treturn ans;}void dp(double *f){\tq[h=t=1]=node(1,n,0);\tfor(int i=1;i&lt;=n;++i)\t{\t\twhile(h&lt;=t&amp;&amp;q[h].r&lt;i) h++;\t\tf[i]=calc(i,q[h].pos);\t\tif(calc(n,i)&gt;=calc(n,q[t].pos))\t\t{\t\t\twhile(h&lt;=t&amp;&amp;calc(q[t].l,i)&gt;=calc(q[t].l,q[t].pos)) t--;\t\t\tif(h&gt;t) q[++t]=node(i,n,i);\t\t\telse\t\t\t{\t\t\t\tint x=find(q[t],i);\t\t\t\tq[t].r=x-1,q[++t]=node(x,n,i);\t\t\t}\t\t}\t}}\n\n分治：\n对于区间 ，已知其最优决策范围为 。取  后扫一遍区间  来得出  的  值和最优决策点 ，那么左区间的最优决策范围为 ，右区间的最优决策范围为 。应用分治时要求保证区间  的信息都已存在，因此应用分治大部分时候都是分层的两维 。\ndouble calc(int i,int j){    return a[j]-a[i]+sqrt(i-j);}void solve(int l,int r,int L,int R,double *f){    if(l&gt;r) return;    int pos,mid=(l+r)&gt;&gt;1;    for(int i=L;i&lt;=min(mid,R);++i)    {        double v=calc(mid,i);        if(v&gt;f[mid]) f[mid]=v,pos=i;    }    solve(l,mid-1,L,pos,f),solve(mid+1,r,pos,R,f);}\n\n可以处理无法快速  计算  的 。，其中  为区间  相同元素的对数。\nvoid add(int c){    sum+=cnt[c],cnt[c]++;}void del(int c){    sum-=cnt[c]-1,cnt[c]--;}ll get(int ql,int qr){    while(l&lt;ql) del(a[l++]);    while(r&gt;qr) del(a[r--]);    while(l&gt;ql) add(a[--l]);    while(r&lt;qr) add(a[++r]);    return sum;}void solve(int id,int l,int r,int L,int R){    if(l&gt;r) return;    int pos,mid=(l+r)&gt;&gt;1;    for(int i=L;i&lt;=min(mid,R);++i)    {        ll v=f[i][id-1]+get(i+1,mid);        if(v&lt;f[mid][id]) f[mid][id]=v,pos=i;    }    solve(id,l,mid-1,L,pos),solve(id,mid+1,r,pos,R);}\n\n指针的移动均摊是  的。\n长链剖分给定一棵以  为根， 个节点的树。设  为  子树中到  距离为  的节点数。  对于每个点，求一个最小的 ，使得  最大。\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n;int len[maxn],son[maxn],ans[maxn];vector&lt;int&gt; f[maxn];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void dfs_son(int x,int fa){    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_son(y,x);\t\tif(len[y]&gt;=len[son[x]]) son[x]=y,len[x]=len[y]+1;    }}void dfs(int x,int fa){\tif(!son[x])\t{\t\tf[x].push_back(1);\t\treturn;\t}\tdfs(son[x],x),swap(f[x],f[son[x]]),f[x].push_back(1),ans[x]=ans[son[x]]+1;\tif(f[x][len[x]-ans[x]]==1) ans[x]=0;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fa||y==son[x]) continue;\t\tdfs(y,x);\t\tfor(int j=0;j&lt;=len[y];++j)\t\t{\t\t\tf[x][len[x]-j-1]+=f[y][len[y]-j];\t\t\tif(f[x][len[x]-j-1]&gt;f[x][len[x]-ans[x]]||(f[x][len[x]-j-1]==f[x][len[x]-ans[x]]&amp;&amp;j+1&lt;ans[x]))\t\t\t\tans[x]=j+1;\t\t}\t}}int main(){\tread(n);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs_son(1,0),dfs(1,0);\tfor(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]);\treturn 0;}\n\n凸优化理解可以是二分斜率切凸包，也可以是上下平移凸函数的导函数，来左右平移导函数的零点，使原凸函数的取到极值的位置发生变化。可以优化一种有限制个数的 ，即恰好选  个，通过二分来去掉一维来实现优化。通过题面性质来证明凸函数，费用流模型都为凸函数。\n#include&lt;bits/stdc++.h&gt;#define maxn 600010#define inf 1000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,k;ll l,r,ans;struct edge{    int to,nxt;    ll v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]=(edge){to,head[from],val};    head[from]=edge_cnt;}struct node{    ll val,cnt;}f[maxn][3],g[3];bool operator &lt;(const node &amp;a,const node &amp;b){    if(a.val==b.val) return a.cnt&lt;b.cnt;    return a.val&lt;b.val;}node operator +(const node &amp;a,const node &amp;b){    return (node){a.val+b.val,a.cnt+b.cnt};}void dfs(int x,int fa,ll delta){    f[x][0]=(node){0,0},f[x][1]=(node){-inf,-inf},f[x][2]=(node){delta,1};    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        if(y==fa) continue;        dfs(y,x,delta),g[0]=g[1]=g[2]=(node){-inf,-inf};        for(int j=0;j&lt;3;++j)            for(int k=0;k&lt;3;++k)                g[j]=max(g[j],f[x][j]+f[y][k]);        g[1]=max(g[1],max(f[x][0]+f[y][0]+(node){v+delta,1},f[x][0]+f[y][1]+(node){v,0}));        g[2]=max(g[2],max(f[x][1]+f[y][1]+(node){v-delta,-1},f[x][1]+f[y][0]+(node){v,0}));        f[x][0]=g[0],f[x][1]=g[1],f[x][2]=g[2];    }}bool check(ll x){    dfs(1,0,x);    return max(f[1][0],max(f[1][1],f[1][2])).cnt&gt;=k;}int main(){    read(n),read(k),k++;    for(int i=1;i&lt;n;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v),r+=abs(v);    }    l=-r;    while(l&lt;=r)    {        ll mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,r=mid-1;        else l=mid+1;    }    check(ans),printf(\"%lld\",max(f[1][0],max(f[1][1],f[1][2])).val-ans*k);    return 0;}\n\n通过限制二分来处理选至多选  个的问题。\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,k,pos,l=-inf,r=0;ll ans,sum,cnt;struct node{    ll v,p;}a[maxn],b[maxn];bool cmp(const node &amp;a,const node &amp;b){    if(a.p==b.p) return a.v&lt;b.v;    return a.p&lt;b.p;}bool check(int x){    priority_queue&lt;int&gt; q;    sum=cnt=0,pos=1;    for(int i=1;i&lt;=n;++i)    {        while(pos&lt;=m&amp;&amp;a[i].p&gt;=b[pos].p) q.push(b[pos++].v);        if(q.empty()) continue;        if(q.top()-a[i].v+x&gt;=0)            sum+=q.top()-a[i].v+x,cnt++,q.pop();    }    return cnt&lt;=k;}int main(){    read(n),read(m),read(k);    for(int i=1;i&lt;=n;++i) read(a[i].v),read(a[i].p);    for(int i=1;i&lt;=m;++i) read(b[i].v),read(b[i].p);    sort(a+1,a+n+1,cmp),sort(b+1,b+m+1,cmp);    while(l&lt;=r)    {        int mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,l=mid+1;        else r=mid-1;    }    check(ans),printf(\"%lld\\n\",sum-ans*cnt);    return 0;}\n\n整体 DPMissing or unrecognized delimiter for \\leftf(u, j)=\\max\\left{f(u, j-1), w_u[d_u=j]+\\sum_{v\\in son_u} f(v, j)\\right}\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 15000010#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,k,tot;int d[maxn],w[maxn],rt[maxn],ls[maxm],rs[maxm];ll mx[maxm],tag[maxm];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void pushtag(int cur,ll v){\tif(cur) mx[cur]+=v,tag[cur]+=v;}void pushdown(int cur){\tif(tag[cur]) pushtag(ls[cur],tag[cur]),pushtag(rs[cur],tag[cur]),tag[cur]=0;}void modify(int l,int r,int p,ll v,int &amp;cur){\tif(!cur) cur=++tot;\tif(l==r)\t{\t\tmx[cur]=v;\t\treturn;\t}\tpushdown(cur);\tif(p&lt;=mid) modify(l,mid,p,v,ls[cur]);\telse modify(mid+1,r,p,v,rs[cur]);\tmx[cur]=max(mx[ls[cur]],mx[rs[cur]]);}ll query(int L,int R,int l,int r,int cur){\tif(!cur) return 0;\tif(L&lt;=l&amp;&amp;R&gt;=r) return mx[cur];\tll v=0;\tpushdown(cur);\tif(L&lt;=mid) v=max(v,query(L,R,l,mid,ls[cur]));\tif(R&gt;mid) v=max(v,query(L,R,mid+1,r,rs[cur]));\treturn v;}int get(int x,int y,int l,int r,ll v1,ll v2){\tif(!x&amp;&amp;!y) return 0;\tif(x&amp;&amp;!y)\t{\t\tpushtag(x,v2);\t\treturn x;\t}\tif(!x&amp;&amp;y)\t{\t\tpushtag(y,v1);\t\treturn y;\t}\tif(l==r)\t{\t\tmx[x]=max(mx[x],v1)+max(mx[y],v2);\t\treturn x;\t}\tpushdown(x),pushdown(y);\trs[x]=get(rs[x],rs[y],mid+1,r,max(v1,mx[ls[x]]),max(v2,mx[ls[y]]));\tls[x]=get(ls[x],ls[y],l,mid,v1,v2);\tmx[x]=max(mx[ls[x]],mx[rs[x]]);\treturn x;}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tdfs(y),rt[x]=get(rt[x],rt[y],1,k,0,0);\t}\tif(d[x]) modify(1,k,d[x],w[x]+query(1,d[x],1,k,rt[x]),rt[x]);}int main(){\tread(n),read(m),read(k);\tfor(int i=2,p;i&lt;=n;++i) read(p),add(p,i);\tfor(int i=1,x;i&lt;=m;++i) read(x),read(d[x]),read(w[x]);\tdfs(1),printf(\"%lld\\n\",mx[rt[1]]);    return 0;}\n\n动态 DP给定一棵  个点的树，点带点权。有  次操作，每次操作给定 ，表示修改点  的权值为 。你需要在每次操作之后求出这棵树的最大权独立集的权值大小。\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m;int f[maxn][2],a[maxn],ch[maxn][2],fa[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}struct matrix{    int a[2][2];    matrix()    {        a[0][0]=a[0][1]=a[1][0]=a[1][1]=-inf;    }    int get()    {        return max(a[0][0],a[1][0]);    }}val[maxn],mul[maxn];matrix operator *(const matrix &amp;x,const matrix &amp;y){    matrix z;    for(int k=0;k&lt;=1;++k)        for(int i=0;i&lt;=1;++i)            for(int j=0;j&lt;=1;++j)                z.a[i][j]=max(z.a[i][j],x.a[i][k]+y.a[k][j]);    return z;}void pushup(int x) {    mul[x]=val[x];    if(ch[x][0]) mul[x]=mul[ch[x][0]]*mul[x];    if(ch[x][1]) mul[x]=mul[x]*mul[ch[x][1]];}bool check(int x){    return ch[fa[x]][1]==x;}bool notroot(int x){    return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void rotate(int x){    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];    if(notroot(y)) ch[z][check(y)]=x;    ch[x][k^1]=y,ch[y][k]=w;    if(w) fa[w]=y;    fa[x]=z,fa[y]=x;    pushup(y),pushup(x);}void splay(int x){    for(int y;notroot(x);rotate(x))        if(notroot(y=fa[x]))            rotate(check(x)^check(y)?x:y);}void access(int x){    for(int y=0;x;y=x,x=fa[x])    {            splay(x);        if(ch[x][1]) val[x].a[0][0]+=mul[ch[x][1]].get(),val[x].a[1][0]+=mul[ch[x][1]].a[0][0];        if(y) val[x].a[0][0]-=mul[y].get(),val[x].a[1][0]-=mul[y].a[0][0];        val[x].a[0][1]=val[x].a[0][0],ch[x][1]=y,pushup(x);    }}void modify(int x,int v){    access(x),splay(x);    val[x].a[1][0]-=a[x]-v;    pushup(x),a[x]=v;}void dfs(int x,int fath){    fa[x]=fath,f[x][1]=a[x];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fath) continue;        dfs(y,x),f[x][0]+=max(f[y][0],f[y][1]),f[x][1]+=f[y][0];    }    val[x].a[0][0]=val[x].a[0][1]=f[x][0],val[x].a[1][0]=f[x][1],mul[x]=val[x];}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    for(int i=1;i&lt;n;++i)    {        int x,y;        read(x),read(y);        add(x,y),add(y,x);    }    dfs(1,0);    while(m--)    {        int x,y;        read(x),read(y),modify(x,y),splay(1);        printf(\"%d\\n\",mul[1].get());    }\treturn 0;}\n\n字符串KMPfor(int i=2;i&lt;=m;++i){    while(pos&amp;&amp;t[i]!=t[pos+1]) pos=nxt[pos];    if(t[i]==t[pos+1]) pos++;    nxt[i]=pos;}pos=0;for(int i=1;i&lt;=n;++i){    while(pos&amp;&amp;s[i]!=t[pos+1]) pos=nxt[pos];    if(s[i]==t[pos+1]) pos++;    if(pos==m) printf(\"%d\\n\",i-m+1);}\n\nManacher设  为以  为中心的长度为奇数的回文串个数，也就是最长回文串的回文半径。\nvoid manacher(){\ts[0]='/',s[1]='#';\tfor(int i=1;i&lt;=n;++i) s[i&lt;&lt;1]=t[i],s[i&lt;&lt;1|1]='#';\tn=n&lt;&lt;1|1,s[n+1]='!';\tfor(int i=1,mr=1,mid=0;i&lt;=n;++i)\t{\t\tf[i]=i&lt;mr?min(f[mid*2-i],mr-i):1;\t\twhile(s[i+f[i]]==s[i-f[i]]) f[i]++;\t\tif(i+f[i]&gt;mr) mr=i+f[i],mid=i;\t}}\n\nAC 自动机给你一个文本串  和  个模式串 ，请你分别求出每个模式串  在  中出现的次数。\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot,root;int ch[maxn][28],fail[maxn],siz[maxn],bel[maxn];char s[maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}int insert(char *s){\tint len=strlen(s+1),p=root;\tfor(int i=1;i&lt;=len;++i)\t{\t\tint c=s[i]-'a';\t\tif(!ch[p][c]) ch[p][c]=++tot;\t\tp=ch[p][c];\t}\treturn p;}void build(){\tqueue&lt;int&gt; q;\tfor(int i=0;i&lt;26;++i)\t\tif(ch[root][i])\t\t\tq.push(ch[root][i]);\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=0;i&lt;26;++i)\t\t{\t\t\tint y=ch[x][i];\t\t\tif(y) fail[y]=ch[fail[x]][i],q.push(y);\t\t\telse ch[x][i]=ch[fail[x]][i];\t\t}\t}\tfor(int i=1;i&lt;=tot;++i) add(fail[i],i);}void update(){\tscanf(\"%s\",s+1);\tint len=strlen(s+1);\tfor(int i=1,p=root;i&lt;=len;++i) p=ch[p][s[i]-'a'],siz[p]++;}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt) dfs(e[i].to),siz[x]+=siz[e[i].to];}int main(){\tread(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%s\",s+1),bel[i]=insert(s);\tbuild(),update(),dfs(root);\tfor(int i=1;i&lt;=n;++i) printf(\"%d\\n\",siz[bel[i]]);    return 0;}\n\n后缀排序将字符串每个后缀按照字典序排序。 表示排名为  的后缀的起始位置。 表示起始位置为  的后缀的排名。。两个后缀的  为区间  数组的最小值。\nvoid rsort(){    for(int i=0;i&lt;=m;++i) b[i]=0;    for(int i=1;i&lt;=n;++i) b[rk[i]]++;    for(int i=1;i&lt;=m;++i) b[i]+=b[i-1];    for(int i=n;i;--i) sa[b[rk[tp[i]]]--]=tp[i];}void SA(){    for(int i=1;i&lt;=n;++i) rk[i]=s[i],tp[i]=i;    rsort();    for(int k=1;k&lt;=n;k&lt;&lt;=1)    {        int num=0;        for(int i=n-k+1;i&lt;=n;++i) tp[++num]=i;        for(int i=1;i&lt;=n;++i)             if(sa[i]&gt;k)                tp[++num]=sa[i]-k;        rsort();        memcpy(tp,rk,sizeof(rk));        rk[sa[1]]=num=1;        for(int i=2;i&lt;=n;++i)            rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k])?num:++num;        if(num==n) break;        m=num;    }}void height(){    int k=0;    for(int i=1;i&lt;=n;++i) rk[sa[i]]=i;    for(int i=1;i&lt;=n;++i)    {        if(rk[i]==1) continue;        if(k) k--;        int j=sa[rk[i]-1];        while(s[i+k]==s[j+k]) k++;        ht[rk[i]]=k;    }}void ST(){    lg[0]=-1;    for(int i=1;i&lt;=n;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int i=1;i&lt;=n;++i) f[i][0]=ht[i];    for(int j=1;j&lt;=20;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)            f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);}int lcp(int l,int r){    l=rk[l],r=rk[r];    if(l&gt;r) swap(l,r);    l++;    int len=lg[r-l+1];    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);}\n\n后缀自动机后缀自动机可以理解为是将字符串所有后缀所建出的  进行压缩后得出的 。对于一个子串 ，它结束位置的集合称为 ，如 ，。 为原串的两个子串，设 ，则  是  的后缀当且仅当 ， 不是  的后缀当且仅当 。由  的包含关系可以得出一个树形结构，称为  树。\n后缀自动机的节点就是  树的节点，每个节点表示一个 。 的节点数不超过 ，边数不超过 ，数组大小应开成两倍。为一个  所对应的子串中最长子串的长度。为转移函数。为后缀连接。设  为一个  所对应的子串中最短子串的长度，得 。后缀自动机是一张有向无环图，其中顶点是状态，而边代表了状态之间的转移。每一个状态包含了它包含的最长子串的一些连续长度的后缀，不是所有后缀，再短的其他后缀在  连接的状态，也就是该串的所有后缀在  树的链上。一个字符串的  树，是其反串的后缀树。从初始状态经由任意路径走到某一终止状态，得到的字符串为原串的某一后缀。从初始状态经由任意路径走到某一状态，得到的字符串为原串的某一子串。所有终止状态包含了原串的所有后缀，整串状态是终止状态，整串状态在  树上的祖先也都是终止状态。一个状态的  集合大小等于该状态转移到终止状态的方案数。\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot=1,las=1;ll ans;int len[maxn],fa[maxn],ch[maxn][28],siz[maxn];char s[maxn];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void insert(int c){\tint p=las,np=las=++tot;\tlen[np]=len[p]+1,siz[np]=1;\twhile(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p];\tif(!p) fa[np]=1;\telse\t{\t\tint q=ch[p][c];\t\tif(len[q]==len[p]+1) fa[np]=q;\t\telse\t\t{\t\t\tint nq=++tot;\t\t\tmemcpy(ch[nq],ch[q],sizeof(ch[q]));\t\t\tlen[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;\t\t\twhile(ch[p][c]==q) ch[p][c]=nq,p=fa[p];\t\t}\t}}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tdfs(y),siz[x]+=siz[y];\t}\tif(siz[x]&gt;1) ans=max(ans,(ll)len[x]*siz[x]);}int main(){\tscanf(\"%s\",s+1),n=strlen(s+1);\tfor(int i=1;i&lt;=n;++i) insert(s[i]-'a');\tfor(int i=2;i&lt;=tot;++i) add(fa[i],i);\tdfs(1),printf(\"%lld\",ans);\t    return 0;}\n\n广义后缀自动机#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,las,tot=1,root=1;ll ans;int fa[maxn],len[maxn],ch[maxn][26];char s[maxn];int insert(int c){    if(ch[las][c]&amp;&amp;len[las]+1==len[ch[las][c]]) return ch[las][c];    int p=las,np=++tot;    len[np]=len[p]+1;    while(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p];    if(!p) fa[np]=root;    else    {        int q=ch[p][c];        if(len[q]==len[p]+1) fa[np]=q;        else        {            int nq=++tot;            bool flag=las==p;            memcpy(ch[nq],ch[q],sizeof(ch[q]));            len[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;            while(ch[p][c]==q) ch[p][c]=nq,p=fa[p];            return flag?nq:np;        }    }    return np;}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        int lenth;        scanf(\"%s\",s+1),lenth=strlen(s+1),las=1;        for(int j=1;j&lt;=lenth;++j) las=insert(s[j]-'a');    }    for(int i=2;i&lt;=tot;++i) ans+=len[i]-len[fa[i]];    printf(\"%lld\",ans);    return 0;}\n\n回文自动机回文树可以用来处理一个字符串中所有的回文子串。一个串的本质不同回文子串个数最多为  个。一个字符串的回文树由两棵树组成，一个维护所有长度为奇数的回文子串，一个维护所有长度为偶数的回文子串。树上除根节点外的每个节点都表示串中的一个回文子串。\n 节点对应的回文子串长度。\n 指向该节点所对应的回文子串的最长回文后缀所对应的节点。\n 转移到该树的另一个节点，转移为向当前回文子串两端加上一个字符。\n 以一个位置结尾对应节点的回文子串个数\n为方便处理，偶树的根的  设为 ， 设为奇树的根，奇树的根的  设为 ， 设为其本身。构造时用增量法即可。\nvoid init(){    len[1]=-1,fail[0]=fail[1]=tot=1;}void insert(int i){    int p=las,c=s[i]-'a';    while(s[i-1-len[p]]!=s[i]) p=fail[p];    if(ch[p][c])    {        las=ch[p][c];        return;    }    int x=fail[p],y=++tot;    while(s[i-1-len[x]]!=s[i]) x=fail[x];    fail[y]=ch[x][c],len[y]=len[p]+2,ch[p][c]=las=y,cnt[y]=cnt[fail[y]]+1;}\n\n建  树：\nfor(int i=0;i&lt;=tot;++i)    if(i!=1)    \tadd(fail[i],i);\n\n一个字符串的本质不同回文子串个数即为其回文树除了两个根的节点个数。字符串中一个位置的回文后缀个数即为该位置对应的节点的  链长度。在维护每个本质不同回文子串的出现次数时，还需在  树上用儿子来更新父亲。\nfor(int i=tot;i;--i) cnt[fail[i]]+=cnt[i];\n\n有时还需用到 ，指向长度小于等于其回文子串长度一半的最长回文后缀的节点，建树时维护即可。\nvoid insert(int i){    int p=las,c=s[i]-'a';    while(s[i-1-len[p]]!=s[i]) p=fail[p];    if(ch[p][c])    {        las=ch[p][c];        return;    }    int x=fail[p],y=++tot;    while(s[i-1-len[x]]!=s[i]) x=fail[x];    fail[y]=ch[x][c],len[y]=len[p]+2,ch[p][c]=las=y;    if(len[y]&lt;=2) trans[y]=fail[y];    else    {        int q=trans[p];        while(s[i-1-len[q]]!=s[i]||(len[q]+2)*2&gt;len[y]) q=fail[q];        trans[y]=ch[q][c];    }}\n\n扩展 KMP扩展  可以  得出一个字符串的  函数， 为以  开头的后缀和整个串的 。\nz[1]=n;for(int i=2;i&lt;=n;++i){    if(i&lt;=r) z[i]=min(z[i-l+1],r-i+1);    while(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+1]) z[i]++;    if(i+z[i]-1&gt;r) l=i,r=i+z[i]-1;}\n\n计算几何二维凸包求凸包周长。\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,top;double ans;int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }}p[maxn],st[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}double operator &amp; (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double dis(const Vec &amp;a,const Vec &amp;b){    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}bool cmp(const Vec &amp;a,const Vec &amp;b){    double A=atan2(a.y-p[1].y,a.x-p[1].x),B=atan2(b.y-p[1].y,b.x-p[1].x);    return sgn(A-B)?A&lt;B:a.x&lt;b.x;}void graham(){\tint k=1;\tfor(int i=2;i&lt;=n;++i)\t\tif(p[i].x&lt;p[k].x||(p[i].x==p[k].x&amp;&amp;p[i].y&lt;p[k].y))\t\t\tk=i;\tswap(p[1],p[k]),sort(p+2,p+n+1,cmp),st[top=1]=p[1];\tfor(int i=2;i&lt;=n;++i)\t{\t\twhile(top&gt;1&amp;&amp;sgn((p[i]-st[top-1])&amp;(st[top]-st[top-1]))&gt;=0) top--;\t\tst[++top]=p[i];\t}}int main(){    read(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y);\tgraham();\tfor(int i=1;i&lt;top;++i) ans+=dis(st[i],st[i+1]);\tprintf(\"%.2lf\",ans+dis(st[top],st[1]));\treturn 0;}\n\n旋转卡壳求凸包直径。\n#include&lt;bits/stdc++.h&gt;#define maxn 50010#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,top;int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }}p[maxn],st[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double operator % (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}int dis(const Vec &amp;a,const Vec &amp;b){    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}bool cmp(const Vec &amp;a,const Vec &amp;b){    double A=atan2(a.y-p[1].y,a.x-p[1].x),B=atan2(b.y-p[1].y,b.x-p[1].x);    return sgn(A-B)?A&lt;B:a.x&lt;b.x;}void graham(){\tint k=1;\tfor(int i=2;i&lt;=n;++i)\t\tif(p[i].x&lt;p[k].x||(p[i].x==p[k].x&amp;&amp;p[i].y&lt;p[k].y))\t\t\tk=i;\tswap(p[1],p[k]),sort(p+2,p+n+1,cmp),st[top=1]=p[1];\tfor(int i=2;i&lt;=n;++i)\t{\t\twhile(top&gt;1&amp;&amp;sgn((p[i]-st[top-1])*(st[top]-st[top-1]))&gt;=0) top--;\t\tst[++top]=p[i];\t}}int calc(){\tif(top==2) return dis(st[1],st[2]);\tint j=3,v=0;;\tst[top+1]=st[1];\tfor(int i=1;i&lt;=top;++i)\t{\t\twhile((st[i+1]-st[i])*(st[j]-st[i])&lt;=(st[i+1]-st[i])*(st[j+1]-st[i])) j=j%top+1;\t\tv=max(v,max(dis(st[j],st[i]),dis(st[j],st[i+1])));\t}\treturn v;}int main(){    read(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y);\tgraham(),printf(\"%d\",calc());\treturn 0;}\n\n半平面交求半平面交面积。\n#include&lt;bits/stdc++.h&gt;#define maxn 510#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,cnt,tot,h,t;int q[maxn];int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }    void in()    {        scanf(\"%lf%lf\",&amp;x,&amp;y);    }    double len()    {        return sqrt(x*x+y*y);    }}p[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double operator % (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}struct Line{    Vec a,b,c;    double k;    void init()    {        c=b-a,k=atan2(c.y,c.x);    }}l[maxn];bool cmp(const Line &amp;u,const Line &amp;v){    return sgn(u.k-v.k)?u.k&lt;v.k:sgn(u.c*(v.b-u.a))==-1;}Vec cross(Line u,Line v){    return v.a+v.c*((v.a-u.a)*u.c)/(u.c*v.c);}bool check(Line u,Line v,Line w){    return sgn(w.c*(cross(u,v)-w.a))==-1;}double get(){    double v=0;    sort(l+1,l+cnt+1,cmp);    for(int i=1;i&lt;=cnt;++i)        if(sgn(l[i].k-l[i-1].k))            l[++tot]=l[i];    q[h=t=1]=1,q[++t]=2;    for(int i=3;i&lt;=tot;++i)    {        while(h&lt;t&amp;&amp;check(l[q[t-1]],l[q[t]],l[i])) t--;        while(h&lt;t&amp;&amp;check(l[q[h]],l[q[h+1]],l[i])) h++;        q[++t]=i;    }    while(h&lt;t&amp;&amp;check(l[q[t-1]],l[q[t]],l[q[h]])) t--;    if(t-h+1&lt;=2) return 0;    q[t+1]=q[h],cnt=0;    for(int i=h;i&lt;=t;++i) p[++cnt]=cross(l[q[i]],l[q[i+1]]);    p[cnt+1]=p[1];    for(int i=1;i&lt;=cnt;++i) v+=p[i]*p[i+1];    return v/2;}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        int k;        read(k);        for(int j=1;j&lt;=k;++j)            l[++cnt].b.in(),l[cnt].a=l[cnt-1].b;        l[cnt-k+1].a=l[cnt].b;    }    for(int i=1;i&lt;=cnt;++i) l[i].init();    printf(\"%.3lf\",get());\treturn 0;}\n\n数学FFT#include&lt;bits/stdc++.h&gt;#define maxn 8000010#define Pi acos(-1.0)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int rev[maxn];struct Complex{\tdouble x,y;\tComplex(double a=0,double b=0)\t{\t\tx=a,y=b;\t}}f[maxn],g[maxn];Complex operator +(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x+b.x,a.y+b.y);}Complex operator -(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x-b.x,a.y-b.y);}Complex operator *(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void FFT(Complex *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tComplex T(cos(Pi/len),type*sin(Pi/len));\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tComplex t(1,0);\t\t\tfor(int j=i;j&lt;i+len;++j,t=t*T)\t\t\t{\t\t\t\tComplex x=a[j],y=t*a[j+len];\t\t\t\ta[j]=x+y,a[j+len]=x-y;\t\t\t}\t\t}\t}    if(type==1) return;    for(int i=0;i&lt;lim;++i) a[i].x=a[i].x/lim+0.5;}void mul(Complex *f,Complex *g){    int lim=calc(n+m);    FFT(f,lim,1),FFT(g,lim,1);    for(int i=0;i&lt;lim;++i) f[i]=f[i]*g[i];    FFT(f,lim,-1);}int main(){    read(n),read(m);    for(int i=0,x;i&lt;=n;++i) read(x),f[i].x=x;    for(int i=0,x;i&lt;=m;++i) read(x),g[i].x=x;    mul(f,g);    for(int i=0;i&lt;=n+m;++i) printf(\"%d \",(int)f[i].x);    return 0;}\n\n多项式全家桶#include&lt;bits/stdc++.h&gt;#define maxn 400010#define P 998244353#define G 3#define Gi (P+1)/Gusing namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,k,T,lenth;ll rev[maxn],f[maxn],g[maxn];char s[maxn];ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%P;        x=x*x%P,y&gt;&gt;=1;    }    return v;}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void NTT(ll *a,int lim,int type){    for(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);    for(int len=1;len&lt;lim;len&lt;&lt;=1)    {        ll wn=qp(type==1?G:Gi,(P-1)/(len&lt;&lt;1));        for(int i=0;i&lt;lim;i+=len&lt;&lt;1)        {            ll w=1;            for(int j=i;j&lt;i+len;++j,w=w*wn%P)            {                ll x=a[j],y=w*a[j+len]%P;                a[j]=(x+y)%P,a[j+len]=(x-y+P)%P;            }        }    }    if(type==1) return;    ll inv=qp(lim,P-2);    for(int i=0;i&lt;lim;++i) a[i]=a[i]*inv%P;}void Inv(int deg,ll *a,ll *b){    static ll t[maxn];    if(deg==1)    {        b[0]=qp(a[0],P-2);        return;    }    Inv((deg+1)&gt;&gt;1,a,b);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=b[i]*(2-t[i]*b[i]%P+P)%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Ln(int deg,ll *a,ll *b){    static ll inva[maxn],dera[maxn];    Inv(deg,a,inva);    for(int i=0;i&lt;deg-1;++i) dera[i]=a[i+1]*(i+1)%P;    dera[deg-1]=0;    int lim=calc(deg&lt;&lt;1);    for(int i=deg;i&lt;lim;++i) dera[i]=inva[i]=0;    NTT(dera,lim,1),NTT(inva,lim,1);    for(int i=0;i&lt;lim;++i) b[i]=dera[i]*inva[i]%P;    NTT(b,lim,-1);    for(int i=deg-1;i&gt;=1;--i) b[i]=b[i-1]*qp(i,P-2)%P;    b[0]=0;    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Exp(int deg,ll *a,ll *b){    static ll t[maxn],lnb[maxn];    if(deg==1)    {        b[0]=1;        return;    }    Exp((deg+1)&gt;&gt;1,a,b),Ln(deg,b,lnb);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1),NTT(lnb,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=b[i]*(1-lnb[i]+t[i]+P)%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Pow(int deg,ll *a,ll *b,ll k){    static ll lna[maxn];    Ln(deg,a,lna);    for(int i=0;i&lt;deg;++i) lna[i]=lna[i]*k%P;    Exp(deg,lna,b);}void Sqrt(int deg,ll *a,ll *b){    static ll t[maxn],invb[maxn];    if(deg==1)    {        b[0]=1;        return;    }    Sqrt((deg+1)&gt;&gt;1,a,b);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=2*b[i]%P,invb[i]=0;    for(int i=deg;i&lt;lim;++i) t[i]=invb[i]=0;    Inv(deg,t,invb);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1),NTT(invb,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=(b[i]*b[i]%P+t[i])%P*invb[i]%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}int main(){\tread(n);    for(int i=0;i&lt;n;++i) read(f[i]);    Sqrt(n,f,g);    for(int i=0;i&lt;n;++i) printf(\"%lld \",g[i]);\treturn 0;}\n\n分治 FFT#include&lt;bits/stdc++.h&gt;#define maxn 400010#define p 998244353using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n;int rev[maxn];ll f[maxn],g[maxn];ll qp(ll x,ll y){\tll v=1;\twhile(y)\t{\t\tif(y&amp;1) v=v*x%p;\t\tx=x*x%p,y&gt;&gt;=1;\t}\treturn v;}int calc(int n){\tint lim=1;\twhile(lim&lt;=n) lim&lt;&lt;=1;\tfor(int i=0;i&lt;lim;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);\treturn lim;}void NTT(ll *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)\t\tif(i&lt;rev[i])\t\t\tswap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tll wn=qp(3,(p-1)/(len&lt;&lt;1));\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tll w=1;\t\t\tfor(int j=i;j&lt;i+len;++j,w=w*wn%p)\t\t\t{\t\t\t\tll x=a[j],y=w*a[j+len]%p;\t\t\t\ta[j]=(x+y)%p,a[j+len]=(x-y+p)%p;\t\t\t}\t\t}\t}\tif(type==1) return;\tll inv=qp(lim,p-2);\tfor(int i=0;i&lt;lim;++i) a[i]=a[i]*inv%p;\treverse(a+1,a+lim);}void Inv(int deg,ll *f,ll *g){\tif(deg==1)\t{\t\tg[0]=qp(f[0],p-2);\t\treturn;\t}\tstatic ll t[maxn];\tInv((deg+1)&gt;&gt;1,f,g);\tint lim=calc(deg&lt;&lt;1);\tfor(int i=0;i&lt;deg;++i) t[i]=f[i];\tfor(int i=deg;i&lt;lim;++i) t[i]=0;\tNTT(t,lim,1),NTT(g,lim,1);\tfor(int i=0;i&lt;lim;++i) g[i]=(2*g[i]-t[i]*g[i]%p*g[i]%p+p)%p;\tNTT(g,lim,-1);\tfor(int i=deg;i&lt;lim;++i) g[i]=0;}int main(){\tread(n),f[0]=1;\tfor(int i=1;i&lt;n;++i) read(f[i]),f[i]=p-f[i];\tInv(n,f,g);\tfor(int i=0;i&lt;n;++i) printf(\"%lld \",g[i]);    return 0;}\n\n任意模数多项式乘法#include&lt;bits/stdc++.h&gt;#define maxn 800010#define all 262144#define M 32767#define Pi acos(-1.0)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,p;int rev[maxn],f[maxn],g[maxn],h[maxn];struct Complex{\tlong double x,y;\tComplex(long double a=0,long double b=0)\t{\t\tx=a,y=b;\t}}w[maxn];Complex operator +(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x+b.x,a.y+b.y);}Complex operator -(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x-b.x,a.y-b.y);}Complex operator *(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}Complex operator ~(const Complex &amp;a){\treturn Complex(a.x,-a.y);}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void init(int n){    int lim=calc(n);    for(int len=1;len&lt;lim;len&lt;&lt;=1)        for(int i=0;i&lt;len;++i)            w[i+len]=Complex(cos(Pi*i/len),sin(Pi*i/len));}void FFT(Complex *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tfor(int j=0;j&lt;len;++j)\t\t\t{\t\t\t\tComplex x=a[i+j],y=w[j+len]*a[i+j+len];\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\t\t\t}\t\t}\t}    if(type==1) return;    reverse(a+1,a+lim);    for(int i=0;i&lt;lim;++i)        a[i].x=a[i].x/lim+0.5,a[i].y=a[i].y/lim+0.5;} void MTT(int *f,int *g,int *h){    static Complex a[maxn],b[maxn],a0[maxn],b0[maxn];    int lim=calc(n+m);    for(int i=0;i&lt;lim;++i) a[i]=Complex(f[i]&gt;&gt;15,f[i]&amp;M);    for(int i=0;i&lt;lim;++i) b[i]=Complex(g[i]&gt;&gt;15,g[i]&amp;M);    FFT(a,lim,1),FFT(b,lim,1),a0[0]=~a[0],b0[0]=~b[0];    for(int i=1;i&lt;lim;++i) a0[i]=~a[lim-i],b0[i]=~b[lim-i];    for(int i=0;i&lt;lim;++i)    {        Complex v1=a[i],v2=a0[i],v3=b[i],v4=b0[i];        a[i]=(v1+v2)*Complex(0.5,0),a0[i]=(v1-v2)*Complex(0,-0.5);        b[i]=(v3+v4)*Complex(0.5,0),b0[i]=(v3-v4)*Complex(0,-0.5);    }    for(int i=0;i&lt;lim;++i)        a[i]=a[i]*b[i]+(a[i]*b0[i]+a0[i]*b[i])*Complex(0,1),b[i]=a0[i]*b0[i];    FFT(a,lim,-1),FFT(b,lim,-1);    for(int i=0;i&lt;lim;++i)        h[i]=((((ll)a[i].x%p&lt;&lt;30)%p+((ll)a[i].y%p&lt;&lt;15)%p)%p+(ll)b[i].x)%p;}int main(){    read(n),read(m),read(p),n++,m++,init(n+m);    for(int i=0;i&lt;n;++i) read(f[i]),f[i]%=p;    for(int i=0;i&lt;m;++i) read(g[i]),g[i]%=p;    MTT(f,g,h);    for(int i=0;i&lt;n+m-1;++i) printf(\"%d \",h[i]);    return 0;}\n\nFWT#include&lt;bits/stdc++.h&gt;#define maxn 131082#define p 998244353#define inv 499122177using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,all;ll va[maxn],vb[maxn],a[maxn],b[maxn];void FWT_or(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t\ta[j+len]=(a[j+len]+a[j]*type+p)%p;}void FWT_and(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t\ta[j]=(a[j]+a[j+len]*type+p)%p;}void FWT_xor(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t{\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t{\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t{\t\t\t\tll x=a[j],y=a[j+len];\t\t\t\ta[j]=(x+y)%p,a[j+len]=(x-y+p)%p;\t\t\t\tif(type==-1) a[j]=a[j]*inv%p,a[j+len]=a[j+len]*inv%p;\t\t\t}\t\t}\t}}void copy(){\tmemcpy(a,va,sizeof(va)),memcpy(b,vb,sizeof(vb));}void Or(){\tcopy(),FWT_or(a,1),FWT_or(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_or(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\tputchar('\\n');}void And(){\tcopy(),FWT_and(a,1),FWT_and(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_and(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\t\tputchar('\\n');}void Xor(){\tcopy(),FWT_xor(a,1),FWT_xor(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_xor(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\tputchar('\\n');}int main(){\tread(n),all=1&lt;&lt;n;\tfor(int i=0;i&lt;all;++i) read(va[i]);\tfor(int i=0;i&lt;all;++i) read(vb[i]);\tOr(),And(),Xor();    return 0;}\n\n子集卷积#include&lt;bits/stdc++.h&gt;#define maxn 21#define maxs 1200010#define p 1000000009#define lowbit(x) (x&amp;(-x))using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,all;int cnt[maxs],h[maxn][maxs],f[maxn][maxs],g[maxn][maxs];void FWT(int *a,int type){    for(int len=1;len&lt;all;len&lt;&lt;=1)        for(int i=0;i&lt;all;i+=len&lt;&lt;1)            for(int j=i;j&lt;i+len;++j)                a[j+len]=((a[j+len]+a[j]*type)%p+p)%p;}int main(){    read(n),all=1&lt;&lt;n;    for(int i=1;i&lt;all;++i) cnt[i]=cnt[i-lowbit(i)]+1;    for(int i=0;i&lt;all;++i) read(f[cnt[i]][i]);    for(int i=0;i&lt;all;++i) read(g[cnt[i]][i]);    for(int i=0;i&lt;=n;++i) FWT(f[i],1),FWT(g[i],1);    for(int i=0;i&lt;=n;++i)        for(int j=0;j&lt;=i;++j)            for(int s=0;s&lt;all;++s)                h[i][s]=(h[i][s]+(ll)f[i-j][s]*g[j][s]%p)%p;    for(int i=0;i&lt;=n;++i) FWT(h[i],-1);    for(int i=0;i&lt;all;++i) printf(\"%lld \",h[cnt[i]][i]);    return 0;}\n\n拉格朗日插值法 个点  可以唯一地确定一个多项式 。现在，给定这  个点，请你确定这个多项式，并求出  的值。\n#include&lt;bits/stdc++.h&gt;#define maxn 2010#define mod 998244353using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,k,ans;ll x[maxn],y[maxn];ll qp(ll x,ll y){\tll ans=1;\twhile(y)\t{\t\tif(y&amp;1) ans=(ans*x)%mod;\t\tx=(x*x)%mod;\t\ty&gt;&gt;=1;\t}\treturn ans;}int main(){\tread(n),read(k);\tfor(int i=1;i&lt;=n;++i) read(x[i]),read(y[i]);\tfor(int i=1;i&lt;=n;++i)\t{\t\tll p=1;\t\tfor(int j=1;j&lt;=n;++j)\t\t\tif(i!=j)\t\t\t\tp=p*(((x[i]-x[j])%mod+mod)%mod)%mod;\t\tp=qp(p,mod-2);\t\tfor(int j=1;j&lt;=n;++j)\t\t\tif(i!=j)\t\t\t\tp=p*(((k-x[j])%mod+mod)%mod)%mod;\t\tp=p*y[i]%mod;\t\tans=(ans+p)%mod;\t}\tprintf(\"%lld\\n\",ans);\treturn 0;}\n\n矩阵树定理给定一张  个结点  条边的带权图（可能为无向图，可能为有向图）。定义其一个生成树  的权值为  中所有边权的乘积。求其所有不同生成树的权值之和，对  取模。\n#include&lt;bits/stdc++.h&gt;#define maxn 310#define p 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,type;ll a[maxn][maxn];void add1(int x,int y,int v){    a[x][x]=(a[x][x]+v)%p;    a[y][y]=(a[y][y]+v)%p;    a[x][y]=(a[x][y]-v)%p;    a[y][x]=(a[y][x]-v)%p;}void add2(int x,int y,int v){    a[y][y]=(a[y][y]+v)%p;    a[x][y]=(a[x][y]-v)%p;}ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll det(){    ll ans=1;    for(int i=2;i&lt;=n;++i)    {        int ma=i;        for(int j=i+1;j&lt;=n;++j)            if(a[j][i]&gt;a[ma][i])                ma=j;        if(ma!=i) swap(a[i],a[ma]),ans*=-1;        if(!a[i][i]) return 0;        ll inv=qp(a[i][i],p-2);        for(int j=i+1;j&lt;=n;++j)        {            ll d=a[j][i]*inv%p;            for(int k=i;k&lt;=n;++k) a[j][k]=((a[j][k]-a[i][k]*d%p)%p+p)%p;        }        ans=ans*a[i][i]%p;    }    return (ans%p+p)%p;}int main(){    read(n),read(m),read(type);    for(int i=1;i&lt;=m;++i)    {        int a,b,v;        read(a),read(b),read(v);        if(!type) add1(a,b,v);        else add2(a,b,v);    }    printf(\"%lld\",det());    return 0;}\n\n高斯消元#include&lt;bits/stdc++.h&gt;#define maxn 110#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n;double a[maxn][maxn];bool gauss(){    for(int i=1;i&lt;=n;++i)    {        int ma=i;        for(int j=i+1;j&lt;=n;++j)            if(fabs(a[j][i])&gt;fabs(a[ma][i]))                ma=j;        swap(a[ma],a[i]);        double d=a[i][i];        if(fabs(d)&lt;eps) return false;        for(int j=i;j&lt;=n+1;++j) a[i][j]/=d;        for(int j=i+1;j&lt;=n;++j)        {            d=a[j][i];            for(int k=i;k&lt;=n+1;++k)                a[j][k]-=a[i][k]*d;        }    }    for(int i=n;i;--i)        for(int j=i-1;j;--j)            a[j][n+1]-=a[j][i]*a[i][n+1];    return true;}int main(){\tread(n);    for(int i=1;i&lt;=n;++i)    {        for(int j=1;j&lt;=n+1;++j)        {            int val;            read(val);            a[i][j]=val;        }    }    if(!gauss())    {        puts(\"No Solution\");        return 0;    }    for(int i=1;i&lt;=n;++i)         printf(\"%.2lf\\n\",a[i][n+1]);\treturn 0;}\n\n矩阵求逆#include&lt;bits/stdc++.h&gt;#define maxn 810#define mod 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m;ll a[maxn][maxn];ll inv(ll x){    ll y=mod-2,ans=1;    while(y)    {        if(y&amp;1) ans=ans*x%mod;        x=x*x%mod;        y&gt;&gt;=1;    }    return ans;}bool gauss(){    for(int i=1;i&lt;=n;++i)    {        for(int j=i;j&lt;=n;++j)        {               if(a[j][i])            {                swap(a[j],a[i]);                break;            }        }        if(!a[i][i]) return false;        ll d=inv(a[i][i]);        for(int j=i;j&lt;=m;++j) a[i][j]=a[i][j]*d%mod;        for(int j=1;j&lt;=n;++j)        {            if(i==j) continue;            d=a[j][i]%mod;            for(int k=i;k&lt;=m;++k)                a[j][k]=((a[j][k]-a[i][k]*d%mod)%mod+mod)%mod;        }    }    return true;}int main(){    read(n),m=2*n;    for(int i=1;i&lt;=n;++i)    {        for(int j=1;j&lt;=n;++j) read(a[i][j]);        a[i][i+n]=1;    }    if(gauss())    {        for(int i=1;i&lt;=n;++i)        {            for(int j=n+1;j&lt;=m;++j)                printf(\"%lld \",a[i][j]);            puts(\"\");        }    }    else puts(\"No Solution\");    return 0;}\n\n欧拉筛void init(){    mu[1]=1;    for(int i=2;i&lt;=all;++i)    {        if(!tag[i]) pri[++tot]=i,mu[i]=-1;        for(int j=1;j&lt;=tot;++j)        {            int k=i*pri[j];            if(k&gt;all) break;            tag[k]=true;            if(i%pri[j]) mu[k]=mu[i]*mu[pri[j]];            else            {                mu[k]=0;                break;            }        }    }}\n\nPollard’s rho求最大质因子。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll T,n,fac_max;ll pri[14]={2,3,5,7,11,13,17,19,23,29};ll mul(ll x,ll y,ll mod){\tll c=(long double)x*y/mod+0.5;\tc=x*y-c*mod;\treturn c&lt;0?c+mod:c;}ll qp(ll x,ll y,ll mod){    ll ans=1;    while(y)    {        if(y&amp;1) ans=mul(ans,x,mod);        x=mul(x,x,mod);        y&gt;&gt;=1;    }    return ans%mod;}bool check(ll x,ll p,ll mod){    ll t=qp(x,p,mod);    if(t==mod-1) return true;    if(t==1) return p&amp;1?true:check(x,p/2,mod);    return false;}bool Miller_Rabin(ll n){    if(n==1) return false;    if(n&lt;=3) return true;    if(!(n&amp;1)) false;    for(int i=0;i&lt;10;++i)    {        if(n==pri[i]) return true;        if(!check(pri[i],n-1,n)) return false;    }    return true;}ll gcd(ll a,ll b){    return b?gcd(b,a%b):a;}ll f(ll x,ll y,ll mod){    return (mul(x,x,mod)+y)%mod;}ll Pollard_Rho(ll x){    ll s=0,t=0,c=(ll)1*rand()%(x-1)+1,val=1;    for(ll goal=1;;goal&lt;&lt;=1,s=t,val=1)    {        for(ll step=1;step&lt;=goal;++step)        {            t=f(t,c,x);            val=mul(val,abs(t-s),x);            if(step%127==0)            {                ll d=gcd(val,x);                if(d&gt;1) return d;            }        }        ll d=gcd(val,x);        if(d&gt;1) return d;    }}void fac(ll x){    if(x&lt;=fac_max||x&lt;2) return;    if(Miller_Rabin(x))     {        fac_max=max(fac_max,x);        return;    }    ll p=x;    while(p&gt;=x) p=Pollard_Rho(x);    while(x%p==0) x/=p;    fac(x),fac(p);}int main(){    read(T);    while(T--)    {        srand(114514);        read(n);        fac_max=0;        fac(n);        if(fac_max==n) puts(\"Prime\");        else printf(\"%lld\\n\",fac_max);    }\treturn 0;}\n\n杜教筛求  的前缀和。\n#include&lt;bits/stdc++.h&gt;#define maxn 5000010#define all 5000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n,tot;ll p[maxn],phi[maxn],mu[maxn];bool tag[maxn];unordered_map&lt;int,ll&gt; s_phi,s_mu;void init(){    mu[1]=phi[1]=1;    for(int i=2;i&lt;=all;++i)    {        if(!tag[i]) p[++tot]=i,phi[i]=i-1,mu[i]=-1;        for(int j=1;j&lt;=tot;++j)        {            int k=i*p[j];            if(k&gt;all) break;            tag[k]=true;            if(i%p[j]) phi[k]=phi[i]*phi[p[j]],mu[k]=mu[i]*mu[p[j]];            else            {                mu[k]=0,phi[k]=phi[i]*p[j];                break;               }        }    }    for(int i=1;i&lt;=all;++i) phi[i]+=phi[i-1],mu[i]+=mu[i-1];}ll getphi(ll n){    if(n&lt;=all) return phi[n];    if(s_phi[n]) return s_phi[n];    ll v=n*(n+1)/2;    for(int l=2,r;l&lt;=n;l=r+1)        r=n/(n/l),v-=(r-l+1)*getphi(n/l);    return s_phi[n]=v;}ll getmu(ll n){    if(n&lt;=all) return mu[n];    if(s_mu[n]) return s_mu[n];    ll v=1;    for(int l=2,r;l&lt;=n;l=r+1)        r=n/(n/l),v-=(r-l+1)*getmu(n/l);    return s_mu[n]=v;}int main(){    init(),read(T);    while(T--) read(n),printf(\"%lld %lld\\n\",getphi(n),getmu(n));    return 0;}\n\n扩展 BSGS给定 ，求满足  的最小自然数 。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll a,b,p,x,y,ans;unordered_map&lt;ll,int&gt; h;ll qp(ll x,ll y,ll p){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll exgcd(ll a,ll b){    if(!b)    {        x=1,y=0;        return a;    }    ll g=exgcd(b,a%b),tmp=x;    x=y,y=tmp-a/b*y;    return g;}ll inv(ll a,ll p){    exgcd(a,p);    return (x%p+p)%p;}ll bsgs(ll a,ll b,ll p){    ll s=ceil(sqrt(p)),v=b,val;    for(int i=0;i&lt;=s;++i,v=v*a%p) h[v]=i;    v=val=qp(a,s,p);    for(int i=1;i&lt;=s;++i,v=v*val%p)        if(h.count(v))            return i*s-h[v];    return -1;}ll exbsgs(ll a,ll b,ll p){    a%=p,b%=p;    if(b==1||p==1) return 0;    ll g,cnt=0,mul=1,v=a;    for(int i=1;i&lt;=30;++i,v=v*a%p)        if(v==b)            return i;    while((g=exgcd(a,p))!=1)    {        if(b%g!=0) return -1;        cnt++,b/=g,p/=g,mul=mul*(a/g)%p;    }    ll ans=bsgs(a,b*inv(mul,p)%p,p);    if(~ans) return ans+cnt;    return -1;}int main(){    while(1)    {        read(a),read(p),read(b);        if(!a&amp;&amp;!b&amp;&amp;!p) break;        h.clear(),ans=exbsgs(a,b,p);        if(~ans) printf(\"%lld\\n\",ans);        else puts(\"No Solution\");    }\treturn 0;}\n\n扩展中国剩余定理给定   组非负整数   ，求解关于   的方程组的最小非负整数解。\n#include&lt;bits/stdc++.h&gt;#define maxn 100010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll n,x,y;ll a[maxn],m[maxn];ll mul(ll x,ll y,ll mod){    ll ans=0;    while(y)     {        if(y&amp;1) ans=(ans+x)%mod;        x=(x+x)%mod;        y&gt;&gt;=1;    }    return ans%mod;}ll exgcd(ll a,ll b){    if(!b)    {        x=1,y=0;        return a;    }    ll ans=exgcd(b,a%b);    ll tmp=x;    x=y,y=tmp-a/b*y;    return ans;}ll excrt(){    ll ans=a[1],M=m[1];    for(int i=2;i&lt;=n;++i)    {        ll g=exgcd(M,m[i]),tmp=((a[i]-ans)%m[i]+m[i])%m[i];        if(tmp%g!=0) return -1;        ans+=mul(x,tmp/g,m[i])*M,M*=m[i]/g,ans=(ans%M+M)%M;    }    return ans;}int main(){    read(n);    for(int i=1;i&lt;=n;++i) read(m[i]),read(a[i]);    printf(\"%lld\",excrt());\treturn 0;}\n\n扩展欧拉定理给你三个正整数，，你需要求：。\n#include&lt;bits/stdc++.h&gt;#define maxn 20000010 using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll a,m,b,phi,len;char s[maxn];bool flag;ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%m;        x=x*x%m,y&gt;&gt;=1;    }    return v%m;}ll get_phi(ll x){\tll v=x,t=sqrt(x);\tfor(int i=2;i&lt;=t;++i)    {\t\tif(x%i) continue;\t\tv=v*(i-1)/i;\t\twhile(x%i==0) x/=i;\t}\tif(x&gt;1) v=v*(x-1)/x;\treturn v;}int main(){\tread(a),read(m),phi=get_phi(m);    scanf(\"%s\",s+1),len=strlen(s+1);    for(int i=1;i&lt;=len;++i)     {        b=((b&lt;&lt;1)+(b&lt;&lt;3)+(s[i]^48));        if(b&gt;=phi) b%=phi,flag=true;    }    if(flag) b+=phi;    printf(\"%lld\",qp(a,b));\treturn 0;}\n\n扩展卢卡斯定理求 。\n#include&lt;bits/stdc++.h&gt;#define maxn 12#define maxm 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,p,cnt;ll pri[maxn],pk[maxn],a[maxn][maxm];void exgcd(ll a,ll b,ll &amp;x,ll &amp;y){    if(!b) x=1,y=0;    else exgcd(b,a%b,y,x),y-=a/b*x;}ll inv(ll a,ll p){    ll x,y;    exgcd(a,p,x,y);    return (x%p+p)%p;}ll qp(ll x,ll y,ll p){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll f(ll n,int x){    if(!n) return 1;    ll k=pk[x];    return f(n/pri[x],x)*qp(a[x][k],n/k,k)%k*a[x][n%k]%k;}ll C(ll n,ll m,int x){    ll v=0,p=pri[x],k=pk[x];    for(ll i=n;i;i=i/p) v+=i/p;    for(ll i=m;i;i=i/p) v-=i/p;    for(ll i=n-m;i;i=i/p) v-=i/p;    return f(n,x)*inv(f(m,x),k)%k*inv(f(n-m,x),k)%k*qp(p,v,k)%k;}ll crt(ll x,ll m,ll p){    return x*(m/p)*inv(m/p,p);}ll exlucas(ll n,ll m){    ll v=0;    for(int i=1;i&lt;=cnt;++i) v=(v+crt(C(n,m,i),p,pk[i]))%p;    return v;}void init(int x){    a[x][0]=1;    for(int i=1;i&lt;=pk[x];++i)    {        a[x][i]=a[x][i-1];        if(i%pri[x]) a[x][i]=a[x][i]*i%pk[x];    }}void pre(ll x){    for(int i=2;i*i&lt;=x;++i)    {        if(x%i) continue;        ll v=1;        while(x%i==0) x/=i,v*=i;        pri[++cnt]=i,pk[cnt]=v;    }    if(x!=1) pri[++cnt]=x,pk[cnt]=x;    for(int i=1;i&lt;=cnt;++i) init(i);}int main(){    read(n),read(m),read(p),pre(p),printf(\"%lld\",exlucas(n,m));    return 0;}\n\n二次剩余给出 ，求解方程 ，保证  是奇素数。\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n,p,t,v1,v2;struct Complex{    ll x,y;    Complex(ll a=0,ll b=0)    {        x=a,y=b;    }};Complex operator * (const Complex &amp;a,const Complex &amp;b){    return Complex((a.x*b.x%p+a.y*b.y%p*t%p)%p,(a.x*b.y%p+a.y*b.x%p)%p);}Complex qp(Complex x,ll y){    Complex v=Complex(1,0);    while(y)    {        if(y&amp;1) v=v*x;        x=x*x,y&gt;&gt;=1;    }    return v;}ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll solve(ll n,ll p){    if(p==2) return n;    if(qp(n,(p-1)/2)==p-1) return -1;    ll a;    while(true)    {        a=rand()%p,t=((a*a%p-n)%p+p)%p;        if(qp(t,(p-1)/2)==p-1) break;    }    return qp(Complex(a,1),(p+1)/2).x;}int main(){    read(T);    while(T--)    {        read(n),read(p),n%=p;        if(!n)        {            puts(\"0\");            continue;        }        v1=solve(n,p);        if(v1==-1)        {            puts(\"Hola!\");            continue;        }        v2=p-v1;        if(v1&gt;v2) swap(v1,v2);        if(v1==v2) printf(\"%lld\\n\",v1);        else printf(\"%lld %lld\\n\",v1,v2);    }    return 0;}\n\n杂项矩阵快速幂#include&lt;bits/stdc++.h&gt;#define p 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n;struct matrix{    ll a[6][6];    matrix()    {        memset(a,0,sizeof(a));    }}m,ans;matrix operator *(const matrix &amp;a,const matrix &amp;b){    matrix c;    for(int i=0;i&lt;5;++i)        for(int j=0;j&lt;5;++j)            for(int k=0;k&lt;5;++k)                c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%p+p)%p;    return c;}matrix qp(matrix x,ll y){    matrix e;    for(int i=0;i&lt;5;++i) e.a[i][i]=1;    while(y)    {        if(y&amp;1) e=e*x;        x=x*x,y&gt;&gt;=1;    }    return e;}ll m1[6][6]={    {2,0,1,1,1}};ll m2[6][6]={    {1,1,0,0,0},    {1,0,0,0,0},    {2,0,1,1,1},    {0,0,1,0,0},    {2,0,0,0,1}};int main(){    read(T);    memcpy(ans.a,m1,sizeof(ans.a));    memcpy(m.a,m2,sizeof(m.a));    while(T--)    {        read(n);        if(n&lt;3) puts(\"0\");        else printf(\"%lld\\n\",(ans*qp(m,n-3)).a[0][0]);    }    return 0;}\n\n模拟退火最大化\n#include&lt;bits/stdc++.h&gt;#define maxn 55#define eps 1e-10using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,ans,cnt=1000;struct node{    int a,b;}p[maxn];int calc(){    int v=0;    for(int i=1;i&lt;=n+m;++i)    {        v+=p[i].a+p[i].b;        if(p[i-1].a==10) v+=p[i].a+p[i].b;        else if(p[i-1].a+p[i-1].b==10) v+=p[i].a;    }    return v;}void SA(){    double T=1000000,delta=0.9895;\twhile(T&gt;eps)\t{\t\tint x=rand()%(n+m)+1,y=rand()%(n+m)+1,v;        while(x==y||(m&amp;&amp;(x==n||y==n))) x=rand()%(n+m)+1,y=rand()%(n+m)+1;\t\tswap(p[x],p[y]),v=calc();\t\tif(v&gt;ans) ans=v;\t\telse if(exp((v-ans)/T)*RAND_MAX&lt;rand()) swap(p[x],p[y]);\t\tT*=delta;\t}}int main(){    srand((long long)new char),read(n);    for(int i=1;i&lt;=n;++i) read(p[i].a),read(p[i].b);    if(p[n].a==10) m=1,read(p[n+1].a),read(p[n+1].b);    while(cnt--) SA();    printf(\"%d\",ans);    return 0;}\n\n最小化\n#include&lt;bits/stdc++.h&gt;#define maxn 35#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=x*10+(c^48);c=getchar();}\tif(flag)x=-x;}int t,n,num;int a[maxn];int ans;int work(){\tint u=0,v=0;\tfor(int i=1;i&lt;=(n+1)/2;++i) u+=a[i];\tfor(int i=(n+1)/2+1;i&lt;=n;++i) v+=a[i];\treturn abs(u-v);}void SA(){\tdouble T=3000,delta=0.925;\twhile(T&gt;1e-10)\t{\t\tint x=rand()%n+1, y=rand()%n+1;\t\tswap(a[x],a[y]);\t\tint now=work();\t\tif(now&lt;ans) ans=now;\t\telse if(exp((ans-now)/T)*RAND_MAX&lt;rand())  swap(a[x],a[y]);\t\tT*=delta;\t}}void clear(){\tans=inf;\tnum=1111;}int main(){\tsrand(19260817);\tread(t);\twhile(t--)\t{\t\tclear();\t\tread(n);\t\tfor(int i=1;i&lt;=n;++i) read(a[i]);\t\twhile(num--) SA();\t\tprintf(\"%d\\n\",ans);\t}\treturn 0;}\n\n整体二分带修区间第  小。\n#include&lt;bits/stdc++.h&gt;#define maxn 600010#define inf 1000000000#define lowbit(x) (x&amp;(-x))using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt;int a[maxn],ans[maxn],tr[maxn];char s[8];struct node{    int l,r,k,id,pos;}p[maxn],q1[maxn],q2[maxn];void update(int x,int v){    while(x&lt;=n)        tr[x]+=v,x+=lowbit(x);}int query(int x){    int ans=0;    while(x)        ans+=tr[x],x-=lowbit(x);    return ans;}void solve(int L,int R,int l,int r){    if(L&gt;R) return;    if(l==r)    {        for(int i=L;i&lt;=R;++i)            if(p[i].l)                ans[p[i].id]=l;        return;    }    int mid=(l+r)&gt;&gt;1,cnt1=0,cnt2=0;    for(int i=L;i&lt;=R;++i)    {        if(p[i].l)        {            int v=query(p[i].r)-query(p[i].l-1);            if(p[i].k&lt;=v) q1[++cnt1]=p[i];            else p[i].k-=v,q2[++cnt2]=p[i];        }        else        {            if(p[i].k&lt;=mid) q1[++cnt1]=p[i],update(p[i].pos,p[i].id);            else q2[++cnt2]=p[i];        }    }    for(int i=1;i&lt;=cnt1;++i) p[L+i-1]=q1[i];    for(int i=1;i&lt;=cnt2;++i) p[L+cnt1+i-1]=q2[i];    for(int i=1;i&lt;=cnt1;++i)        if(q1[i].pos)            update(q1[i].pos,-q1[i].id);    solve(L,L+cnt1-1,l,mid),solve(L+cnt1,R,mid+1,r);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i)        read(a[i]),p[++cnt].k=a[i],p[cnt].pos=i,p[cnt].id=1;    for(int i=1;i&lt;=m;++i)    {        scanf(\"%s\",s);        if(s[0]=='Q')            read(p[++cnt].l),read(p[cnt].r),read(p[cnt].k),p[cnt].id=i;        else        {            int x,y;            read(x),read(y);            p[++cnt].k=a[x],p[cnt].pos=x,p[cnt].id=-1;            p[++cnt].k=a[x]=y,p[cnt].pos=x,p[cnt].id=1;        }    }    solve(1,cnt,-inf,inf);    for(int i=1;i&lt;=cnt;++i)        if(ans[i])            printf(\"%d\\n\",ans[i]);    return 0;}\n\n树哈希#include&lt;bits/stdc++.h&gt;#define fi first#define se second#define mp make_pair#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;template&lt;typename T&gt; bool chkmax(T &amp;x,T y){return x&lt;y?x=y,1:0;}template&lt;typename T&gt; bool chkmin(T &amp;x,T y){return x&gt;y?x=y,1:0;}int readint(){\tint x=0,f=1; char ch=getchar();\twhile(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\treturn x*f;}int n,tot,cnt;int v[2000005],nxt[2000005],h[1000005];ull hs[1000005];mt19937_64 mrand(chrono::steady_clock::now().time_since_epoch().count());void addedge(int x,int y){\tv[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\tv[++tot]=x; nxt[tot]=h[y]; h[y]=tot;}ull f(ull x){return x*x*x+x+7;}ull calc(ull x){return f(x);}void dfs(int u,int fa){\ths[u]=1;\tfor(int p=h[u];p;p=nxt[p]){\t\tif(v[p]==fa) continue;\t\tdfs(v[p],u);\t\ths[u]+=hs[v[p]];\t}\ths[u]=calc(hs[u]);}int main(){\tn=readint();\tfor(int i=1;i&lt;n;i++) addedge(readint(),readint());\tdfs(1,-1);\tsort(hs+1,hs+n+1);\tprintf(\"%d\\n\",unique(hs+1,hs+n+1)-hs-1);\treturn 0;}\n\nPrufer 序列#include&lt;bits/stdc++.h&gt;#define maxn 5000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;ll ans;ll fa[maxn],p[maxn],d[maxn];void Prufer(){    for(int i=1;i&lt;n;++i) read(fa[i]),d[fa[i]]++;    int pos=1;    for(int i=1;i&lt;=n-2;++i)    {        while(d[pos]) pos++;        p[i]=fa[pos];        while(i&lt;=n-2&amp;&amp;--d[p[i]]==0&amp;&amp;p[i]&lt;pos) p[i+1]=fa[p[i]],i++;        pos++;    }    for(int i=1;i&lt;=n-2;++i) ans^=i*p[i];}void Father(){    for(int i=1;i&lt;=n-2;++i) read(p[i]),d[p[i]]++;    p[n-1]=n;    int pos=1;    for(int i=1;i&lt;n;++i)    {        while(d[pos]) pos++;        fa[pos]=p[i];        while(i&lt;n&amp;&amp;--d[p[i]]==0&amp;&amp;p[i]&lt;pos) fa[p[i]]=p[i+1],i++;        pos++;    }    for(int i=1;i&lt;n;++i) ans^=i*fa[i];}int main(){    read(n),read(m);    if(m==1) Prufer();    else Father();    printf(\"%lld\",ans);    return 0;}\n\n高精度struct bign{     int len, s[30005];    bign (){        memset(s, 0, sizeof(s));        len = 1;    }    bign (int num) { *this = num; }    bign (const char *num) { *this = num; }    bign operator = (const int num){        char s[30005];        sprintf(s, \"%d\", num);        *this = s;        return *this;    }    void clean(){        while(len &gt; 1 &amp;&amp; !s[len-1]) len--;    }     bign operator = (const char *num){        memset(s, 0, sizeof s);        len = strlen(num);        for(int i = 0; i &lt; len; i++) {            if (isdigit(num[len-i-1])) s[i] = num[len-i-1] - '0';            else s[i] = num[len-i-1] - 'A' + 10;        }        clean();        return *this;    }    bign operator + (const bign &amp;b) const{        bign c;        c.len = max(len, b.len);        for (int i = 0; i &lt; c.len; i++){            c.s[i] += s[i] + b.s[i];            c.s[i+1] += c.s[i] / 10;            c.s[i] %= 10;        }        if (c.s[c.len]) c.len++;        c.clean();        return c;    }    bign operator += (const bign &amp;b){        *this = *this + b;        return *this;    }    bign operator * (const bign &amp;b) {        bign c;        c.len = len + b.len;        for(int i = 0; i &lt; len; i++)            for(int j = 0; j &lt; b.len; j++){                c.s[i+j] += s[i] * b.s[j];            }        for(int i = 0; i &lt; c.len; i++){            c.s[i+1] += c.s[i]/10;            c.s[i] %= 10;        }        c.clean();        return c;    }    bign operator *= (const bign &amp;b){        *this = *this * b;        return *this;    }    bign operator - (const bign &amp;b){        bign c;        c.len = 0;        for(int i = 0, g = 0; i &lt; len; i++){            int x = s[i] - g;            if(i &lt; b.len) x -= b.s[i];            if(x &gt;= 0) g = 0;            else{                g = 1;                x += 10;            }            c.s[c.len++] = x;        }        c.clean();        return c;    }    bign operator -= (const bign &amp;b){        *this = *this - b;        return *this;    }    bign operator / (const int &amp;b){        int f = 0;        bign c;        for (int i = len-1; i &gt;= 0; i--){            f = f *10 + s[i];            c.s[i] = f / b;            f %= b;        }        c.len = len;        c.clean();        return c;    }    bign operator / (const bign &amp;b){        bign c, f = 0;        for(int i = len-1; i &gt;= 0; i--){            f = f*10;             f.s[0] = s[i];             while(f &gt; b || f == b){                f -= b;                c.s[i]++;            }        }        c.len = len;        c.clean();        return c;    }    bign operator /= (const bign &amp;b){        *this  = *this / b;        return *this;    }    bign operator % (const bign &amp;b){        bign r = *this / b;        r = *this - r*b;        return r;    }    bign operator %= (const bign &amp;b){        *this = *this % b;        return *this;    }    bool operator &lt; (const bign &amp;b){        if(len != b.len) return len &lt; b.len;        for(int i = len-1; i &gt;= 0; i--){            if(s[i] != b.s[i]) return s[i] &lt; b.s[i];        }        return false;    }    bool operator &gt; (const bign &amp;b){        if(len != b.len) return len &gt; b.len;        for(int i = len-1; i &gt;= 0; i--){            if(s[i] != b.s[i]) return s[i] &gt; b.s[i];        }        return false;    }    bool operator == (const bign &amp;b){        return !(*this &gt; b) &amp;&amp; !(*this &lt; b);    }    string str() const{        string res = \"\";         for (int i = 0; i &lt; len; i++) {            if (s[i] &lt; 10) res = char(s[i]+'0') + res;            else res = char(s[i] + 'A' - 10) + res;        }        return res;    }} a, b, c;\n\n","categories":["算法竞赛"],"tags":["模板"]}]
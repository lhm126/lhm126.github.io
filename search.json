[{"title":"7.17 组会","url":"/2023/07/16/7.17%20%E7%BB%84%E4%BC%9A/","content":"Chaitanya K. Joshi, Thomas Laurent, and Xavier Bresson. \"An Efficient\r\nGraph Convolutional Network Technique for the Travelling Salesman\r\nProblem.\", Computing Research Repository abs/1906.01227\r\n(2019)\r\n和 \r\n中的一样，神经网络的输出 \r\n表示该边在图的最优解中的概率，损失函数为 \r\n和最优解的交叉熵损失，即为将问题看作为一个分类问题。\r\n得到 \r\n后，通过束搜索来求解问题。\r\nWouter Kool, Herke van Hoof, and Max Welling. \"Attention, Learn to\r\nSolve Routing Problems!\", arXiv: Machine Learning (2019)\r\n文章由 \r\n提出了一个基于注意力层的模型，并用  算法来训练模型。\r\n将  问题的解定义为\r\n，是节点的一个排列。基于问题实例\r\n 找到解  的随机策略： \r\nEncoder\r\n\r\n没有采用位置编码，输入的节点无次序之分。\r\n先将维度为  的节点坐标特征\r\n 嵌入到维度为  的向量  中：  然后 \r\n通过  层注意力层来更新（实验中\r\n），类似于 ，注意力层每一层包含两个子层，一个\r\n 头注意力层（）和一个全连接层（），每个子层中还有残差链接和批归一化：  通过 \r\n得到点嵌入 \r\n和图嵌入 ，都作为\r\n 的输入。\r\nAttention mechanism\r\n\r\nMulti-head attention\r\n\r\nFeed-forward sublayer\r\n\r\nBatch normalization\r\n\r\nDecoder\r\n\r\n\r\n由两层注意力层构成，一层多头注意力层，一层单头注意力，这里的注意力层没有采用残差连接、批归一化、全连接层操作，而是直接得到相关性分数。\r\n： 在  时刻的输入来自  和  之前其本身的输出：  其中  和\r\n 是维度为  的学习到的参数。\r\n将  和\r\n 计算：  然后和上面  中一样求出 \r\n头注意力层输出结果 。\r\n最后用一个单头注意力层来求出输出概率 ，其中用\r\n 函数来将结果修正到 ： \r\nTrain\r\npolicy gradient\r\n\r\n论文中的梯度计算公式为：  其中 \r\n是累计奖励函数，对于 \r\n即为路径长度。 是 ，减去  后能减少  的方差，利于梯度更新。\r\n\r\n\r\n是采取采样策略，\r\n的概率选择当前概率最大的点输出，\r\n的概率随机选择一个点输出。\r\n\r\n是采取贪心策略，每次都是选择当前概率最大的点输出。\r\n当  和  两个分布差异很大时，则用\r\n 来更新 。\r\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"Crash Course Computer Science","url":"/2022/10/23/Crash%20Course%20Computer%20Science/","content":"4. 二进制\r\n位，bit，即为二进制的一位，\r\n位储存的信息大小为 。字节，byte​， 字节为  位。\r\nIEEE 754 标准，用来存储浮点数。如  写成 ， 为有效位数， 为指数。对于  位浮点数（float 型浮点数）， 位表示正负， 位存储指数， 位存储有效位数。\r\n5. 算术逻辑单元\r\n算术逻辑单元（ALU），含有算术单元和逻辑单元。\r\n算法单元：两个半加器（可以输入两个 ）组成全加器（可以输入三个 ，两个数字相加以及进位情况）， 个全加器可制作  位加法器。当 \r\n位加法器中最后一个全加器产生进位时，就是发生溢出（overflow）了。现代计算机使用超前进位加法器。\r\n6. 寄存器 &amp; 内存\r\n随机存取存储器（RAM），持久存储。\r\nAND-OR 锁存器（存储一位信息），八个组成一个 \r\n位寄存器。用矩阵来实现更高位的寄存器，有列地址和行地址。多路复用器用来找到对应的地址（寻址）。\r\nSRAM（静态随机存取存储器）。\r\n寄存器：很小的一块内存，能存一个值。\r\nRAM：一大块内存，能在不同地址存大量数字。\r\n7. 中央处理器(CPU)\r\nCPU 负责执行程序，程序由指令组成。数学指令：CPU 用 ALU\r\n进行数学运算。内存指令：CPU 和内存通信，进行读值或写值。\r\n寄存器用来临时存数据和操作数据。\r\nCPU 状态：取指令，解码，执行。\r\n9. 高级CPU设计\r\n给 CPU 加一点 RAM，叫缓存（cache）。\r\n缓存命中（cache hit）：想要的数据已经在缓存。\r\n缓存未命中（cache miss）：想要的数据不在缓存。\r\n脏位（dirty bit）：同步一般发生在当缓存满了而 CPU\r\n又要缓存时。在清理缓存腾出空间之前，会先检查”脏位“，如果是”脏“的，在加载新内容之前，会把数据写回\r\nRAM。\r\n脏位的意义：修改数据时，为提高速度，会直接在缓存修改，而 RAM\r\n未修改。\r\n指令流水线：并行处理，但要先弄清数据依赖性，必要时停止流水线。高端\r\nCPU\r\n会动态排序有依赖关系的指令，最小化流水线的停工时间，这叫做”乱序执行“。条件跳转会产生”岔路口“，高端\r\nCPU\r\n会猜那条路可能性大一些，然后提前把指令放进流水线，这叫做”推测执行“。\r\n多核处理器：同时运行多个指令流。\r\n11. 编程语言发展史\r\n二进制是处理器的“母语”，这叫“机器语言”或“机器码”。\r\n汇编器读取用“汇编语言”写的程序，然后转成“机器码”。\r\n高级编程语言：程序员只需创建代表内存地址的抽象，叫“变量”。\r\n16. 软件工程\r\n把函数打包成层级，把相关代码都放在一起，打包成对象（objects）。把函数打包成对象的思想叫“面向对象编程”。\r\n程序编程接口，简称 API，帮助不同程序员合作。API\r\n控制哪些函数和数据让外部访问，哪些仅供内部（设定 public 或\r\nprivate）。\r\n集成开发环境，简称 IDE。\r\n源代码管理，也叫“版本控制”，比如 GIT，SVN。\r\n测试可以统称“质量保证测试”，检查 QA。\r\n17. 集成电路&amp;摩尔定律\r\n集成电路（IC），封装一定数量的常用电子元件，把分立元件封装成一个独立单元。\r\n印刷电路板，简称 PCB。\r\n光刻，用光把复杂图案印到材料上，比如半导体。\r\n18. 操作系统\r\n操作系统，简称 OS，充当软件和硬件之间的媒介。更具体地说，操作系统提供\r\nAPI 来抽象硬件，叫“设备驱动程序”。\r\n虚拟内存，操作系统会自动处理虚拟内存和物理内存之间的映射（物理内存地址不连续，但虚拟内存地址连续）。\r\n这种机制使程序的内存大小可以灵活增减，叫“动态内存分配”。对程序来说，内存看起来是连续的。这为操作系统同时运行多个程序提供了极大的灵活性。\r\n给程序分配专用的内存范围的另一个好处：程序出错后，只能捣乱自己的内存，不会影响到其它程序，这叫“内存保护”。\r\n分时操作系统，每个用户只能用一小部分处理器，内存等。\r\n19. 内存&amp;储存介质\r\n存储器，如硬盘，具有非易失性。\r\n20. 文件系统\r\n数据的数据，叫“元数据”（meta\r\ndata），提供信息来正确读取数据，存在文件开头，在实际数据前面，因此也叫文件头（Header）。\r\n文件系统移动文件时，不用移动任何数据块，只需改两个目录文件，一个文件里删一条记录，另一个文件里加一条记录。\r\n21. 压缩\r\n游程编码（Run-Length\r\nEncoding），适合经常出现相同值的文件，压缩连续相同值。\r\nDFTBA，字典编码，紧凑代码，用霍夫曼树为出现频率高的数据分配长度短的代码（编号）。\r\n游程编码和字典编码实现了“无损压缩”，没有丢失任何数据。\r\n如果录音乐，超声波数据都可以扔掉。人对人声敏感，对低音不敏感，所以有损音频压缩利用这一点，用不同精度编码不同频段。这种删掉人类无法感知的数据的方法，叫“感知编码”（perceptual\r\ncoding）。\r\n27. 3D 图形\r\n3D 投影，把 3D 坐标“拍平”显示到 2D 屏幕上。3D 转 2D 后用画 2D\r\n线段的函数来连接点，这叫“线框渲染”。\r\n填充图形的经典算法叫扫描线渲染。\r\n抗锯齿，如果像素在多边形内部，就直接涂颜色，如果多边形划过像素，颜色就浅一些。\r\n实现遮挡，排序后从远到近渲染，这叫画家算法。还有一种方法叫深度缓冲，不用排序，对每个像素取距离的最小值，从而得到最前面的多边形。但距离相同时无法处理，不可预测哪个画在上面，导致出现\r\nZ-fighting 效果。\r\n背面剔除，忽略多边形背面。\r\n明暗处理，多边形面对的方向叫“表面法线”，根据方向来进行平面着色。还有更多算法，如高落德着色和冯氏着色。\r\n纹理映射，查询纹理，从相应区域取平均颜色，并填充多边形。\r\nGPU，图形处理单元，在显卡上，周围有专用的 RAM。\r\n28. 计算机网络\r\n计算机近距离构成的小型网络，叫局域网，简称 LAN。\r\n为了知道数据传递方向，以太网需要每台计算机有唯一的媒体访问控制地址，简称\r\nMAC 地址。\r\n多台电脑共享一个传输媒介，这种方法叫“载波侦听多路访问”，简称“CSMA”。很多计算机同时侦听载体，所以叫“侦听”和“多路访问”。载体传输数据的速度叫“带宽”。\r\n指数退避，发生冲突后等 1 秒。若仍冲突，等 2 秒。若仍冲突，等 4\r\n秒……\r\n我们需要减少同一载体中设备的数量，载体和其中的设备总称“冲突域”。为了减少冲突，可以用交换机将一个冲突域拆成两个冲突域。\r\n大型网络中，从一个地点到另一个地点通常有多条路线。消息沿着路由跳转的次数，叫“跳数”（hop\r\ncount）。\r\n29. 互联网\r\nWIFI\r\n路由器连着的所有设备，组成了局域网，局域网再连到广域网（WAN），WAN\r\n的路由器一般属于“互联网服务提供商”，简称 ISP。\r\n传输的数据会被拆成多个小数据包（packet）。数据包想在互联网上传输，要符合“互联网协议”的标准，简称\r\nIP。为解决数据包传给哪个程序，还需更多协议，其中最简单最常见的叫“用户数据报协议”，简称\r\nUDP。IP 负责把数据包送到正确的计算机，UDP\r\n负责把数据包送到正确的程序。\r\n如果“所有数据必须到达”，就用“传输控制协议”，简称 TCP。1. TCP\r\n数据包有序号。2. TCP\r\n要求接收方的电脑收到数据包并且“校验和”检查无误后（数据没有损坏），给发送方发一个确认码（ACK），代表收到了。\r\n当计算机访问一个网站时，需要 IP\r\n地址和端口号。域名系统（DNS）负责把域名和 IP 地址一一对应。\r\n30. 万维网\r\n为了使网页能相互连接，每个网页需要一个唯一的地址，这个地址叫“统一资源定位器”，简称\r\nURL。\r\n超文本传输协议（HTTP）。\r\n超文本标记语言（HTML）。\r\n网络中立性，应该平等对待所有数据包。\r\n31. 计算机安全\r\n计算机安全是保护系统和数据的保密性，完整性和可用性。\r\n“保密性”是只有有权限的人才能读取计算机系统和数据。“完整性”是只有有权限的人才能使用和修改系统和数据。“可用性”是有权限的人应该随时可以访问系统和数据。\r\n拒绝服务攻击（DDOS）就是黑客发大量的假请求到服务器，让网站很慢或者挂掉。这就是攻击“可用性”。\r\n为了保护这三方面，安全专家会从抽象层面想象“敌人”可能是谁，这叫“威胁模型分析”。\r\n隔离，计划当程序被攻破后，如何限制损害，控制损害的最大程度，并且不让它危害到计算机上其他东西。可以用“沙盒”程序实现隔离，给每个程序独有的内存块，其他程序不能动。\r\n32. 黑客&amp;攻击\r\n“社会工程学”，欺骗别人让人泄密信息。最常见的攻击是网络钓鱼。\r\n远程攻击一般需要攻击者利用系统漏洞来获得某些能力或访问权限，这叫“漏洞利用”。一种常见的漏洞利用叫“缓冲区溢出”。“缓冲区”是一种概称，指预留的一块内存空间。可以利用缓冲区溢出来修改内存。\r\n为了防止缓冲区溢出被利用，最简单的方法是复制之前先检查长度，防止内存被修改，这叫“边界检查”。程序也会随机存放变量在内存中的位置，导致黑客更容易让程序崩溃，而不是获得访问权限。\r\n程序也可以在缓冲区后，留一些不用的空间，然后跟踪里面的值，看是否发生变化。如果发生了变化，说明有攻击者在乱来，这些不用的内存空间叫“金丝雀”。\r\n代码注入，最常用于攻击用数据库的网站。用“结构化查询语言”（SQL），一种流行的数据库\r\nAPI。\r\n33. 加密\r\n把明文转成密文叫“加密”，把密文恢复回明文叫“解密”。\r\n密钥交换，是一种不发送密钥，但依然让两台计算机在密钥上达成共识的算法。“迪菲-赫尔曼密钥交换”（Diffie-Hellman），有公开的基数和模数，双方分别选一个指数\r\n，分别将  和  发给对方，共享密钥为 。双方用一样的密钥加密和解密消息，这叫“对称加密“。\r\n非对称加密，有两个不同的密钥，人们用公钥加密消息，只有有私钥的人能解密。知道公钥只能加密，但不能解密，这是”不对称“的。目前最流行的”非对称加密“技术是\r\nRSA。\r\n34. 机器学习&amp;人工智能\r\n机器学习算法让计算机可以从数据中学习，然后自行做出预测和决定。\r\n分类，区分两个事物，做分类的算法叫“分类器”。很多算法会减少复杂性，把数据简化成“特征”，“特征”是用来帮助“分类”的值。为了训练“分类器”做出好的预测，我们需要“训练数据”。\r\n把决策空间切成几个盒子的简单方法，可以用“决策树”来表示。\r\n人工神经网络，人造神经元可以接受多个输入，然后整合并发出一个信号，被放成一层层，形成神经元网络，因此得名神经网络。一个输入层，一个输出层和多个隐藏层，因此得名“深度学习”。\r\n“弱 AI”或“窄 AI”，只能做特定任务。真正通用的，像人一样聪明的\r\nAI，叫“强 AI”。\r\n学习什么管用，什么不管用，自己发现成功的策略，这叫“强化学习”。\r\n35. 计算机视觉\r\n卷积神经网络，用一堆神经元处理图像数据，每个都会输出一个新图像 。\r\n36. 自然语言处理\r\n人类语言叫“自然语言”。自然语言处理，简称 NLP。\r\n分析树，用规则来讲句子划分为块，同时标明了句子的结构。\r\n语音识别，如今准确度最高的语音识别系统，用深度神经网络。\r\n波形转换为谱图，用快速傅里叶变换（FFT）实现波形到频率的转换。构成单词的声音片段叫“音素”。\r\n语音合成，让计算机输出语音。把一段文字，分解成多个声音，然后播放这些声音。\r\n37. 机器人\r\n机器人是由计算机控制，可以自动执行一系列动作的机器。\r\n比例-积分-微分控制器，简称 PID\r\n控制器。比例值，实际值和理想值差多少。积分值，一段时间内误差的总和。导数值，期望值与实际值之间的变化率。三个值有不同权重，然后用来控制系统。\r\n","categories":["学习笔记"],"tags":["计算机基础知识"]},{"title":"ML for CO","url":"/2023/04/18/ML%20for%20CO/","content":"ML for CO 综述\r\nYoshua Bengio, Andrea Lodi, and Antoine Prouvost. \"Machine learning\r\nfor combinatorial optimization: A methodological tour d'horizon\",\r\nEuropean Journal of Operational Research 290.2 (2021):\r\n405-421.\r\n不失一般性的，CO\r\n问题可以被公式化为一个受约束的最小优化问题。如果目标和约束是线性的，则该问题称为线性规划（LP）问题。如果一些变量也被限制为只能为整数值，则问题被称为混合整数线性规划（MILP）问题。可用单纯形算法多项式复杂度求解\r\nLP 问题。\r\n分支限界（branch and\r\nbound），分支是使用广度优先策略，依次生成扩展结点的所有分支，限界是在结点扩展过程中，计算结点的上界，搜索的同时剪掉某些分支。分支限界法就是把问题的可行解展开，再由各个分支寻找最佳解。\r\n对于 MILP\r\n问题，分支限界算法为将问题松弛为实数变量后分解为小问题。\r\nEnd to end learning\r\n通过 ML，由 Problem defifinition 直接得到 Solution。ML\r\n适合在较短的计算时间内获得准确的解决方案，因为一些复杂性是在学习阶段离线解决的。\r\nLearning\r\nmeaningful properties of optimization problems\r\n通过 ML，为传统的运筹优化方法提供信息。\r\nMachine\r\nlearning alongside optimization algorithms\r\n构建 CO 算法，在整个执行过程中反复调用 ML\r\n模型。主算法控制高级结构，同时经常调用ML模型以协助较低级别决策。\r\n最大公共子图（MCS）\r\nCiaran McCreesh, Patrick Prosser, and James Trimble. \"A Partitioning\r\nAlgorithm for Maximum Common Subgraph Problems.\", International Joint\r\nConference on Artificial Intelligence (2017): 712-719.\r\nYanli Liu, Chumin Li, Hua Jiang, and Kun He. \"A Learning Based Branch\r\nAnd Bound For Maximum Common Subgraph Related Problems\", AAAI\r\nConference on Artificial Intelligence 34. (2020): 2392-2399.\r\nJianrong Zhou, Kun He, Jiongzhi Zheng, Chu-Min Li, and Yanli Liu. \"A\r\nStrengthened Branch and Bound Algorithm for the Maximum Common\r\n(Connected) Subgraph Problem\", European Conference on Artificial\r\nIntelligence (2022): 1908-1914.\r\nThe McSplit Algorithm\r\n搜索过程中的当前状态为点对的映射 ，同时将还未考虑的点打上一个与已考虑的点集连通性的\r\n，\r\n相同的点对才可加入映射，即选择处于同一标签类的点对。\r\n当前状态对应的答案上界为：  启发式：选择标签类时，选择  最小的标签类，从  中选点时，选度数最大的点。\r\nMcSplit+RL\r\n\r\n因为预计的上界越小，越可能剪枝，因此考虑将上界的减少量作为奖励。\r\n同时，若考虑上界的减少率，则又得到一种变体方法。\r\n考虑点对的匹配作为奖励。\r\n\r\nMcSplit+LL Algorithm\r\nLong-Short Memory (LSM)\r\n随着搜索的深入，当前状态会有很大的变化，均匀地累积分数会导致由大部分历史评估值引起的偏差。因此，需要一种能够消除历史评估的影响的机制。\r\n考虑短期阈值  （默认为 ）和长期阈值  （默认为 ）。若  大于 ，则所有  衰减到一半。若  大于 ，则所有  衰减到一半。\r\nLeaf vertex Union Match (LUM)\r\n叶节点定义为只跟一个点相邻的节点。一个点的叶子定义为与该点相邻的叶节点。\r\n定理：在进行  时，当一对点\r\n 匹配时，可以从 \r\n的不匹配的叶子中匹配尽可能多的点对，而不影响解的最优性。\r\n旅行商问题（TSP）\r\nLKH\r\n求解 TSP\r\n的启发式算法可分为三类：回路构造算法、回路改进算法和复合算法。复合算法通常使用回路改进算法对回路构造算法得到的初始解进行改进。LKH\r\n算法是一种利用 k-opt 来改进启发式构造的初始行程的复合算法。\r\nk-opt：替换当前解的 \r\n条边，得到一个更优的新解。\r\n\r\n1-tree 下界：从  中选出一个点\r\n，求出剩下点 \r\n的最小生成树，最小生成树的权值再加上 \r\n向最小生成树的不同两个点连出的最小权值的边的权值（一条边为进入最小生成树，一条边为离开最小生成树），即为\r\n1-tree 下界。1-tree 下界不一定是可行解。当 1-tree 中每个点度数都为  时为可行解，且为最优解。\r\n定义 ，其中  为 1-tree 的权值， 为必须包含边  的 1-tree 的权值。一条边的  值可以看做必须包含该边的最小\r\n1-tree 的额外权值。在 LKH 算法中，有更小的  值的边在搜索中有更高的优先级。\r\nHeld-Karp 下界：LKH 算法通过添加惩罚  来最大化最优 TSP\r\n解的下界，边权变为：。这个变化不改变\r\nTSP 的最优解，但改变了最小的 1-tree。最大化 ，即为\r\nHeld-Karp 下界。迭代为 ，其中\r\n 为点  在最小 1-tree 中的度数， 为迭代的参数， 为迭代的轮数。迭代即为让最小 1-tree\r\n中的点的度数都变为 。\r\nVSR-LKH\r\nJiongzhi Zheng, Kun He, Jianrong Zhou, Yan Jin, and Chu-min Li.\r\n\"Combining Reinforcement Learning With Lin-Kernighan-Helsgaun Algorithm\r\nFor The Traveling Salesman Problem\", AAAI Conference on Artificial\r\nIntelligence 35 (2021): 12445-12452.\r\nVSR-LKH 中，k-opt\r\n过程不再是遍历候选边集，而是通过强化学习来从候选边集选择添加的边。对于该强化学习，状态为当前需要加边的点，动作为加边，加边后状态转移为所加边的另一个端点，奖励为：\r\n 定义  的初始  为：  \r\n影响选择边的优先级。\r\nNeuroLKH\r\nLiang Xin, Wen Song, Zhiguang Cao, and Jie Zhang. \"NeuroLKH:\r\nCombining Deep Learning Model with Lin-Kernighan-Helsgaun Heuristic for\r\nSolving the Traveling Salesman Problem.\", Conference on Neural\r\nInformation Processing Systems (2021): 7472-7483.\r\nLKH 中迭代 \r\n后能提升候选边集的质量，但仍有局限性，因此提出了 NeuroLKH\r\n来构建候选边集。\r\n首先将原图转化为稀疏有向图 ，每个点所连的边只保留最短的\r\n 条，这 \r\n条看作是该点连出的有向边。实验中取了 。\r\n用稀疏图网络来预测边的权值  和点的惩罚 。\r\n不是边权，其权值越大，搜索中越优先选择这条边， 即为上面改变边权的惩罚。\r\n\r\n先将边和点的信息转化为特征向量，维度为 ，用  层稀疏图卷积层来预测，实验中取  和 ，卷积层定义为：   和 \r\n分别是按元素乘法和按元素除法，\r\n是层数， 和  都是训练的参数。\r\n 经过两层线性层后再由\r\n 激活得到 。同样的， 经过两层线性层后再由  激活得到 。然后再计算  和 ：   是训练的参数，，使得  范围为 。\r\n边的权值 \r\n通过监督学习训练，点的惩罚 \r\n通过无监督学习训练。损失函数分别为： 𝟙𝟙 ，即为若一条边在最优解中，则增大其权值 。\r\n 为点  在最小 1-tree 中的度数，\r\n为平衡两个损失函数的系数。实验中取 。\r\n对于大规模的数据，边的权值  可以很好地泛化，但点的惩罚\r\n 不能直接泛化。因为  是通过无监督学习训练的。因此，对于\r\n 进行微调，进行  次迭代，批处理大小为 。\r\n图匹配\r\nJunchi Yan, Shuang Yang, and Edwin R. Hancock. \"Learning for Graph\r\nMatching and Related Combinatorial Optimization Problems.\",\r\nInternational Joint Conference on Artificial Intelligence 5\r\n(2020): 4988-4996.\r\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"个性化联邦学习","url":"/2023/11/27/%E4%B8%AA%E6%80%A7%E5%8C%96%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/","content":"Tnnls 2022\r\nTowards Personalized Federated Learning\r\nPFL 为了解决一般的 FL 中的问题：\r\n在异质性强的数据上收敛慢。\r\n模型对于本地缺乏个性化。\r\n\r\n本文将 PFL 分为两类：Global Model Personalization 和 Learning\r\nPersonalized Models。\r\nGlobal Model Personalization：先训练一个全局的 FL\r\n模型，然后在本地数据集上进行额外的训练来达到个性化。\r\nLearning Personalized Models：在训练阶段就加入个性化。\r\n\r\n标准的 FL：   是客户端个数，\r\n编码了全局模型的参数，\r\n表示客户  在数据分布  上的期望损失。\r\n本地学习：  即为每个客户端在本地自己训练。\r\n为了在泛化和个性化性能之间取得平衡，PFL 介于标准 FL\r\n和本地学习之间。\r\nGlobal Model Personalization\r\nData-based Approaches\r\n\r\n为了减少异质性。\r\nData Augmentation\r\n数据共享策略：将一小部分全局数据按类别平衡分布到每个客户端。实验显示，添加少量数据有可能获得显著的准确性提升（约30%）。\r\nFAug：一种联邦增强方法，在 FL\r\n服务器中训练一个生成对抗网络（GAN）模型。一些数据样本被上传到服务器来训练\r\nGAN 模型。然后，训练好的 GAN\r\n模型被分发到每个客户端，以生成额外的数据来增强其本地数据，从而产生一个\r\nIID 数据集。\r\nAstraea：一个自平衡的 FL 框架，用于通过使用基于 Z-score\r\n的数据增强和本地数据的下采样来处理类别不平衡。FL\r\n服务器需要关于客户端本地数据分布的统计信息（例如，类别大小，均值和标准差值）。\r\nFedHome：该算法使用 FL\r\n训练一个生成卷积自编码器（GCAE）模型。在FL过程结束后，每个客户端在一个本地增强的类平衡数据集上进行进一步的个性化。这个数据集是通过在基于本地数据的编码网络的低维特征上执行\r\nSMOTE 算法来生成的。\r\nClient Selection\r\n选择更同质的数据分布的客户端，来提升全局模型的泛化能力。\r\nFAVOR：在每个训练轮次中选择一部分参与的客户端，以减轻由 non-IID\r\n数据引入的偏差。设计了一种基于深度 Q-learning\r\n的客户端选择公式，目标是在最小化通信轮次的同时，最大化准确性。\r\n多臂老虎机公式：一种基于多臂老虎机公式的客户端选择算法，以选择类别不平衡最小的客户端子集。通过比较提交给\r\nFL\r\n服务器的本地梯度更新与从服务器上的平衡代理数据集推断出的梯度的相似性，来估计本地类别分布。\r\nTiFL：一个基于层级的FL系统（TiFL），该系统根据训练性能将客户端分组到层中。该算法通过优化准确性和训练时间，自适应地从同一层中选择参与每个训练轮次的客户端。这有助于缓解由数据和资源异质性引起的性能问题。\r\nFedSAE：一个自适应的 FL\r\n系统，它在每个训练轮次中自适应地选择本地训练损失较大的客户端，以加速全局模型的收敛。还提出了一个预测每个客户端可承受工作负载的机制，以便动态调整每个客户端的本地训练周期数，从而提高设备的可靠性。\r\nModel-based Approaches\r\n\r\nRegularized Local Loss\r\n用正则化来限制本地更新的影响，提高全局模型的收敛稳定性和泛化性。\r\n FedProx：引入了一个接近项到本地子问题，该接近项考虑了全局 FL\r\n模型和本地模型之间的不相似性，以调整本地更新的影响。\r\nFedCL：进一步考虑了参数重要性，在使用连续学习领域的弹性权重固化（EWC）的正则化本地损失函数中。\r\nSCAFFOLD：使用方差减少来减轻客户端漂移的影响，该漂移导致本地和全局模型之间的权重发散。\r\nMOON：一种基于对比学习的 FL - MOON。MOON\r\n的目标是减小本地模型和全局模型之间学习到的表示之间的距离（即减轻权重发散），并增加给定本地模型和其先前本地模型之间学习到的表示之间的距离（即加速收敛）。\r\nMeta-learning\r\n元学习算法分两个阶段：元训练和元测试。将 FL\r\n的训练阶段视作为元学习的训练阶段，将 FL\r\n模型个性化阶段视作为元学习的测试阶段，可以很自然的将元学习模型迁移到个性化联邦学习中。\r\nPer-FedAvg：  元函数 。\r\nTransfer Learning\r\nFedMD：一个基于 TL 和知识蒸馏的 FL\r\n框架，供客户使用自己的私有数据设计独立模型。在 FL\r\n训练和知识提炼阶段之前，首先使用在公共数据集上预训练的模型进行\r\nTL。然后，每个客户端都会根据其私有数据对该模型进行微调。\r\nLearning Personalized Models\r\n\r\nArchitecture-based\r\nApproaches\r\nParameter Decoupling\r\n私有参数在客户端上进行本地训练，并且不与联邦学习服务器共享。这使得可以学习到针对特定任务的个性化表示，从而增强个性化定制能力。\r\n基础层+个性化层：为每个客户端设置个性化层，个性化层只在本地训练，而其余的层参数需要上传至云端。\r\nKnowledge Distillation\r\n通过知识蒸馏进行信息传递，客户端之间的模型结构可以不一致。\r\nSimilarity-based Approaches\r\n基于相似性的方法旨在通过建模客户关系来实现个性化。为每个客户学习一个个性化模型，并使相关的客户学习相似的模型。\r\nMulti-task Learning (MTL)\r\nMTL\r\n的目标是训练一个能够同时执行多个相关任务的模型。将联邦学习的每个客户端视为\r\nMTL 中的一个任务。\r\nModel Interpolation\r\n一种使用全局和局部模型的混合来学习个性化模型的新方法，用来平衡泛化与个性化。每个\r\nFL 客户端都会学习一个单独的本地模型。惩罚参数 \r\n用于阻止局部模型与平均模型相差太大。当 \r\n设置为零时，则为纯局部模型学习。当 \r\n趋近无穷大时，所有局部模型相同，相当于全局模型学习。\r\nClustering\r\n将客户端之间聚类，并且对每一个类训练一个模型。\r\n","categories":["学习笔记"],"tags":["论文","人工智能","联邦学习","个性化联邦学习"]},{"title":"吴恩达机器学习","url":"/2022/10/23/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"课程\r\n1 Supervised Machine Learning: Regression and Classification\r\nWeek 1: Introduction to\r\nMachine Learning\r\n监督学习\r\n监督学习是输入  到输出标签\r\n\r\n映射的算法。算法从事先给的“正确答案”中学习。\r\n第一种监督学习算法，回归，从无限多个可能的数中预测出一个数。如预测房价。\r\n第二种监督学习算法，分类，预测类别在一个小的、有限的输出类别集合。如判断猫狗。\r\n无监督学习\r\n在数据集中找到一些结构或者模式。不事先给“正确答案”。\r\n聚类算法，一种无监督学习算法，将未标记的数据放在不同的簇中。\r\n其他的无监督学习算法：异常检测，降维。\r\n线性回归\r\n方差代价函数： \r\n梯度下降\r\n\r\n这里的  是赋值。\r\n为学习率，取值应适当，不能太小太大。因为在梯度下降的过程中，导数会自动变小，所以更新的步幅也会自动变小。\r\n\r\n批量梯度下降指的是每一步梯度下降，都会考虑到所有的训练样本。\r\nWeek 2:\r\nRegression with multiple input variables\r\n多元线性回归\r\n\r\n特征缩放\r\n为了让特征  的取值范围接近\r\n。\r\nWeek 3: Classification\r\n逻辑回归\r\n一种分类模型。\r\nsigmoid function：  逻辑回归模型：  决策边界：  损失函数：  代价函数： \r\n过拟合\r\n高偏差的模型，欠拟合。高方差的模型，过拟合。\r\n解决过拟合的方法：1.收集更多的数据。2.选择并使用特征子集。3.利用正则化减小参数的大小。\r\n正则化\r\n线性回归的正则化：  逻辑回归的正则化： \r\n课程 2 Advanced Learning\r\nAlgorithms\r\nWeek 1: Neural Networks\r\n神经网络\r\n输入层，输出层，隐藏层。神经网络结构的问题就是，要有多少个隐藏层，每个隐藏层要有多少个神经元。\r\n对于神经网络的第  层的第  个神经元：  其中 \r\n为激活函数。这个过程称为前向传播。\r\nWeek 2: Neural network\r\ntraining\r\n激活函数\r\nLinear activation function：\r\nSigmoid：\r\nReLU：\r\n对于输出层：\r\n二分类问题，使用 Sigmoid。\r\n 可正可负，使用 Linear\r\nactivation function。\r\n 非负，使用 ReLU。\r\n对于隐藏层，使用 ReLU。\r\n多分类\r\n多分类问题，如数字识别，结果为 \r\n到 。\r\nSoftmax 回归算法是逻辑回归的推广，用来解决多分类问题。\r\n 可以取  个值： \r\n 时即为逻辑回归。\r\n损失函数： \r\n多标签分类\r\n多标签分类，如判断图片上有无汽车，公交车，行人。\r\nAdam 算法\r\n自动调整学习率，过小时增大，过大时减小。\r\nWeek 3: Advice for\r\napplying machine learning\r\n模型评估\r\n解决方案：\r\n高偏差：增加特征，增加多项式特征（如 ），减小 。\r\n高方差：更多训练样本，减少特征，增大 。\r\nWeek 4: Decision trees\r\n决策树\r\n熵，对一组数据不纯度的衡量。 \r\n信息增益：  其中，\r\n为左子树中带有正标签的样本的比例，\r\n为根节点到左边子分支的样本的比例。\r\n停止条件：\r\n一个节点所有数据标签相同。\r\n树的深度大于某一阈值。\r\n最大信息增益小于某一阈值。\r\n一个节点数据数小于某一阈值。\r\nOne-hot 编码\r\n对多分类问题的决策树应用 One-hot\r\n编码，即可转化为二分类问题。如耳朵为椭圆，尖角，耷拉转化为耳朵是否椭圆等。\r\n连续值\r\n若特征为连续值，则取阈值 ，阈值通常为 ，这里  有序。将特征转化为 ，变为 。\r\n回归树\r\n和决策树类似，不再预测分类，而是输出一个 。\r\n信息增益：   为方差函数。\r\n集成树\r\n使用集成树后，不用担心整体算法会对任何一棵树的预测过于敏感。\r\n通过有放回抽样，得到和原数据集大小相等的新数据集，用新数据集来构建集成树。\r\n随机森林算法\r\n对每个节点，当要选特征来分裂时，若有  个特征可选，则随机选  个特征来考虑。通常取 。\r\nboosting\r\n指再构建一棵新树时，优先选取在当前决策树森林中被错误分类的样本。\r\n课程\r\n2 Unsupervised Learning, Recommenders, Reinforcement Learning\r\nWeek 1: Unsupervised learning\r\n聚类\r\nK-means\r\n第一步是将点分配给簇质心（簇的中心），第二步是移动簇质心。\r\n代价函数（distortion 函数）：   为第  个簇质心， 表示第  个点 \r\n当前对应的簇（最近的簇质心）。\r\n第一步是固定 ，通过调整  来让  最小，第一步是固定 ，通过调整  来让 \r\n最小。在每一次迭代中，代价函数下降或不变。\r\n一开始随机选样本点来作为簇质心。\r\n异常检测\r\n通过观察正常事件的未标记数据集，从而学会检测异常或在异常事件发生时发出危险信号。\r\n密度估计\r\n对于  个样本，每个样本有  个特征：  等式右边的 \r\n为高斯（正态）分布。若 ，则认为异常。\r\nWeek 2: Recommender systems\r\n协同过滤\r\n代价函数：   表示用户  有给商品  评分， 为对应的评分， 为用户  评分商品的数量， 为有  个特征的向量。\r\n 是常量，可以去掉：  用来学习  的代价函数：\r\n 用来学习  的代价函数：\r\n 合并到一起：  用梯度下降来迭代。\r\n对于二元分类，类似逻辑回归处理即可。\r\n基于内容过滤\r\n用深度学习实现。\r\n代价函数： \r\nWeek 3: Reinforcement\r\nlearning\r\n强化学习有若干概念，状态，行动，奖励，折扣因子，回报，策略，马尔可夫决策过程。\r\n状态动作价值函数，\r\n表示在状态  时，采取行动  后行动最优所得到的回报。\r\n贝尔曼方程：  其中  表示状态  的奖励， 是状态  采取行动 \r\n后转移到的状态。感觉就是动态规划转移方程。\r\n实际情况中，状态不一定能顺利转移，因此考虑的回报是期望回报： \r\n","categories":["学习笔记"],"tags":["人工智能","机器学习"]},{"title":"强化学习","url":"/2023/04/28/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"基本概念\r\n\r\nPolicy function: \r\nPolicy function 是一个概率密度函数。\r\n\r\nenvironment 的随机性：\r\nTwo Sources of Randomness:\r\naction: \r\nstate: \r\nReturn: \r\nDiscounted return: \r\ndiscount factor: \r\n（超参数）\r\n\r\n价值学习\r\nAction-value function: \r\nOptimal action-value function: \r\nbest action: \r\n用神经网络来近似 。\r\nTemporal Difference (TD) Learning\r\n\r\n用  来近似\r\n。 是神经网络的参数。\r\n\r\nTD target: \r\nLoss: \r\nGradient descent: \r\n策略学习\r\nState-value function:\r\n\r\n（离散）\r\n （连续）\r\n用 \r\n来评估 policy 。\r\n用策略网络 \r\n来近似 ， 为需要训练的参数。同时，。\r\n学习  来最大化 。\r\n更新策略：\r\n策略梯度：\r\n形式一：\r\n形式二：\r\n设 ，得 。这里用蒙特卡洛近似来计算期望：随机抽样\r\n\r\n来计算 ，从而进行更新，。\r\nActor-Critic Methods\r\n\r\nPolicy network (actor): \r\nValue network (critic): \r\n\r\n更新  来增大\r\n，监督基于\r\nvalue network (critic)。\r\n更新 \r\n来更好的估计回报 return。\r\n蒙特卡洛\r\n随机抽样，可以用来求 ，求定积分，求期望。\r\nSarsa 算法\r\n\r\n直接求不了期望，所以用蒙特卡洛近似，用观测值  来近似，近似值  即为 TD\r\ntarget 。\r\n用价值神经网络 \r\n来近似 ：\r\nTD target: \r\nTD error: \r\nLoss: \r\nGradient: \r\nGradient descent: \r\nQ-Learning 算法\r\nQ-learing 用来训练最优动作价值函数 。  然后用蒙特卡洛近似：\r\nTD target: \r\n通过 DQN  来近似\r\n：\r\nTD target: \r\nTD error: \r\nUpdate: \r\nMulti-Step TD Target\r\n考虑多个奖励：  对于 Sarsa：  对于 Q-learning： \r\nPolicy Gradient with\r\nBaseline\r\n如果  和  独立，则有：  policy gradient 可改写 为： \r\n","categories":["学习笔记"],"tags":["人工智能","强化学习"]},{"title":"图神经网络","url":"/2023/08/12/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"Thomas N. Kipf, and Max Welling. \"Semi-Supervised Classification with\r\nGraph Convolutional Networks.\", International Conference on Learning\r\nRepresentations abs/1609.02907. (2017)\r\n 其中 \r\n为加上自环的邻接矩阵，\r\n为其对应的度矩阵，\r\n为激活函数。这里分别左乘和右乘上  其中 。\r\nSpatial-based Convolution\r\nNN4G（Neural Networks for\r\nGraph）\r\n\r\nDCNN（Diffusion-Convolution\r\nNeural Network）\r\n$$\r\n\r\n$$\r\n其中  表示所有和\r\n 距离为  的点。\r\nDGC（Diffusion Graph\r\nConvolution）\r\n跟上一个一样，只是最后不是 ，而是全部相加： \r\nMoNET（Mixture Model\r\nNetworks）\r\n\r\nGraphSAGE\r\naggregation: mean, max-pooling, or LSTM\r\nGAT（Graph Attention\r\nNetworks）\r\n\r\nGIN（Graph Isomorphism\r\nNetwork）\r\n\r\nSpectral-based Convolution\r\nChebNet\r\n","categories":["学习笔记"],"tags":["论文","人工智能","图神经网络"]},{"title":"日记 2023.5","url":"/2023/05/05/%E6%97%A5%E8%AE%B0%202023.5/","content":"5.1\r\n健身，吃秀玉。\r\n看马里奥大电影，碧姬公主很帅！！蓝龟壳，马里奥赛车，“猫对抗强”，“人拿到无敌星就会本能的冲”，要素挺多。想起自己高二高三天天看超级小桀的马造视频，感觉自己还是懂点马里奥的。\r\n5.2\r\n健身，和 wyk 吃九轮，体验挺好。\r\n5.4\r\n第一次做义工，益路华中大，把非机动车赶到非机动车道上。好几个同学一开始没明白我向非机动车道挥旗子的意思，骑过去后才明白，然后哈哈笑，感觉挺有意思。同学们也都很配合，“OK”，微笑，竖大拇指。\r\nyz 把照片盒出来了，🦐。\r\n5.5\r\n😥 这段时间我好摆啊，效率好低，得多注意了。\r\n5.6\r\n😰\r\n依旧摆，早上九点四十起，直接睡过微积分，下午又睡一下午，晚上多学会儿吧。\r\n5.7\r\n中午班级东湖烧烤团建，感觉办的挺成功的。烧烤吃的挺开心，桌游也有两三桌，希望大家吃的烤串都是熟的\r\n🙏，也别太熟成黑炭。\r\n蛋白粉到了，我要大我要大我要大 🤤。喝起来没啥味儿，饱腹感挺强。\r\n晚上去看银河护卫队\r\n3，好看！每个角色最后都有自己的归途。火箭的故事很饱满，至高进化和他创造的反地球的设定都挺有意思。反地球——福瑞控天堂。\r\n5.8\r\n下午完成了公选课作业，采访了大萝卜。萝卜比我们预期的能说，问一个问题，直接把我们接下来要问的问题也给回答了。最后又他谈到了卷，“不是逼着你们卷，但大一还是要努努力，不要丢了那股劲儿，不然以后找都找不回来”。\r\n5.9\r\n上午找 hk\r\n面谈，约了好几次，终于约上了。给她讲了讲我这段时间看的论文，说了四十分钟。我一直以为之后是找个学长带我，但今天交流完，我才知道老师对我的期望是主要我自己来做，老师和学长提供帮助。这下直接幻想时间了\r\n🤤，不过工作量也挺多，本来以为这次谈完后，到暑假前这边就没啥事了，这下直接事儿更多了\r\n😨。\r\n5.11\r\n去“梦系红楼”音乐会当志愿者，那句“天尽头，何处有香丘”很震撼，最后我们志愿者还跟吴碧霞老师一起合照了。\r\n5.12\r\n这次时机比较巧。\r\n5.15\r\n听了安全教育报告，感觉国内管理 AIGC 确实很难，希望逐步完善吧。\r\n5.18\r\n盖亚过生日，吃了东北乱炖，好吃 😋。\r\n逼宫大成功。\r\n😭 但我大失败。\r\n5.19\r\n去看室友唱歌，集成十大歌手。冠军唱的李健的歌，巨牛。\r\n😥 然后又失败。\r\n5.22\r\n事儿好多，hk 那边也开始催组会了。是真没 idea 啊，各种意义上。\r\n感觉太内耗了，还是弃了吧 😞。\r\n5.23\r\n语文结课了，写小作文，“我的阅读小史”，上学期还是读了挺多小说的，有东西写。\r\n5.24\r\n考英语口语，我们组最后一个，全班都走了我们才上 😭。\r\n5.25\r\n考离散，感觉复习时间多了，没必要战线拉这么长，考的还是偏简单的，虽然分应该不怎么高吧\r\n😕。\r\n5.26\r\n根儿过生日。然后晚上给高中他们讲课，七点到十点半，讲了三个半小时。没想到讲这么长时间，并且还是线上，但同学们还是挺积极的。\r\n5.28\r\n去吃赤牧，体验挺好。第一次坐轮渡，吹风挺舒服，然后去江滩，继续吹风。\r\n🤤🤤\r\n5.30\r\n认识了\r\n🌋，早上简单聊了聊，下午一起自习，她挺有意思的，也很有自己的想法，并且社交属性很强。她加入了冰岩，猛猛学前端，想搞\r\nHCI，比口口大部分只懂卷加权的人强。BBHust\r\n里全是她的帖子，什么个人博客。\r\n","categories":["生活"],"tags":["日记"]},{"title":"指针网络","url":"/2023/09/03/%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C/","content":"Pointer Networks\r\nOriol Vinyals, Meire Fortunato, and Navdeep Jaitly. \"Pointer\r\nNetworks.\", Conference on Neural Information Processing Systems\r\nabs/1506.03134. (2015): 2692-2700.\r\n\r\n的输出类别是固定的，比如对于 \r\n问题，每次的输出是从固定大的词汇表中输出一个单词。但对于组合优化问题，比如\r\n，对于不同规模大小的问题，其点数\r\n 不同，输出不是固定的。\r\n就是为了解决这种输出不固定的问题。\r\nSequence-to-Sequence Model\r\n问题描述：比如对于 ：\r\n 输入是 \r\n个点，输出是一个长为  的排列。\r\n\r\n模型对于训练数据 ，拟合条件概率：  其中  为参数。\r\nContent Based Input\r\nAttention\r\n 和  都是 。 和  的隐藏状态分别定义为  和 。 模型第  次输出为 ，注意力机制额外求出注意力向量 ，将二者连接后，\r\n作为隐藏状态来实现预测。 表示\r\n 和  的距离。 \r\nPtr-Net\r\n  用 \r\n作为指向输入元素的指针。将输入作为查找的词典，而不是用事先固定的词典。\r\nCombinatorial\r\nOptimization by Graph Pointer Networks and Hierarchical Reinforcement\r\nLearning\r\nMa Qiang, Ge Suwen, He Danyang, Thaker Darshan, and Drori Iddo.\r\n\"Combinatorial Optimization by Graph Pointer Networks and Hierarchical\r\nReinforcement Learning\", arXiv preprint arXiv 1911.04936\r\n(2019)\r\n 即为找到一个最佳排列\r\n，使得路径长度最小： \r\nReinforcement Learning for\r\nTSP\r\n奖励的期望为：  \r\n是城市集合的空间， 是  上所有可能排列  的空间。 是 \r\n上的分布，由神经网络预测。用策略梯度算法最大化奖励函数来训练。\r\nHierarchical RL for TSP\r\n第 \r\n层中，动作  由策略  采样得到。\r\n是前一层提供的潜在变量，该层为下一层提供潜在变量 ，即为 。\r\n\r\nHierarchical Policy Gradient\r\n第  层的目标函数为 。由\r\n\r\n算法得，其策略梯度为：  其中  为批量大小， 为第  层的 。用梯度下降来更新参数\r\n。动作  是用贪心采样得到。\r\n对于这个  层的分层策略 ，每个策略用一个\r\n 表示。\r\nGPN Architecture\r\nEncoder\r\n包含两部分，\r\n和 。\r\n 将节点\r\n 映射到  维向量 ，并且所有节点共享映射变换的参数，然后通过  进一步编码得到隐藏变量 ， 会传递给  和下一时刻的 。\r\n 对 \r\n进行编码后输入到 \r\n里。\r\n\r\nGraph Embedding Layer\r\n 的每一层为：  \r\n是一个可训练的参数，用来正则化权重矩阵的特征值， 是可训练的权重矩阵，\r\n是聚合函数，用神经网络来拟合。\r\n\r\n考虑的是完全图，将每一层写成矩阵的形式为：  具体实验中使用的聚合函数是单层的全连接神经网络，图嵌入层即为：\r\n Vector Context\r\n一般的 \r\n都是用城市的二维坐标，即 ，但这篇文章用的是一个城市指向其他城市的向量，称为\r\n。\r\n设 ， 为 。图嵌入层就改为：\r\n Decoder\r\n 生成指针向量\r\n，定义为：  其中  和  是可训练矩阵， 为  的隐藏变量 ， 为  中的 ，即 。根据策略 \r\n来抽样或者贪心来得到动作 。\r\nExperiments\r\n小规模的问题：\r\n\r\n大规模的问题：\r\n\r\nPointerformer:\r\nDeep Reinforced Multi-Pointer Transformer for the Traveling Salesman\r\nProblem\r\nYan Jin, Yuandong Ding, Xuanhao Pan, Kun He, Li Zhao, Tao Qin, Lei\r\nSong, and Jiang Bian. \"Pointerformer: Deep Reinforced Multi-Pointer\r\nTransformer for the Traveling Salesman Problem\", CoRR abs/2304.09407\r\n(2023): 8132-8140.\r\n目标为最大化奖励：  根据策略梯度定理得： \r\nReversible residual\r\nnetwork based encoder\r\n采取特征增强，将每个节点从 \r\n表示改为 ，其中 。同时翻转和旋转整张图，得到原图的\r\n\r\n个等效的图，得到的每个图节点的特征也作为节点的特征。这样每个节点就有\r\n\r\n个特征来作为初始嵌入层的输入了。\r\n\r\n使用可逆残差网络，不同于剩余网络，其不需要存储所有剩余层的激活值来计算反向传播中的梯度。\r\n\r\n因为可以从输出嵌入 \r\n可以直接计算出输入嵌入 ，所以不需要存储所有激活值。\r\n\r\nMulti-pointer network based\r\ndecoder\r\nEnhanced Context Embedding  \r\n是第一个节点的嵌入。\r\n是当前最后一个节点的嵌入。\r\n是对整张图的嵌入，， 是第\r\n 个节点嵌入。 是当前已考虑节点的嵌入，。\r\n\r\n被用作查询 ，，\r\nA Multi-pointer Network\r\n在每一步中， 用于和和所有要访问的节点交互，来得到它们的概率分布。\r\n 其中 \r\n是当前得到的部分路径中的最后一个节点。这里减去 \r\n能鼓励每次选择最近的节点来作为下一个访问的节点。 是平衡探索和利用的一个参数。最后用\r\n 来计算概率。\r\nA modified REINFORCE\r\nalgorithm\r\n用 \r\n算法来训练模型。\r\n对于一个  个节点的  实例 ，将每个点都作为起始点来得到  条可行路径 ，然后对这 \r\n条路径进行蒙特卡洛采样。\r\n对于一个包含  个  实例的批次，可以得到 \r\n个路径。训练前进行归一化处理，这样能提高收敛速度和保证稳定训练。 \r\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"日记 2023.6","url":"/2023/06/02/%E6%97%A5%E8%AE%B0%202023.6/","content":"6.1\r\n图书馆楼下有六一活动，给小朋友写回信，小学生的想法很有趣，很童真。\r\n😰 图书馆电梯里碰见了 ______，还好人家没认出来我，不然有点尴尬。\r\n新馆四楼看见本书，《没有男朋友又怎样》——山内麻里子，感觉挺有意思。\r\n6.2\r\n网格员制度有点逆天。\r\n6.3\r\n看天空之城，然后……\r\n🥺 呜呜呜，我没了。\r\n😰 一点半到快四点。\r\n问是 ________，还是 ___，得到的答案是“不知道”，但我也不知道啊。\r\n6.4\r\n我以为很稳的。\r\n6.5\r\n我超，🕷 蜘蛛侠真好看，未完待续真 **，导致了一些鬼叫。\r\n6.6\r\n去讲了数据结构，感觉挺成功，但来的人比我预期的少。然后和大伙去吃川菜，很正宗，老板都是四川人，但确实辣\r\n🥵。\r\n在一起了。\r\n6.7\r\n粉裙子有点像小羽毛球，有点嘉然孕妇装的感觉。\r\n6.9\r\n逆天 lhw，“哈喽嫂子😁”。\r\n6.10\r\n晚上告诉 yz\r\n他们了，说去吃夜宵，逛了半天，发现海底捞人巨多，最后一人一笼小笼包。\r\n6.11\r\n考完近代史了，她也考完细生了，出去玩，官宣了。\r\n6.14\r\n碰见了 dcn 拔草。帮 xjr 上课，她睡大觉。她睡一下午，完全失联，“😭 xjr\r\n别似啊”。\r\n我们俩碰见了 zhy，她直接“嫂子好！”。\r\n6.16\r\n逆天啊，保研群聊了一下午我，真字面意思。一帮人匿名讨论“刘队”。\r\n6.17\r\n萝卜说了说下一届的图论班，还说加权没有 ％ 的同学不让进萝卜班 😨。\r\n6.18\r\n😋 xjr 怒骂 yz，来点攻击性震撼。\r\n巨大雨，我在紫菘渡江，水没到膝盖 😰。耳机盒不见了 😢。\r\n6.19\r\n考微积分，感觉还好。耳机盒找到了 😋。\r\n6.21\r\n大物考的血崩，希望成绩不要 \r\n开头 😭。\r\n6.22\r\n去蹭光电请李开丁老师讲的概率论，他讲的确实好 👍。\r\n6.24\r\n😭 我晚上备考第二天的概率论，她晚上去 club 看表演。\r\n6.25\r\n教 xjr 骑 🚲，学挺好！\r\n6.26\r\n搬寝室第一波，在韵苑各个寝室来回跑，逛了个遍。\r\n出去玩，看了消失的她，我们俩一致认为后半段很怪，她严厉批评了彩蛋。\r\n6.27\r\n吃一绪，爽喝旺仔牛奶！\r\n6.28\r\n搬寝室第二波，回来吧紫菘十栋 😭。\r\n6.29\r\n去了猫咖 🐱，猫猫可爱捏。\r\n6.30\r\n收到了如如的染卡和手写信 🥰。\r\n","categories":["生活"],"tags":["日记"]},{"title":"日记 2023.7","url":"/2023/07/12/%E6%97%A5%E8%AE%B0%202023.7/","content":"7.1\r\n去逛了湖北省美术馆，感受了艺术，但小孩儿好多啊，我们俩逛的都挺累。\r\n7.4\r\n给如如送了碎冰蓝 🌹。\r\n7.5\r\n送她去火车站。整理了一下她给我的零食，发现有好多啊。\r\n结果后来发现零食要么是临期的，要么是过期的，我还吃了一些过期的零食\r\n😰。\r\n7.11\r\n和 jdk 去打舞萌碰见了 lg。\r\n爽跑三公里。\r\n7.13\r\n爽跑五公里。\r\n","categories":["生活"],"tags":["日记"]},{"title":"李宏毅机器学习","url":"/2023/07/14/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"Self-Attention\r\n\r\nMulti-head Self-attention\r\n\r\nTransformer\r\nEncoder\r\n\r\nDecoder\r\n\r\n\r\nEncoder-Decoder\r\n\r\nLSTM\r\n\r\n\r\n","categories":["学习笔记"],"tags":["人工智能","机器学习"]},{"title":"第 29 次 CCF 计算机软件能力认证","url":"/2023/03/30/%E7%AC%AC%2029%20%E6%AC%A1%20CCF%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/","content":"T1 100:\r\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,x,y,ans;int main(){    read(n),read(x),read(y);    for(int i=1;i&lt;=n;++i)    {        ll a,b,c,d;        read(a),read(b),read(c),read(d);        a=max(a,(ll)0);        b=max(b,(ll)0);        c=max(c,(ll)0);        d=max(d,(ll)0);        a=min(a,x);        c=min(c,x);        b=min(b,y);        d=min(d,y);        ans+=(c-a)*(d-b);    }    cout&lt;&lt;ans;    return 0;}\r\nT2 100:\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,k,ans,l,r;ll t[maxn],c[maxn];bool check(ll x){\tll res=m;    for(int i=1;i&lt;=n;++i)    {        ll v=t[i]-x;        if(v&lt;=0) continue;        res-=v*c[i];        if(res&lt;0) return false;    }    return true;}int main(){    read(n),read(m),read(k),l=k;    for(int i=1;i&lt;=n;++i) read(t[i]),read(c[i]),r=max(r,t[i]);    while(l&lt;=r)    {        ll mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,r=mid-1;        else l=mid+1;    }    cout&lt;&lt;ans;    return 0;}\r\nT3 100:\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2510using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,q;int dn[maxn];char s[maxn];unordered_map&lt;int,int&gt; mp[maxn];bitset&lt;maxn&gt; f(int l,int r){    if(s[l]=='&amp;'||s[l]=='|')    {        int l1,r1,l2,r2;        l1=l+1,r1=l1;        int num=0;        while(r1&lt;=r)        {            if(s[r1]=='(') num++;            if(s[r1]==')') num--;            if(num==0) break;            r1++;        }        l2=r1+1,r2=r;        if(s[l]=='&amp;') return f(l1+1,r1-1)&amp;f(l2+1,r2-1);        else return f(l1+1,r1-1)|f(l2+1,r2-1);    }    else    {        int pos;        for(int i=l;i&lt;=r;++i)            if(!isdigit(s[i]))                pos=i;        int x=0,y=0;        for(int i=l;i&lt;=pos-1;++i) x=s[i]-'0'+x*10;        for(int i=pos+1;i&lt;=r;++i) y=s[i]-'0'+y*10;        bitset&lt;maxn&gt; b;        if(s[pos]==':')        {            for(int i=1;i&lt;=n;++i)            {                if(!mp[i].count(x)) b[i]=0;                else                {                    if(mp[i][x]==y) b[i]=1;                    else b[i]=0;                }            }        }        else        {            for(int i=1;i&lt;=n;++i)            {                if(!mp[i].count(x)) b[i]=0;                else                {                    if(mp[i][x]!=y) b[i]=1;                    else b[i]=0;                }            }        }        return b;    }}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        read(dn[i]);        int num;        read(num);        while(num--)        {            int x,y;            read(x),read(y);            mp[i][x]=y;        }    }    read(q);    while(q--)    {        scanf(\"%s\",s+1);        int len=strlen(s+1);        bitset&lt;maxn&gt; ans=f(1,len);        vector&lt;int&gt; v;        for(int i=1;i&lt;=n;++i)            if(ans[i])                v.push_back(dn[i]);        sort(v.begin(),v.end());        for(int i=0;i&lt;v.size();++i) printf(\"%d \",v[i]);        puts(\"\");    }    return 0;}\r\nT4 60:\r\n#include&lt;bits/stdc++.h&gt;#define maxn using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,q;struct node{    int id;    vector&lt;int&gt; l,r;};set&lt;node&gt; s;bool operator &lt; (const node &amp;a,const node &amp;b){    int siz=a.r.size();    for(int i=0;i&lt;m;++i)        if(a.r[i]!=b.r[i])            return a.r[i]&lt;b.r[i];    return false;}bool operator == (const node &amp;a,const node &amp;b){    return a.id==b.id&amp;&amp;a.l==b.l&amp;&amp;a.r==b.r;}vector&lt;int&gt; operator - (const vector&lt;int&gt; &amp;a,const int &amp;b){    vector&lt;int&gt; c=a;    for(int i=m-1;i&gt;=0;--i)    {        if(c[i])        {            c[i]-=b;            return c;        }        else        {            c[i]+=16;            c[i]-=b;        }    }    return c;}vector&lt;int&gt; get(string str){    vector&lt;int&gt; v;    int len=str.size();    for(int i=0;i&lt;len;i+=5)    {        int val=0;        for(int j=i;j&lt;i+4;++j)        {            int x;            if(isdigit(str[j])) x=str[j]-'0';            else            {                if(str[j]=='a') x=10;                if(str[j]=='b') x=11;                if(str[j]=='c') x=12;                if(str[j]=='d') x=13;                if(str[j]=='e') x=14;                if(str[j]=='f') x=15;            }            val=val*16+x;        }        v.push_back(val);    }    return v;}vector&lt;int&gt; R(){    string str;    cin&gt;&gt;str;    return get(str);}set&lt;node&gt;::iterator find(vector&lt;int&gt; &amp;x){    return s.lower_bound((node){0,x,x});}void work1(){    int x;    vector&lt;int&gt; l,r;    set&lt;node&gt;::iterator t1,t2,it;    read(x),l=R(),r=R();    t1=find(l),t2=find(r);    if(t1==s.end()&amp;&amp;t2==s.end())    {        puts(\"YES\");        s.insert((node){x,l,r});        return;    }    if(r&lt;(*t1).l)    {        puts(\"YES\");        s.insert((node){x,l,r});        return;    }    if((*t1)==(*t2)&amp;&amp;!(l&lt;(*t1).l))    {        puts(\"NO\");        return;    }    vector&lt;node&gt; v;    for(set&lt;node&gt;::iterator it=t1;it!=s.end();++it)    {        if(it==s.end()) break;        if(x!=(*it).id)        {            puts(\"NO\");            return;        }        v.push_back(*it);        if(it==t2) break;    }    for(int i=0;i&lt;v.size();++i) s.erase(v[i]);    if(v[0].l&lt;l) l=v[0].l;    if(r&lt;v[v.size()-1].r) r=v[v.size()-1].r;    puts(\"YES\");    node tmp=(node){x,l,r},ttmp;    s.insert(tmp);    it=find(r);    if(it!=s.begin())    {        t1=it,t1--;        if((*t1).r==tmp.l-1&amp;&amp;(*t1).id==x)        {            ttmp=(node){x,(*t1).l,tmp.r};            s.erase(t1),s.erase(tmp);            tmp=ttmp;            s.insert(tmp);        }    }    it=find(r);    t1=it,t1++;    if(t1!=s.end())    {        if(tmp.r==(*t1).l-1&amp;&amp;(*t1).id==x)        {            ttmp=(node){x,tmp.l,(*t1).r};            s.erase(t1),s.erase(tmp);            tmp=ttmp;            s.insert(tmp);        }    }}void work2(){    vector&lt;int&gt; x;    x=R();    set&lt;node&gt;::iterator it;    it=find(x);    if(it==s.end())    {        puts(\"0\");        return;    }    if(x&lt;(*it).l)    {        puts(\"0\");        return;    }    printf(\"%d\\n\",(*it).id);}void work3(){    vector&lt;int&gt; l,r;    set&lt;node&gt;::iterator t1,t2;    l=R(),r=R();    t1=find(l),t2=find(r);    if(t1==s.end()||t2==s.end())    {        puts(\"0\");        return;    }    if(t1!=t2)    {        puts(\"0\");        return;    }    if(l&lt;(*t1).l)    {        puts(\"0\");        return;    }    printf(\"%d\\n\",(*t1).id);}int main(){    read(n),read(q),m=n/16;    while(q--)    {        int opt;        read(opt);        if(opt==1) work1();        if(opt==2) work2();        if(opt==3) work3();    }    return 0;}\r\nT5 60:\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;ll ans;int l[maxn],r[maxn],id[maxn];set&lt;pair&lt;int,int&gt; &gt; s;map&lt;pair&lt;int,int&gt;,bool&gt; mp;bool vis[maxn],V[maxn],vis2[maxn];ll calc(int R){    if(V[R]) return 0;    V[R]=true;    ll val=0;    for(int i=1;i&lt;=m;++i) vis[i]=false;    for(int i=1;i&lt;=n;++i) vis2[i]=false;    int pos=0,id=0,mx=0;    for(int i=1;i&lt;=m;++i)    {        if(l[i]&gt;pos&amp;&amp;r[i]==R)        {            pos=l[i];            id=i;        }    }    vis[id]=true;    vis2[pos]=true;    val++;    priority_queue&lt;pair&lt;int,int&gt; &gt; q;    for(int i=1;i&lt;=m;++i)    {        if(vis[i]) continue;        if(r[i]&lt;=R)        {            q.push(make_pair(l[i],r[i]));        }    }    while(!q.empty())    {        int l=q.top().first,r=q.top().second;        q.pop();        if(r&gt;=pos-1&amp;&amp;l&lt;pos)        {            pos=l;            if(!vis2[pos])            {                vis2[pos]=true;                val++;            }        }    }    return val;}int main(){    read(n),read(m);    for(int i=1;i&lt;=m;++i) read(l[i]),read(r[i]);    for(int i=1;i&lt;=m;++i) ans+=calc(r[i]);    cout&lt;&lt;ans;    return 0;}\r\n","categories":["题解"],"tags":["CSP"]},{"title":"端到端组合优化","url":"/2023/09/03/%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/","content":"Memory-efficient\r\nTransformer-based network model for TravelingSalesman Problem\r\nHua Yang, Minghao Zhao, Lei Yuan, Yang Yu, Zhenhua Li, and Ming Gu.\r\n\"Memory-efficient Transformer-based network model for Traveling Salesman\r\nProblem.\", Neural Networks 161 (2023): 589-597.\r\n 模型在解决\r\n 中存在局限性：\r\n计算复杂度是二次的，\r\n中的操作导致时间和空间的复杂度为 。（ 是输入序列的长度）\r\n内存需求过高，导致内存不足。\r\n强化学习中马尔可夫决策过程的变量为：状态，\r\n为当前已访问的节点的有序序列。动作， 为下一个访问的节点。奖励，。转移，从当前为访问过的节点集合中选择一个点，加入到已访问的节点集合中。策略， 为一个神经网络， 是网络的可训练权值。 \r\nTspformer architecture\r\n\r\n 中的  被定义为：  ， 是序列长度， 是头的个数， 是嵌入维度。（实验中 ）\r\n其中主要的注意力来自于点积值，可以对查询数据进行采样，从而使得矩阵乘法运算的数据减少。\r\n采样  的个数为 ， 是一个微调参数，。采样  表示为 。\r\n用矩阵乘法来求  和  的兼容性：   取概率最高的前  个值为 ，即为值最大的前  个值。然后根据  对数据查询进行采样，得到 。\r\n再次计算  和  的兼容性：  屏蔽访问过的节点后，计算注意力值：  这里 \r\n都是可学习的矩阵。这里假定线性投影的隐藏维度都一样大，。（实验中 ）\r\n\r\nEncoder  的  和  的  的区别只有将 \r\n换为了 。\r\nDecoder  的  去掉了  的  中的第一个组件，即 。用自回归来每一次预测节点，用贪婪搜索和束搜索来改善解空间。\r\nModel training with\r\nreinforcement learning\r\n损失函数：  用随机梯度下降和策略梯度方法来优化参数，用  算法来计算梯度的更新：\r\n 用贪婪算法来作为 。\r\n为了构造 \r\n和单次采样，用蒙特卡洛抽样来采样 ： \r\nLearning\r\nto Iteratively Solve Routing Problems with Dual-Aspect Collaborative\r\nTransformer\r\nYining Ma, Jingwen Li, Zhiguang Cao, Wen Song, Le Zhang, Zhenghua\r\nChen, and Jing Tang. \"Learning to Iteratively Solve Routing Problems\r\nwith Dual-Aspect Collaborative Transformer.\", Conference on Neural\r\nInformation Processing Systems abs/2110.02544 (2021): 11096-11107.\r\n","categories":["学习笔记"],"tags":["论文","ML4CO","人工智能"]},{"title":"联邦学习","url":"/2023/11/15/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/","content":"联邦机器学习是一个机器学习框架，能有效帮助多个机构在满足用户隐私保护、数据安全和政府法规的要求下，进行数据使用和机器学习建模。\r\n联邦学习白皮书：\r\n联邦学习：在进行机器学习的过程中，各参与方可借助其他方数据进行联合建模。各方无需共享数据资源，即数据不出本地的情况下，进行数据联合训练，建立共享的机器学习模型。\r\n横向联邦学习：\r\n两个数据集的用户特征  重叠部分较大,而用户  重叠部分较小。\r\n在两个数据集的用户特征重叠较多而用户重叠较少的情况下，我们把数据集按照横向（即用户维度）切分并取出双方用户特征相同而用户不完全相同的那部分数据进行训练。\r\n纵向联邦学习：\r\n两个数据集的用户 \r\n重叠部分较大,而用户特征  重叠部分较小。\r\n在两个数据集的用户重叠较多而用户特征重叠较少的情况下，我们把数据集按照纵向（即特征维度）切分并取出双方用户相同而用户特征不完全相同的那部分数据进行训练。\r\n联邦迁移学习：\r\n两个数据集的用户 \r\n与用户特征重叠 \r\n部分都比较小。\r\n在两个数据集的用户与用户特征重叠都较少的情况下，我们不对数据进行切分，而可以利用迁移学习克服数据或标签不足的情况。\r\n\r\nJMLR\r\n2017 Communication-Efficient Learning Of Deep Networks From\r\nDecentralized Data\r\n为了保证模型聚合的准确性，FedAvg\r\n算法采用加权平均的方式进行模型聚合。设备上传的模型参数的权重是根据设备上的本地数据量大小进行赋值的，数据量越多的设备权重越大。但其也存在数据不平衡的问题，即数据量小的本地设备贡献小。\r\n目标为：  考虑联邦学习的情况，假设有  个客户端， 是第  个客户端的索引集，，目标则可改写为：  FedSGD\r\n 控制着全局批次大小， 对应全批次梯度下降。 和固定学习率  的 FedSGD 实现：  也等价于： \r\n也就是，每个客户端在其本地数据上使用当前模型进行一步全批量梯度下降，然后服务器对结果模型进行加权平均。\r\nFedAvg\r\n进行多次迭代本地更新：  其中参数为：，每轮计算的客户端的比例。，每个客户端在每轮中对其本地数据集进行的训练次数（）。，客户端更新的本地批量大小。\r\n当 （整个本地数据集视为一个批次）和  时，就对应了 FedSGD。\r\n\r\nNeurIPS\r\n2020 Personalized Federated Learning: A Meta-Learning Approach\r\nPer-FedAvg，其目标是训练一个全局模型，该模型更容易进行微调以适应特定设备的数据。\r\n若有 \r\n个客户端，则联邦学习的目标为： \r\n其局限性为：在用户数据分布不同的异质情况时，这样得到的全局模型应用到本地时，表现不好。因此需要考虑到每个用户的特定情况，而不能仅仅依赖全局模型。\r\nPer-FedAvg\r\n中则是所有用户得到初始模型后，然后在本地数据上梯度下降一次来得到自己的模型：\r\n 回顾 FedAvg 的做法：  我们需要计算本地函数的梯度：  实现时，用无偏估计代替原始参数求导来减少开销。\r\n\r\nMLSys\r\n2020 Federated Optimization in Heterogeneous Networks\r\nFedProx，其目标是解决在本地训练过程中，个性化模型偏离全局模型过远的问题。为了实现这一目标，FedProx\r\n在本地训练的目标函数中引入了一个动态正则化项。这个正则化项可以限制模型的更新步骤，防止模型偏离全局模型太远。\r\n设备  在本地训练时，最小化：\r\n \r\n动态变化时，效果最好。实验中，当损失连续  轮增加时，我们将  增加 ；当损失连续  轮减少时，我们将  减少 。\r\nNeurIPS\r\n2023 PRIOR: Personalized Prior for Reactivating the Information\r\nOverlooked in Federated Learning\r\nIntroduction\r\n联邦学习的基本特性是数据异质性，导致了诸如训练和测试数据不一致（数据漂移）等挑战。\r\n数据异质性：不同的参与者可能拥有不同类型或分布的数据。这种数据的差异性可能导致模型在不同的参与者之间表现不一致。\r\n数据漂移：模型在训练和测试数据上的表现不一致。例如，如果模型在某一类型的数据上进行训练，但在另一类型的数据上进行测试，那么模型的表现可能会下降。这是因为模型可能未能捕捉到测试数据中的某些重要特征。\r\n个性化\r\nFL（PFL）被提出来减轻异构数据导致的负面影响。通过个性化学习，每个设备可以根据其自身的数据特性训练模型，从而提高模型在该设备上的性能。\r\n现有的 PFL 存在两个问题：\r\n相同的全局模型为本地训练提供先验知识，导致忽视客户端的采样信息。\r\n做不到显式提取先验知识。\r\n本文提出了 pFedBreD\r\n框架，将个性化先验知识注入到全局模型提供的知识中，来解决第一个问题。引入宽松的镜像下降\r\nRMD 来显式提取先验以探索个性化策略，来解决第二个问题。\r\nPreliminary\r\nOverlooked Information in Prior Knowledge\r\n传递给客户端的全局知识与客户端采样没有互信息（Mutual\r\nInformation，MI，度量了两个变量之间相互依赖的程度），即  其中  是第  个客户端上的本地模型， 是全局模型， 是在给定客户端  的采样的条件下的期望值。\r\nBregman-Moreau Envelope\r\n布雷格曼散度（Bregman\r\nDivergence）是一种在优化问题中常用的正则项，它满足计算需求和先验假设：\r\n \r\n是一个严格凸、可微的函数。\r\n如何理解布雷格曼散度：  注意到  是  的导数，将定义扩展，把  换为凸函数  后便得到了布雷格曼散度。\r\n为了利用布雷格曼散度的计算性质，引入布雷格曼近端映射（Bregman\r\nproximal mapping）和布雷格曼-莫罗包络（Bregman-Moreau envelope）：  其中 \r\n表示正则化强度和建模中先验的方差。\r\nExponential Family\r\n指数族（Exponential Family，X-family）：  其中， 是凸函数，\r\n是布雷格曼散度， 是  的 Fenchel 共轭， 是自然参数， 是势函数， 是对数归一化因子， 是均值参数。\r\n为了突出方差，引入了缩放指数族（Scaled Exponential\r\nFamily，SX-family）：  其中  是缩放势函数，\r\n是缩放参数，用来突出方差。\r\n\r\n被假设为本地推断的完全信息的最小充分统计量。\r\nMethodology\r\n在经典联邦学习的基础上引入缺失的客户端采样信息，使用 EM\r\n算法来降低引入信息的计算成本，并基于 EM 中的 E-step\r\n提出了一类先验选择策略，RMD。\r\n通过客户端采样  和本地数据采样\r\n，具有 KL 散度的一般 FL\r\n分类问题可被表述为：  KL 散度用来度量两个概率分布之间的差异程度：  这里将判别模型重写为了一个关于  的最大似然估计（MLE）问题。 是  参数化的推理模型。\r\n直接通过全局模型传输的先验知识作为本地训练的先验知识（例如，通过初始点，动态正则项中的惩罚点等）与客户端采样没有互信息。为了减少忽视信息的潜在影响，引入了第\r\n 个客户端的完整信息 ：  其中 ，但直接计算的话，计算成本高昂。\r\nFramework: Leveraging Expectation Maximization for Prior\r\nParameter Extraction\r\n因此用 EM 方法来近似含有未观察变量的似然函数，其中  是任意的概率测度：  引入两个假设：  第一个是对先验的假设，第二个是假设  包含了所有的本地推断信息。\r\n第  个客户端的本地损失函数为\r\n，结合假设，得到 。最终得到一个双层优化的问题：\r\n 其中均值参数 。\r\nStrategies: Relaxing Mirror Descent for Prior\r\nSelection\r\n为了在封闭形式中实现 EM 的 \r\nE-step 并提取先验策略，提出了一种称为松弛镜像下降（Relaxed Mirror\r\nDescent，简称 RMD）的方法。\r\n镜像下降（Mirror Descent，简称MD）是 X-family 中的 EM，为： \r\n根据拉格朗日对偶性，将问题重写成更一般的变体，其中有松弛的限制和多余的参数：\r\n 设置  满足\r\n，并定义  作为一个包含 \r\n和一个使得  和 \r\n尽可能接近的惩罚项的函数，使得将该公式  转换回公式 。这提供了一种提取 \r\n的方法，该函数用于生成先验的均值参数，如公式  所示，该公式是最小化公式  问题的上界：  根据最优性条件，有 ，这可以由  指定。剩下的部分是一个\r\nBregman-Moreau 包络。因此，我们可以使用 EM-MAP 方法优化上界，交替计算\r\n 和 。\r\nFramework Design\r\nProblem Formulation that Highlights Personalized\r\nPrior\r\n个性化模型 \r\n和平均参数分别是第i个客户端上的  和  的解，其中  是全局模型。我们假设个性化模型包含第\r\n\r\n个客户端上推理所需的所有本地信息，并且满足 ，全局问题可以写成：   是严格凸的，， 是局部损失函数， 是自然参数， 是均值方程中的参数。\r\nFramework: pFedBreD\r\n为了解决方程 \r\n中的优化问题，使用基于梯度的方法来利用  的梯度来解决全局问题：  其中 \r\n是向量值函数的梯度算子， 是\r\nHessian 算子。其中 \r\n是全局模型聚合的客户端选择策略，和  是第  个客户端的初始化策略， 为主问题步长，\r\n分别是总迭代次数、局部迭代次数和客户端数。 生成每个  和  的初始化点的策略是  和\r\n 。\r\n\r\n","categories":["学习笔记"],"tags":["论文","人工智能","联邦学习"]},{"title":"边缘计算","url":"/2023/09/24/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/","content":"Edge Intelligence\r\nPyramid:\r\nEnabling Hierarchical Neural Networks with Edge Computing\r\nQiang He, Zeqian Dong, Feifei Chen, Shuiguang Deng, Weifa Liang, and\r\nYun Yang. \"Pyramid: Enabling Hierarchical Neural Networks with Edge\r\nComputing\", The Web Conference (2022): 1860-1870.\r\n云端的 \r\n模型存在固有的局限性。首先，其对于延迟敏感的应用，很难保持低延迟。其次，它会在已经承受很对压力的回程网络上产生过多的流量。（回程指核心网或骨干网与网络边缘的小子网之间的中间链路）\r\n边缘计算提供一种新的计算模式，使网络边缘的 \r\n克服了上述限制。在边缘计算环境中，配置了计算资源的边缘服务器被部署在基站或者接入点。这使得\r\n\r\n模型可以在边缘服务器而不是远程的云服务器上进行训练和部署。\r\n本篇论文提出了一种新的框架，，来在边缘服务器实现 ，在云服务器实现\r\n。\r\nPROBLEM STATEMENT\r\n\r\n 个地区被  条高速相连。第  个地区有  个道路传感器，。所有的道路传感器为 。每条高速上至少有 \r\n个高速传感器，两个端点各一个，中点一个，。总共有\r\n 个高速传感器，总共为 。\r\n用邻接矩阵来表示距离，。\r\n在时间 \r\n内传感器采集的历史交通数据为 ，总共为\r\n。\r\n分层交通预测的目标是预测 \r\n时间的道路交通状况  和高速交通状况 。\r\nPYRAMID NEURAL NETWORK\r\n\r\n由部署在边缘服务器上的  和部署在云服务器上的 \r\n两个主要部分组成。\r\n\r\nLocal Prediction\r\n\r\n 由  三部分组成。\r\n之前获取时空道路交通相关性的方法都是采用了两个时间块和中间一个空间块的“三明治”结构。但堆叠三明治之间的时间块会产生额外的开销。针对该问题，\r\n采用了“双层三明治”结构，由三个时间块与两个空间块交织组成。\r\nData Modeling\r\n将道路传感器收集到的历史交通数据放入  可读的矩阵中：  Feature Extraction\r\n\r\n采用时间块从输入矩阵 \r\n中提取时间道路交通特征。时间块中包含 ，其可以将线性和非线性特征都传输到后续层：  其中  是  激活层。\r\n空间块的主要组成部分是 ，通过图卷积来获取空间道路交通相关性：\r\n 其中  是  激活层，。\r\nPrediction\r\n最后用一个全连接层来实现预测：  同时， 也将被传输到\r\n\r\n来方便全局预测。\r\nGlobal Prediction\r\n\r\n 由 \r\n两部分组成。\r\nFeature Extraction\r\n输入是 \r\n提取的道路交通特征：   从\r\n\r\n中获取道路与高速的空间相关性，高速之间的空间相关性，高速的时间相关性。\r\n\r\n采用了转换块来将道路交通特征  转换为高速交通特征 。其由两个稀疏层和中间的批量归一化层组成。\r\n第一个稀疏层将  维道路交通特征\r\n 转换为  维中间特征：   是嵌入矩阵。\r\n第二个稀疏层将 \r\n维中间特征转换为  维高速交通特征\r\n：   是嵌入矩阵。\r\n根据  来构建\r\n 的全局道路高速邻接矩阵\r\n。其中  表示第  个道路传感器是否与第  个道路传感器相关。然后将  分解为  的  和  的 ，其中\r\n。\r\nPrediction\r\n最后用一个全连接层来实现预测： \r\nFedEdge:\r\nAccelerating Edge-Assisted Federated Learning\r\nKaibin Wang, Qiang He, Feifei Chen, Hai Jin, and Yun Yang. \"FedEdge:\r\nAccelerating Edge-Assisted Federated Learning\", WWW 2023 (2023):\r\n2895-2904.\r\n\r\n 存在三个缺陷：\r\n两阶段训练期间浪费了大量时间，客户端在发送本地模型进行聚合后停止模型训练，直到使用接收到的全局模型更新本地模型。他们的等待时间可以用来加速模型训练。\r\n缺乏模型多样性，而数据存在多样性。\r\n存在模型受到中毒袭击的漏洞，边缘服务器容易受到损害。\r\n本文提出了 \r\n来解决以上问题。\r\nPRELIMINARIES\r\nFederated Learning\r\n研究重点是在 \r\n方案下以有限和目标训练神经网络模型：  其中  是 \r\n系统中客户端的数量，每个客户端都有一个本地训练数据集 。 是第 k\r\n个客户的局部损失函数，衡量  的局部经验风险：  其中 \r\n是训练样本， 是交叉熵损失函数。\r\nEdge-Assisted Federated Learning\r\n考虑一个 \r\n系统，客户端用 ， 表示，以及一组覆盖这些客户端的  个边缘服务器，用  表示，以及云服务器\r\n。每个边缘服务器  覆盖客户端的一个子集 。 每个客户端  都拥有一个本地数据集 。其中\r\n 表示第  个输入样本， 是  的相应标记输出。\r\n 与现有的边缘辅助\r\n\r\n方案有着相同的基本训练流程：\r\n，客户端在自己的数据集上训练本地模型，然后将本地模型传输到相应的边缘服务器。\r\n，每个边缘服务器通过聚合其客户端的本地模型来生成中间模型，并将中间模型传输到云服务器。\r\n，云服务器通过聚合从边缘服务器接收到的中间模型来生成全局模型。\r\n，云服务器将全局模型发送至边缘服务器；边缘服务器将全局模型发送给其客户端；最后，客户更新他们的本地模型并进入下一轮训练。\r\nFINDINGS OF OUR EXPLORATION\r\nTraining Time Wasting\r\n\r\nLack of Model Diversity Consideration\r\n利用模型多样性后，模型精度和模型收敛性均有提升。\r\nVulnerability to Model Poisoning Attacks\r\nFEDEDGE DESIGN\r\nAsynchronous Local Federated Training\r\n\r\nAdaptive Model Aggregation\r\nPhase 1: Filtering Anomalous Models\r\n\r\nPhase 2: Aggregating Models  \r\nEdgeMove:\r\nPipelining Device-Edge Model Training for Mobile Intelligence\r\nZeqian Dong, Qiang He, Feifei Chen, Hai Jin, Tao Gu, and Yun Yang.\r\n\"EdgeMove: Pipelining Device-Edge Model Training for Mobile\r\nIntelligence\", WWW 2023 (2023): 3142-3153.\r\nEdgeMove\r\n将模型分为两个部分，一个用于在边缘设备上进行训练，另一个用于在边缘服务器上进行训练。中间传输的是中间特征，而不是用户的私有数据。与端云训练方案相比，EdgeMove\r\n显著减少了本地模型部分和外部模型部分之间的通信延迟带来的训练过程延迟。\r\nEdgeMove\r\n探测边缘设备附近边缘服务器的训练性能，并通过近似模型分区引导模型训练。EdgeMove\r\n自适应地探测附近边缘服务器的训练性能，并根据运行时的系统动态主动调整训练管道。\r\nEdgeMove 监控工作线程（即当前正在训练 ML\r\n模型的边缘服务器）的端到端训练性能，自适应地探测附近边缘服务器的端到端性能，并调整训练主动管道\r\nOFFLINE PIPELINE\r\nCONSTRUCTION\r\nModel Profiling\r\nEdgeMove 发送一个测试模型 \r\n和一个测试数据集 \r\n到每个附近的边缘服务器用于训练，完成训练周期并返回结果时，客户端将获得其端到端训练性能的估计值。\r\nModel Partitioning\r\n令 \r\n表示边缘设备在模型分析中完成一个训练周期所花费的时间， 表示附近边缘服务器的集合， 表示  中第 \r\n个附近边缘服务器所花费的时间。我们计算它们每层训练时间如下：  \r\n是训练循环中的训练迭代次数，\r\n是目标模型  中的层数。\r\nEdgeMove\r\n下模型分区的目标是最大化管道吞吐量，类似于现有的管道方案。关键是吞吐量平衡，即边缘设备和边缘服务器维持大致相同的吞吐量。注意到边缘设备的训练性能低于边缘服务器，EdgeMove\r\n分区目标是确保处理一个\r\nminibatch（包括前向和后向传递）所需的时间大致等于完成前一个 minibatch\r\n的后向传递所需的时间加上下一个小批量的前向传递。\r\nONLINE PIPELINE ADAPTATION\r\n在运行时，EdgeMove\r\n监控管道性能并相应地调整训练管道。它可以通过两种方式调整训练管道：1）调整跨客户端和工作器的模型划分；\r\n2）使用新的工作器和可能的新模型分区来调整整个训练管道。\r\nEdge Resource\r\nA\r\nGame-Theoretical Approach for User Allocation in Edge Computing\r\nEnvironment\r\n应用程序供应商的另一个重要目标是最大限度地降低为应用程序用户提供服务的总体系统成本。该问题称为边缘用户分配（EUA）问题。\r\n位于边缘服务员覆盖的交叉区域的应用程序用户可以连接到附近具有足够计算能力（容量约束）（例如CPU、内存和带宽）的边缘服务器之一（邻近约束）。\r\n本文了介绍 EUAGame，这是一种寻找 EUA 问题解决方案的博弈论方法。\r\nEUAGame 将应用程序供应商的 EUA 问题建模为 EUA\r\n游戏。在这个游戏中，每个应用程序用户都被模拟为游戏中的玩家，寻找附近的边缘服务器来卸载其计算任务。\r\nEUAGame\r\n然后采用去中心化算法为应用程序用户做出分配决策，以实现游戏的纳什均衡。\r\n\r\nSYSTEM MODEL\r\n对于应用供应商，EUA 旨在将其 \r\n个应用用户 \r\n分配给特定区域的 m 个边缘服务器 。应用用户  的容量需求，用  表示，其中 。边缘服务器  的可用容量用  表示，其中 。\r\n\r\nMulti-tenancy Benefit Model\r\n服务器  的 CPU\r\n利用率可以近似为：  其中  由计算任务大小决定，是分配给服务器的应用程序用户数。\r\n边缘服务器 \r\n的多租户收益计算公式为：  其中  且  由计算任务大小决定。\r\nUser Benefit Model  这样的边缘服务器 \r\n被称为  的邻居边缘服务器。 的邻居边缘服务器集由  表示\r\nCost-Effective\r\nApp Data Distribution in Edge Computing\r\n在本文中，我们首次尝试从应用供应商的角度将边缘数据分布 （EDD）\r\n问题表述为约束优化问题，并证明其 NP-hardness。我们提出了一种名为 EDD-IP\r\n的最优方法，用整数规划技术精确地解决了这个问题。然后，我们提出了一种名为\r\nEDD-A 的 \r\n逼近算法，用于有效地找到大规模 EDD 问题的近似解。\r\nOnline\r\nCollaborative Data Caching in Edge Computing\r\n在本文中，我们研究了 EC\r\n环境中的协同缓存问题，旨在最小化系统成本，包括数据缓存成本、数据迁移成本和服务质量\r\n（QoS）\r\n损失。我们将该协同边缘数据缓存问题（CEDC）建模为约束优化问题，并证明它是\r\nNP-complete 的。我们提出了一种称为 CEDC-O 的在线算法，以解决所有时隙中的\r\nCEDC 问题。CEDC-O 基于 Lyapunov\r\n优化开发，无需未来信息即可在线工作，并实现可证明的接近最佳性能。\r\nEdge Security\r\nCooperative\r\nAssurance of Cache Data Integrity for Mobile Edge Computing\r\n但是，在高度分布式的 MEC\r\n环境中，缓存数据容易损坏，必须确保其完整性。现有的集中式数据完整性保证方案被MEC的独特特性所淘汰，即与云服务器不同，边缘服务器只有有限的计算和存储资源，并且它们大规模部署并分布在地理上。因此，在地理位置分散、资源受限的边缘服务器上确保缓存数据完整性是一项新的重大挑战。该文提出一种以分布式方式保证边缘数据完整性的CooperEDI方案。CooperEDI采用分布式共识机制，形成自我管理的边缘缓存系统。在系统中，边缘服务器协同确保缓存副本的完整性并修复损坏的副本。我们根据三种具有代表性的方案对其性能进行了实验评估。结果表明，CooperEDI能够有效、高效地保证MEC环境下的缓存数据完整性。\r\nA\r\nGame-Theoretical Approach for Mitigating Edge DDoS Attack\r\n在本文中，我们首次尝试解决边缘 DDoS 缓解 （EDM）\r\n问题。我们将其建模为约束优化问题，并证明其NP硬度。为了解决这个问题，我们提出了一种名为EDMOpti的最优方法和一种名为EDMGame的新颖博弈论方法，用于缓解边缘DDoS攻击。EDMGame\r\n将 EDM 问题表述为一个潜在的 EDM\r\n博弈，它承认纳什均衡，并采用分散算法来寻找纳什均衡作为 EDM\r\n问题的解决方案。通过理论分析和实验评估，证明了我们的方法能够有效、高效地解决EDM问题。\r\nCoopEdge:\r\nA Decentralized Blockchain-based Platform for Cooperative Edge\r\nComputing\r\n本文提出了CoopEdge，一种基于区块链的新型去中心化平台，用于驱动和支持协同边缘计算。在\r\nCoopEdge\r\n上，边缘服务器可以发布计算任务供其他边缘服务器争用。获胜者是根据其声誉从候选边缘服务器中选出的。之后，边缘服务器之间达成共识，记录区块链上任务执行的性能。我们实现了基于\r\nHyperledger Sawtooth 的 CoopEdge，并在模拟 EC\r\n环境中根据基线和两个最先进的实现对其进行了实验评估。结果验证了 CoopEdge\r\n的实用性并证明了其性能。\r\n","categories":["学习笔记"],"tags":["论文","边缘计算"]},{"title":"量化","url":"/2023/12/05/%E9%87%8F%E5%8C%96/","content":"AISTAT 2020 FedPAQ: A Communication-Efficient Federated Learning\r\nMethod with Periodic Averaging and Quantization\r\nIntroduction\r\n来解决两个问题：\r\n通信瓶颈：因为大量客户端要和中心服务器传输数据，所以在联邦学习中，通信带宽是一个主要的瓶颈。\r\n规模：客户端在训练过程中可能是活跃的、慢速的，或者完全不活跃的。因此，一个被提出的联邦学习算法应该能够在部分设备参与或随机抽样设备的情况下高效地运行。\r\nFedPAQ：\r\n周期性平均：周期性平均可以减少通信轮数，从而减少训练过程的总通信成本。\r\n部分节点参与：每一轮中，只有总设备的一小部分（即活跃设备）有助于训练模型。\r\n量化的信息传递：节点在每轮通信中仅将其量化后的本地信息发送到服务器。\r\nFederated Learning Setup\r\n考虑以下随机学习问题：  考虑每个节点 \r\n维护来自分布  的  个样本的集合：  本文考虑的是独立同分布的情况。\r\nProposed FedPAQ Method\r\nPeriodic averaging\r\n本地运行  次 \r\n来更新模型后再上传，而不是一次更新一次上传。\r\nPartial node participation\r\n假设在总共  个设备中，只有\r\n\r\n个设备在训练的每一轮中是可用的，且是随机分布的。\r\n在训练的每个周期里，随机选取 \r\n个设备来训练，集合为 。\r\nQuantized message-passing\r\n上传模型时量化，用的是低精度量化器。\r\nAlgorithm update\r\n\r\n个周期，每个周期中，每个节点执行  次本地更新，总共进行 \r\n次迭代。每个周期中，随机均匀选择 \r\n个设备：  \r\n是从本地数据集 \r\n中选取的随机样本来计算得到的。\r\n本地更新完后，将量化更新  上传到服务器：  \r\n","categories":["学习笔记"],"tags":["论文","联邦学习","量化"]},{"title":"算法竞赛模板","url":"/2023/07/30/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%A8%A1%E6%9D%BF/","content":"数据结构\r\n线段树合并\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 20000010#define all 100000#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot;int ans[maxn],f[maxn][19],dep[maxn],rt[maxn],mx[maxm],id[maxm],ls[maxm],rs[maxm];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void dfs_pre(int x,int fa){    dep[x]=dep[f[x][0]=fa]+1;    for(int i=1;i&lt;=16;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_pre(y,x);    }}int lca(int x,int y){\tif(dep[x]&lt;dep[y]) swap(x,y);\tfor(int i=16;i&gt;=0;--i)\t\tif(f[x][i]&amp;&amp;dep[f[x][i]]&gt;=dep[y])\t\t\tx=f[x][i];\tif(x==y) return x;\tfor(int i=16;i&gt;=0;--i)\t\tif(f[x][i]&amp;&amp;f[x][i]!=f[y][i])\t\t\tx=f[x][i],y=f[y][i];\treturn f[x][0];}void pushup(int cur){\tif(mx[ls[cur]]&gt;=mx[rs[cur]]) mx[cur]=mx[ls[cur]],id[cur]=id[ls[cur]];\telse mx[cur]=mx[rs[cur]],id[cur]=id[rs[cur]];}void modify(int l,int r,int pos,int v,int &amp;cur){\tif(!cur) cur=++tot;\tif(l==r)\t{\t\tmx[cur]+=v,id[cur]=l;\t\treturn;\t}\tif(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);\telse modify(mid+1,r,pos,v,rs[cur]);\tpushup(cur);}int merge(int x,int y,int l,int r){\tif(!x||!y) return x+y;\tif(l==r)\t{\t\tmx[x]+=mx[y];\t\treturn x;\t}\tls[x]=merge(ls[x],ls[y],l,mid);\trs[x]=merge(rs[x],rs[y],mid+1,r);\tpushup(x);\treturn x;}void dfs_ans(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==f[x][0]) continue;\t\tdfs_ans(y),rt[x]=merge(rt[x],rt[y],1,all);\t}\tans[x]=mx[rt[x]]?id[rt[x]]:0;}int main(){    read(n),read(m);    for(int i=1;i&lt;n;++i)    {    \tint x,y;    \tread(x),read(y);    \tadd(x,y),add(y,x);    }    dfs_pre(1,0);    for(int i=1;i&lt;=m;++i)    {    \tint x,y,v,anc;    \tread(x),read(y),read(v),anc=lca(x,y);    \tmodify(1,all,v,1,rt[x]),modify(1,all,v,1,rt[y]);    \tmodify(1,all,v,-1,rt[anc]),modify(1,all,v,-1,rt[f[anc][0]]);    }    dfs_ans(1);    for(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]);    return 0;}\r\n线段树分裂\r\n维护若干个可重集。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 80000010#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot,num=1;int rt[maxn],ls[maxn],rs[maxn];ll cnt[maxn];void pushup(int cur){    cnt[cur]=cnt[ls[cur]]+cnt[rs[cur]];}void modify(int l,int r,int pos,ll v,int &amp;cur){    if(!cur) cur=++tot;    if(l==r)    {        cnt[cur]+=v;        return;    }    if(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);    else modify(mid+1,r,pos,v,rs[cur]);    pushup(cur);}ll query(int L,int R,int l,int r,int cur){    if(!cur) return 0;    if(L&lt;=l&amp;&amp;R&gt;=r) return cnt[cur];    ll v=0;    if(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);    if(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);    return v;}int kth(int l,int r,ll k,int cur){    if(l==r) return l;    if(cnt[ls[cur]]&gt;=k) return kth(l,mid,k,ls[cur]);    else return kth(mid+1,r,k-cnt[ls[cur]],rs[cur]);}int merge(int x,int y){    if(!x||!y) return x+y;    int p=++tot;    cnt[p]=cnt[x]+cnt[y];    ls[p]=merge(ls[x],ls[y]);    rs[p]=merge(rs[x],rs[y]);    return p;}void split(int L,int R,int l,int r,int &amp;x,int &amp;y){    if(!x) return;    if(L&lt;=l&amp;&amp;R&gt;=r)    {        y=x,x=0;        return;    }    y=++tot;    if(L&lt;=mid) split(L,R,l,mid,ls[x],ls[y]);    if(R&gt;mid) split(L,R,mid+1,r,rs[x],rs[y]);    pushup(x),pushup(y);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i)    {        ll x;        read(x),modify(1,n,i,x,rt[1]);    }    while(m--)    {        int opt,p;        ll x,y,k;        read(opt),read(p);        if(opt==1||opt==4) read(k);        else read(x),read(y);        if(opt==0) split(x,y,1,n,rt[p],rt[++num]);        if(opt==1) rt[p]=merge(rt[p],rt[k]);        if(opt==2) modify(1,n,y,x,rt[p]);        if(opt==3) printf(\"%lld\\n\",query(x,y,1,n,rt[p]));        if(opt==4)        {            if(cnt[rt[p]]&lt;k) puts(\"-1\");            else printf(\"%d\\n\",kth(1,n,k,rt[p]));        }    }    return 0;}\r\n吉司机线段树\r\n区间加，区间取 ，区间求和，区间最大值，区间历史最大值。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010#define inf 20000000000#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,root=1;ll a[maxn],ma[maxn],hma[maxn],se[maxn],cnt[maxn],sum[maxn];ll tag[maxn],htag[maxn],add[maxn],hadd[maxn];void pushup(int cur){    sum[cur]=sum[ls]+sum[rs],ma[cur]=max(ma[ls],ma[rs]),hma[cur]=max(hma[ls],hma[rs]);    if(ma[ls]==ma[rs]) se[cur]=max(se[ls],se[rs]),cnt[cur]=cnt[ls]+cnt[rs];    else if(ma[ls]&gt;ma[rs]) se[cur]=max(se[ls],ma[rs]),cnt[cur]=cnt[ls];    else se[cur]=max(ma[ls],se[rs]),cnt[cur]=cnt[rs];}void pushtag(int cur,int l,int r,ll v,ll hv,ll w,ll hw){    sum[cur]+=v*cnt[cur]+w*(r-l+1-cnt[cur]);    hma[cur]=max(hma[cur],ma[cur]+hv),ma[cur]+=v;    htag[cur]=max(htag[cur],tag[cur]+hv),tag[cur]+=v;    hadd[cur]=max(hadd[cur],add[cur]+hw),add[cur]+=w;    if(se[cur]!=-inf) se[cur]+=w;}void pushdown(int cur,int l,int r){    ll maxv=max(ma[ls],ma[rs]);    if(ma[ls]==maxv) pushtag(ls,l,mid,tag[cur],htag[cur],add[cur],hadd[cur]);    else pushtag(ls,l,mid,add[cur],hadd[cur],add[cur],hadd[cur]);    if(ma[rs]==maxv) pushtag(rs,mid+1,r,tag[cur],htag[cur],add[cur],hadd[cur]);    else pushtag(rs,mid+1,r,add[cur],hadd[cur],add[cur],hadd[cur]);    tag[cur]=htag[cur]=add[cur]=hadd[cur]=0;}void build(int l,int r,int cur){    if(l==r)    {        sum[cur]=ma[cur]=hma[cur]=a[l],se[cur]=-inf,cnt[cur]=1;        return;    }    build(l,mid,ls),build(mid+1,r,rs),pushup(cur);}void modify_add(int L,int R,int l,int r,ll v,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        pushtag(cur,l,r,v,v,v,v);        return;    }    pushdown(cur,l,r);    if(L&lt;=mid) modify_add(L,R,l,mid,v,ls);    if(R&gt;mid) modify_add(L,R,mid+1,r,v,rs);    pushup(cur);}void modify_min(int L,int R,int l,int r,ll v,int cur){    if(v&gt;=ma[cur]) return;    if(L&lt;=l&amp;&amp;R&gt;=r&amp;&amp;v&gt;se[cur])    {        pushtag(cur,l,r,v-ma[cur],v-ma[cur],0,0);        return;    }    pushdown(cur,l,r);    if(L&lt;=mid) modify_min(L,R,l,mid,v,ls);    if(R&gt;mid) modify_min(L,R,mid+1,r,v,rs);    pushup(cur);}ll query_sum(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];    pushdown(cur,l,r);    ll ans=0;    if(L&lt;=mid) ans+=query_sum(L,R,l,mid,ls);    if(R&gt;mid) ans+=query_sum(L,R,mid+1,r,rs);    return ans;}ll query_max(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return ma[cur];    pushdown(cur,l,r);    ll ans=-inf;    if(L&lt;=mid) ans=max(ans,query_max(L,R,l,mid,ls));    if(R&gt;mid) ans=max(ans,query_max(L,R,mid+1,r,rs));    return ans;}ll query_his(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return hma[cur];    pushdown(cur,l,r);    ll ans=-inf;    if(L&lt;=mid) ans=max(ans,query_his(L,R,l,mid,ls));    if(R&gt;mid) ans=max(ans,query_his(L,R,mid+1,r,rs));    return ans;}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    build(1,n,root);    while(m--)    {        int opt,l,r,v;        read(opt),read(l),read(r);        if(opt==1||opt==2) read(v);        if(opt==1) modify_add(l,r,1,n,v,root);        if(opt==2) modify_min(l,r,1,n,v,root);        if(opt==3) printf(\"%lld\\n\",query_sum(l,r,1,n,root));        if(opt==4) printf(\"%lld\\n\",query_max(l,r,1,n,root));        if(opt==5) printf(\"%lld\\n\",query_his(l,r,1,n,root));    }    return 0;}\r\n线段树优化建图\r\nvoid build_in(int L,int R,int &amp;cur){    cur=++tree_cnt;    if(L==R)    {        in_num[L]=cur;        return;    }    int mid=(L+R)&gt;&gt;1;    build_in(L,mid,ls[cur]);    build_in(mid+1,R,rs[cur]);    add(ls[cur],cur,0),add(rs[cur],cur,0);}void build_out(int L,int R,int &amp;cur){    cur=++tree_cnt;    if(L==R)    {        out_num[L]=cur;        return;    }    int mid=(L+R)&gt;&gt;1;    build_out(L,mid,ls[cur]);    build_out(mid+1,R,rs[cur]);    add(cur,ls[cur],0),add(cur,rs[cur],0);}void modify_in(int L,int R,int l,int r,int pos,int val,int &amp;cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        add(cur,pos,val);        return;    }    int mid=(l+r)&gt;&gt;1;    if(L&lt;=mid) modify_in(L,R,l,mid,pos,val,ls[cur]);    if(R&gt;mid) modify_in(L,R,mid+1,r,pos,val,rs[cur]);}void modify_out(int L,int R,int l,int r,int pos,int val,int &amp;cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        add(pos,cur,val);        return;    }    int mid=(l+r)&gt;&gt;1;    if(L&lt;=mid) modify_out(L,R,l,mid,pos,val,ls[cur]);    if(R&gt;mid) modify_out(L,R,mid+1,r,pos,val,rs[cur]);}\r\n线段树分治\r\n删去无向连通图一些边后，询问原图是否连通。将删边转化为边存在的区间，用带权并查集维护连通块大小。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 400010#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,k,top;int fa[maxn],siz[maxn],pre[maxn];bool ans[maxn];vector&lt;int&gt; ve[maxm];struct node{    int x,y;    node(int a=0,int b=0)    {    \tx=a,y=b;    }}e[maxn],st[maxn];int find(int x){    return fa[x]==x?x:find(fa[x]);}void merge(int x,int y){    x=find(x),y=find(y);    if(x==y) return;    if(siz[x]&lt;siz[y]) swap(x,y);    st[++top]=node(x,y),fa[y]=x,siz[x]+=siz[y];}void insert(int L,int R,int l,int r,int id,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        ve[cur].push_back(id);        return;    }    if(L&lt;=mid) insert(L,R,l,mid,id,ls);    if(R&gt;mid) insert(L,R,mid+1,r,id,rs);}void del(int id){    int x=st[id].x,y=st[id].y;    fa[y]=y,siz[x]-=siz[y];}void dfs(int l,int r,int cur){    int now=top;    for(int i=0;i&lt;ve[cur].size();++i)\t\tmerge(e[ve[cur][i]].x,e[ve[cur][i]].y);    if(l==r) ans[l]=siz[find(1)]==n;    else dfs(l,mid,ls),dfs(mid+1,r,rs);    while(top&gt;now) del(top--);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) siz[fa[i]=i]=1;    for(int i=1;i&lt;=m;++i) read(e[i].x),read(e[i].y),pre[i]=1;    read(k);    for(int i=1;i&lt;=k;++i)    {        int c;        read(c);        while(c--)        {            int id;            read(id);            if(pre[id]&lt;i) insert(pre[id],i-1,1,k,id,1);            pre[id]=i+1;        }    }    for(int i=1;i&lt;=m;++i)        if(pre[i]&lt;=k)            insert(pre[i],k,1,k,i,1);    dfs(1,k,1);    for(int i=1;i&lt;=k;++i) puts(ans[i]?\"Connected\":\"Disconnected\");\treturn 0;}\r\n李超线段树\r\n支持插入直线，查询单点最值。\r\n，斜率优化，维护下凸壳。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 4000010#define all 1000000#define inf 1000000000000#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot,root;int ls[maxm],rs[maxm],num[maxm];ll h[maxn],s[maxn],k[maxn],b[maxn],f[maxn];ll y(int id,ll x){    return k[id]*x+b[id];}void insert(int l,int r,int id,int &amp;cur){    if(!cur)\t{\t\tnum[cur=++tot]=id;\t\treturn;\t}\tif(y(id,mid)&lt;y(num[cur],mid)) swap(id,num[cur]);\tif(y(id,l)&gt;=y(num[cur],l)&amp;&amp;y(id,r)&gt;=y(num[cur],r)) return;\tif(y(id,l)&lt;y(num[cur],l)) insert(l,mid,id,ls[cur]);\telse insert(mid+1,r,id,rs[cur]);}ll query(int l,int r,int x,int cur){    if(!cur) return inf;    ll v=y(num[cur],x);    if(x&lt;=mid) v=min(v,query(l,mid,x,ls[cur]));    else v=min(v,query(mid+1,r,x,rs[cur]));    return v;}int main(){    read(n);    for(int i=1;i&lt;=n;++i) read(h[i]);    for(int i=1;i&lt;=n;++i) read(s[i]),s[i]+=s[i-1];    for(int i=1;i&lt;=n;++i)    {        if(i!=1) f[i]=query(0,all,h[i],root)+h[i]*h[i]+s[i-1];        k[i]=-2*h[i],b[i]=f[i]+h[i]*h[i]-s[i],insert(0,all,i,root);    }    printf(\"%lld\",f[n]);    return 0;}\r\n重链剖分\r\n#include&lt;bits/stdc++.h&gt;#define maxn 400010#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,rt,root=1,cnt;ll p;int siz[maxn],fa[maxn],dfn[maxn],top[maxn],son[maxn],dep[maxn],rev[maxn];ll a[maxn],sum[maxn],tag[maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void pushup(int cur){\tsum[cur]=(sum[ls]+sum[rs])%p;}void pushtag(int cur,int l,int r,ll v){\tsum[cur]=(sum[cur]+v*(r-l+1)%p)%p,tag[cur]=(tag[cur]+v)%p;}void pushdown(int cur,int l,int r){\tif(!tag[cur]) return;\tpushtag(ls,l,mid,tag[cur]),pushtag(rs,mid+1,r,tag[cur]),tag[cur]=0;}void build(int l,int r,int cur){\tif(l==r)\t{\t\tsum[cur]=a[rev[l]];\t\treturn;\t}\tbuild(l,mid,ls),build(mid+1,r,rs),pushup(cur);}void modify(int L,int R,int l,int r,int v,int cur){\tif(L&lt;=l&amp;&amp;R&gt;=r)\t{\t\tpushtag(cur,l,r,v);\t\treturn;\t}\tpushdown(cur,l,r);\tif(L&lt;=mid) modify(L,R,l,mid,v,ls);\tif(R&gt;mid) modify(L,R,mid+1,r,v,rs);\tpushup(cur);}ll query(int L,int R,int l,int r,int cur){\tif(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];\tll v=0;    pushdown(cur,l,r);\tif(L&lt;=mid) v=(v+query(L,R,l,mid,ls))%p;\tif(R&gt;mid) v=(v+query(L,R,mid+1,r,rs))%p;\treturn v;}void update(int x,int y,int v){\twhile(top[x]!=top[y])\t{\t\tif(dep[top[x]]&lt;dep[top[y]]) swap(x,y);\t\tmodify(dfn[top[x]],dfn[x],1,n,v,root),x=fa[top[x]];\t}\tif(dep[x]&gt;dep[y]) swap(x,y);\tmodify(dfn[x],dfn[y],1,n,v,root);}ll ask(int x,int y){\tll v=0;\twhile(top[x]!=top[y])\t{\t\tif(dep[top[x]]&lt;dep[top[y]]) swap(x,y);\t\tv=(v+query(dfn[top[x]],dfn[x],1,n,root))%p,x=fa[top[x]];\t}\tif(dep[x]&gt;dep[y]) swap(x,y);\treturn (v+query(dfn[x],dfn[y],1,n,root))%p;}void dfs_son(int x,int fath){\tfa[x]=fath,dep[x]=dep[fath]+1,siz[x]=1;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fath) continue;\t\tdfs_son(y,x),siz[x]+=siz[y];\t\tif(siz[y]&gt;siz[son[x]]) son[x]=y;\t}}void dfs_chain(int x,int tp){\tdfn[x]=++cnt,rev[cnt]=x,top[x]=tp;\tif(son[x]) dfs_chain(son[x],tp);\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(dfn[y]) continue;\t\tdfs_chain(y,y);\t}}int main(){ \tread(n),read(m),read(rt),read(p);\tfor(int i=1;i&lt;=n;++i) read(a[i]);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs_son(rt,0),dfs_chain(rt,rt),build(1,n,root);\twhile(m--)\t{\t\tint opt,x,y,v;\t\tread(opt),read(x);\t\tif(opt==1) read(y),read(v),update(x,y,v);\t\tif(opt==2) read(y),printf(\"%lld\\n\",ask(x,y));\t\tif(opt==3) read(v),modify(dfn[x],dfn[x]+siz[x]-1,1,n,v,root);\t\tif(opt==4) printf(\"%lld\\n\",query(dfn[x],dfn[x]+siz[x]-1,1,n,root));\t}\treturn 0;}\r\n主席树\r\n静态区间第  小。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot,num;int a[maxn],s[maxn],rt[maxn],cnt[maxm],ls[maxm],rs[maxm];void modify(int l,int r,int pos,int &amp;cur){    int x=++tot;    ls[x]=ls[cur],rs[x]=rs[cur],cnt[x]=cnt[cur]+1,cur=x;    if(l==r) return;    if(pos&lt;=mid) modify(l,mid,pos,ls[cur]);    else modify(mid+1,r,pos,rs[cur]);}int query(int l,int r,int k,int x,int y){    if(l==r) return l;    if(k&gt;cnt[ls[y]]-cnt[ls[x]]) return query(mid+1,r,k-cnt[ls[y]]+cnt[ls[x]],rs[x],rs[y]);    return query(l,mid,k,ls[x],ls[y]);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]),s[i]=a[i];    sort(s+1,s+n+1),num=unique(s+1,s+n+1)-s-1;    for(int i=1;i&lt;=n;++i) rt[i]=rt[i-1],modify(1,num,lower_bound(s+1,s+num+1,a[i])-s,rt[i]);    while(m--)    {        int l,r,k;        read(l),read(r),read(k);        printf(\"%d\\n\",s[query(1,num,k,rt[l-1],rt[r])]);    }    return 0;}\r\n可持久化并查集\r\n合并不采用路径压缩，保证每次合并只修改一个节点的父亲，使当前版本与上一版本共用的节点尽可能的多。为防止并查集退化成链，采取按秩合并。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 10000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,tree_cnt;int ls[maxn],rs[maxn],root[maxn],a[maxn],fa[maxn],de[maxn];void build(int L,int R,int &amp;cur){\tcur=++tree_cnt;\tif(L==R)\t{\t\tfa[cur]=L;\t\treturn;\t}\tint mid=(L+R)&gt;&gt;1;\tbuild(L,mid,ls[cur]);\tbuild(mid+1,R,rs[cur]);}void merge(int L,int R,int pos,int fath,int pre,int &amp;cur){\tcur=++tree_cnt;\tif(L==R)\t{\t\tfa[cur]=fath;\t\tde[cur]=de[pre];\t\treturn;\t}\tls[cur]=ls[pre],rs[cur]=rs[pre];\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) merge(L,mid,pos,fath,ls[pre],ls[cur]);\tif(pos&gt;mid) merge(mid+1,R,pos,fath,rs[pre],rs[cur]);}int query(int L,int R,int pos,int cur){\tif(L==R) return cur;\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) return query(L,mid,pos,ls[cur]);\tif(pos&gt;mid) return query(mid+1,R,pos,rs[cur]);}void add(int L,int R,int pos,int cur){\tif(L==R)\t{\t\tde[cur]++;\t\treturn;\t}\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) add(L,mid,pos,ls[cur]);\telse add(mid+1,R,pos,rs[cur]);}int find(int pos,int cur){\tint fath=query(1,n,pos,cur);\tif(pos==fa[fath]) return fath;\treturn find(fa[fath],cur);}int main(){\tread(n),read(m);\tbuild(1,n,root[0]);\tfor(int i=1;i&lt;=m;i++)\t{\t\tint flag,a,b;\t\tread(flag);\t\tif(flag==1)\t\t{\t\t\tread(a),read(b);\t\t\troot[i]=root[i-1];\t\t\tint u=find(a,root[i]),v=find(b,root[i]);\t\t\tif(fa[u]==fa[v]) continue;\t\t\tif(de[u]&gt;de[v]) swap(u,v);\t\t\tmerge(1,n,fa[u],fa[v],root[i-1],root[i]);\t\t\tif(de[u]==de[v]) add(1,n,fa[v],root[i]);\t\t}\t\tif(flag==2)\t\t{\t\t\tread(a);\t\t\troot[i]=root[a];\t\t}\t\tif(flag==3)\t\t{\t\t\tread(a),read(b);\t\t\troot[i]=root[i-1];\t\t\tint u=find(a,root[i]),v=find(b,root[i]);\t\t\tif(fa[u]==fa[v]) puts(\"1\");\t\t\telse puts(\"0\");\t\t}\t}\treturn 0;}\r\n平衡树\r\n插入 ，删除 ，查  的排名，查排名为  的数，查  的前驱，查  的后继。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,last,ans,tot,root;int ls[maxn],rs[maxn],siz[maxn],key[maxn],val[maxn];int add(int v){\tval[++tot]=v,key[tot]=rand(),siz[tot]=1;\treturn tot;}void pushup(int x){\tsiz[x]=siz[ls[x]]+siz[rs[x]]+1;}void merge(int &amp;p,int x,int y){\tif(!x||!y)\t{\t\tp=x+y;\t\treturn;\t}\tif(key[x]&lt;key[y]) p=x,merge(rs[x],rs[x],y);\telse p=y,merge(ls[y],x,ls[y]);\tpushup(p);}void split(int p,int k,int &amp;x,int &amp;y){\tif(!p)\t{\t\tx=y=0;\t\treturn;\t}\tif(val[p]&lt;=k) x=p,split(rs[p],k,rs[x],y);\telse y=p,split(ls[p],k,x,ls[y]);\tpushup(p);}void insert(int v){\tint x,y;    split(root,v,x,y),merge(x,x,add(v)),merge(root,x,y);}void del(int v){\tint x,y,z;    split(root,v,x,y),split(x,v-1,x,z);    merge(z,ls[z],rs[z]),merge(x,x,z),merge(root,x,y);}int kth(int v){\tint x,y;    split(root,v-1,x,y);    int ans=siz[x]+1;    merge(root,x,y);    return ans;}int get(int p,int k){    if(k==siz[ls[p]]+1) return val[p];    if(k&lt;=siz[ls[p]]) return get(ls[p],k);    else return get(rs[p],k-siz[ls[p]]-1);}int pre(int v){\tint x,y;    split(root,v-1,x,y);    int ans=get(x,siz[x]);    merge(root,x,y);    return ans;}int nxt(int v){\tint x,y;    split(root,v,x,y);    int ans=get(y,1);    merge(root,x,y);    return ans;}int main(){    read(n),read(m);    for(int i=1,a;i&lt;=n;++i) read(a),insert(a);\twhile(m--)\t{\t\tint opt,a;\t\tread(opt),read(a),a^=last;\t\tif(opt==1) insert(a);\t\tif(opt==2) del(a);\t\tif(opt==3) last=kth(a);\t\tif(opt==4) last=get(root,a);\t\tif(opt==5) last=pre(a);\t\tif(opt==6) last=nxt(a);        if(opt!=1&amp;&amp;opt!=2) ans^=last;\t}    printf(\"%d\",ans);\treturn 0;}\r\n插入多个数，删除多个数，区间赋值，区间翻转，区间求和，区间最大子序列。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010#define inf 500000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,tot,root,top;int fa[maxn],siz[maxn],ch[maxn][2],tag[maxn],rev[maxn],st[maxn];int val[maxn],sum[maxn],ma[maxn],a[maxn],lm[maxn],rm[maxn],c[maxn];string opt;bool check(int x){    return ch[fa[x]][1]==x;}void pushup(int x){    int ls=ch[x][0],rs=ch[x][1];    siz[x]=siz[ls]+siz[rs]+1;    sum[x]=sum[ls]+sum[rs]+val[x];    lm[x]=max(lm[ls],sum[ls]+val[x]+lm[rs]);    rm[x]=max(rm[rs],sum[rs]+val[x]+rm[ls]);    ma[x]=max(val[x]+lm[rs]+rm[ls],max(ma[ls],ma[rs]));}void pushr(int x){    rev[x]^=1,swap(ch[x][0],ch[x][1]),swap(lm[x],rm[x]);}void pushv(int x,int v){    if(!x) return;    tag[x]=1,val[x]=v,sum[x]=v*siz[x];    lm[x]=rm[x]=max(sum[x],0),ma[x]=max(sum[x],val[x]);}void pushdown(int x){    int ls=ch[x][0],rs=ch[x][1];    if(tag[x]) pushv(ls,val[x]),pushv(rs,val[x]);    if(rev[x]) pushr(ls),pushr(rs);    tag[x]=rev[x]=0;}int add(){    int x=top?st[top--]:++tot;    fa[x]=ch[x][0]=ch[x][1]=rev[x]=siz[x]=tag[x]=0;    return x;}void build(int l,int r,int &amp;x,int *a){    x=add();    int mid=(l+r)&gt;&gt;1;    lm[x]=rm[x]=max(a[mid],0);    val[x]=ma[x]=sum[x]=a[mid];    if(l&lt;mid) build(l,mid-1,ch[x][0],a);    if(r&gt;mid) build(mid+1,r,ch[x][1],a);    fa[ch[x][0]]=fa[ch[x][1]]=x;    pushup(x);}void rotate(int x){    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];    ch[z][check(y)]=x,fa[x]=z;    ch[y][k]=w,fa[w]=y;    ch[x][k^1]=y,fa[y]=x;    pushup(y),pushup(x);}void splay(int x,int goal){    for(int y;fa[x]!=goal;rotate(x))        if(fa[y=fa[x]]!=goal)            rotate(check(x)^check(y)?x:y);    if(!goal) root=x;}int kth(int x){    int p=root;    while(1)    {        pushdown(p);        int ls=ch[p][0],rs=ch[p][1];        if(ls&amp;&amp;x&lt;=siz[ls]) p=ls;        else        {            x-=siz[ls]+1;            if(!x) return p;            p=rs;        }    }}void split(int l,int r){    l=kth(l-1),r=kth(r+1),splay(l,0),splay(r,l);}void insert(int x,int num){    int t,p;    build(1,num,t,c);    split(x+1,x);    p=ch[root][1];    ch[p][0]=t,fa[t]=p;    pushup(p),pushup(root);}void del(int x){    if(!x) return;    st[++top]=x;    del(ch[x][0]),del(ch[x][1]);}void erase(int l,int r){    int p;    split(l,r);    p=ch[root][1];    del(ch[p][0]),ch[p][0]=0;    pushup(p),pushup(root);}void cover(int l,int r,int v){    int p;    split(l,r);    p=ch[root][1];    pushv(ch[p][0],v);    pushup(p),pushup(root);}void reverse(int l,int r){    int p;    split(l,r);    p=ch[root][1];    pushr(ch[p][0]);    pushup(p),pushup(root);}int query(int l,int r){    int p;    split(l,r);    p=ch[root][1];    return sum[ch[p][0]];}int main(){\tread(n),read(m);    ma[0]=a[1]=a[n+2]=-inf;    for(int i=2;i&lt;=n+1;++i) read(a[i]);    build(1,n+2,root,a);    while(m--)    {        cin&gt;&gt;opt;        int x,num,v;        if(opt==\"MAX-SUM\") printf(\"%d\\n\",ma[root]);        else read(x),read(num),x++;        if(opt==\"INSERT\")        {            for(int i=1;i&lt;=num;++i) read(c[i]);            insert(x,num);        }        if(opt==\"DELETE\") erase(x,x+num-1);        if(opt==\"MAKE-SAME\") read(v),cover(x,x+num-1,v);        if(opt==\"REVERSE\") reverse(x,x+num-1);        if(opt==\"GET-SUM\") printf(\"%d\\n\",query(x,x+num-1));    }\treturn 0;}\r\n可持久化平衡树\r\n#include&lt;bits/stdc++.h&gt;#define maxn 25000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,flag,tot,v,x,y,z;int ls[maxn],rs[maxn],siz[maxn],key[maxn],val[maxn],root[maxn];int build(int x){\tval[++tot]=x;\tsiz[tot]=1;\tkey[tot]=rand();\treturn tot;}void pushup(int x){\tsiz[x]=siz[ls[x]]+siz[rs[x]]+1;}int cpy(int x){\ttot++;\tval[tot]=val[x];\tsiz[tot]=siz[x];\tkey[tot]=key[x];\tls[tot]=ls[x];\trs[tot]=rs[x];\treturn tot;}void merge(int &amp;p,int x,int y){    if(!x||!y)    {           p=x+y;        return;    }    if(key[x]&lt;key[y]) p=cpy(x),merge(rs[p],rs[p],y);    else p=cpy(y),merge(ls[p],x,ls[p]);    pushup(p);}void split(int p,int k,int &amp;x,int &amp;y){\tif(!p)\t{\t\tx=y=0;\t\treturn;\t}\tif(val[p]&lt;=k)\t{\t\tx=cpy(p);\t\tsplit(rs[x],k,rs[x],y);\t\tpushup(x);\t}\telse\t{\t\ty=cpy(p);\t\tsplit(ls[y],k,x,ls[y]);\t\tpushup(y);\t}}int query(int p,int k){\tif(k==siz[ls[p]]+1) return val[p];\tif(k&lt;=siz[ls[p]]) return query(ls[p],k);\telse return query(rs[p],k-siz[ls[p]]-1);}int main(){\tread(n);\tfor(int i=1;i&lt;=n;++i)\t{\t\tint a;\t\tread(v),read(flag),read(a);\t\troot[i]=root[v];\t\tif(flag==1)\t\t{\t\t\tsplit(root[i],a,x,y);\t\t\tmerge(x,x,build(a));\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==2)\t\t{\t\t\tsplit(root[i],a,x,y);\t\t\tsplit(x,a-1,x,z);\t\t\tmerge(z,ls[z],rs[z]);\t\t\tmerge(x,x,z);\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==3)\t\t{\t\t\tsplit(root[i],a-1,x,y);\t\t\tprintf(\"%d\\n\",siz[x]+1);\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==4)\t\t\tprintf(\"%d\\n\",query(root[i],a));\t\tif(flag==5)\t\t{\t\t \tsplit(root[i],a-1,x,y);\t\t\tif(!siz[x]) puts(\"-2147483647\");\t\t\tprintf(\"%d\\n\",query(x,siz[x]));\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==6)\t\t{\t\t \tsplit(root[i],a,x,y);\t\t\tif(!siz[y]) puts(\"2147483647\");\t\t\telse printf(\"%d\\n\",query(y,1));\t\t\tmerge(root[i],x,y);\t\t}\t \t}\treturn 0;}\r\nLCT\r\n#include&lt;bits/stdc++.h&gt;#define maxn 300010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int fa[maxn],ch[maxn][2],rev[maxn],val[maxn],sum[maxn];bool check(int x){\treturn ch[fa[x]][1]==x;}bool notroot(int x){\treturn ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void pushup(int x){\tsum[x]=sum[ch[x][0]]^sum[ch[x][1]]^val[x];\t}void pushrev(int x){\tswap(ch[x][0],ch[x][1]),rev[x]^=1;}void pushdown(int x){\tif(rev[x]) pushrev(ch[x][0]),pushrev(ch[x][1]),rev[x]=0;}void rotate(int x){\tint y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];\tif(notroot(y)) ch[z][check(y)]=x;\tch[x][k^1]=y,ch[y][k]=w;\tif(w) fa[w]=y;\tfa[x]=z,fa[y]=x;\tpushup(y),pushup(x);}void all(int x){\tif(notroot(x)) all(fa[x]);\tpushdown(x);}void splay(int x){\tall(x);\tfor(int y;notroot(x);rotate(x))\t\tif(notroot(y=fa[x]))\t\t\trotate(check(x)^check(y)?x:y);\tpushup(x);}void access(int x){\tfor(int y=0;x;y=x,x=fa[x])\t\tsplay(x),ch[x][1]=y,pushup(x);}void makeroot(int x){\taccess(x),splay(x),pushrev(x);}void split(int x,int y){\tmakeroot(x),access(y),splay(y);}int findroot(int x){\taccess(x),splay(x);\twhile(ch[x][0]) pushdown(x),x=ch[x][0];\tsplay(x);\treturn x;}void link(int x,int y){\tmakeroot(x);\tif(findroot(y)!=x) fa[x]=y;}void cut(int x,int y){\tsplit(x,y);\tif(ch[y][0]==x&amp;&amp;!ch[x][1]) fa[x]=ch[y][0]=0;}int query(int x,int y){\tsplit(x,y);\treturn sum[y];}int main(){\tread(n),read(m);\tfor(int i=1;i&lt;=n;++i) read(val[i]);\twhile(m--)\t{\t\tint opt,x,y;\t\tread(opt),read(x),read(y);\t\tif(opt==0) printf(\"%d\\n\",query(x,y));\t\tif(opt==1) link(x,y);\t\tif(opt==2) cut(x,y);\t\tif(opt==3) splay(x),val[x]=y;\t}    return 0;}\r\n树套树\r\n三维偏序，线段树套树状数组。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define lowbit(x) (x&amp;(-x))#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt,tot;int ans[maxn],rt[maxn],sum[maxm],ls[maxm],rs[maxm];struct node{    int a,b,c,val;}p[maxn];bool cmp(const node &amp;x,const node &amp;y){    if(x.a==y.a)    {        if(x.b==y.b) return x.c&lt;y.c;        return x.b&lt;y.b;    }    return x.a&lt;y.a;}void modify(int l,int r,int pos,int v,int &amp;cur){\tif(!cur) cur=++tot;\tsum[cur]+=v;\tif(l==r) return;\tif(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);\telse modify(mid+1,r,pos,v,rs[cur]);}int query(int L,int R,int l,int r,int cur){\tif(!cur) return 0;\tif(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];\tint v=0;\tif(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);\tif(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);\treturn v;}void update(int x,int c,int v){\twhile(x&lt;=m) modify(1,m,c,v,rt[x]),x+=lowbit(x);}int ask(int x,int c){\tint v=0;\twhile(x) v+=query(1,c,1,m,rt[x]),x-=lowbit(x);\treturn v;}void init(){    int pos;    sort(p+1,p+n+1,cmp);    for(int i=1;i&lt;=n;i=pos+1)    {        pos=i;        while(pos&lt;n&amp;&amp;p[i].a==p[pos+1].a&amp;&amp;p[i].b==p[pos+1].b&amp;&amp;p[i].c==p[pos+1].c) pos++;        p[++cnt]=p[i],p[cnt].val=pos-i+1;    }}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(p[i].a),read(p[i].b),read(p[i].c);    init();    for(int i=1;i&lt;=cnt;++i)\t{\t\tans[ask(p[i].b,p[i].c)+p[i].val-1]+=p[i].val;\t\tupdate(p[i].b,p[i].c,p[i].val);\t}    for(int i=0;i&lt;n;++i) printf(\"%d\\n\",ans[i]);    return 0;}\r\n线段树套平衡树。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 20000010#define inf 2147483647using namespace std;typedef long long ll; template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}template&lt;typename T&gt; inline void write(T x){    short st[30],tp=0;    if(x&lt;0) putchar('-'),x=-x;    do st[++tp]=x%10,x/=10; while(x);    while(tp) putchar('0'|st[tp--]);}int n,m,tot;int a[maxn],val[maxn],key[maxn],siz[maxn],ls[maxn],rs[maxn];struct FHQ_Treap{    int root,x,y,z;    int add(int x)    {        val[++tot]=x;        siz[tot]=1;        key[tot]=rand();        return tot;    }    void pushup(int x)    {        siz[x]=siz[ls[x]]+siz[rs[x]]+1;    }    void merge(int &amp;p,int x,int y)    {        if(!x||!y)        {               p=x+y;            return;        }        if(key[x]&lt;key[y]) p=x,merge(rs[p],rs[p],y);        else p=y,merge(ls[p],x,ls[p]);        pushup(p);    }    void split(int p,int k,int &amp;x,int &amp;y)    {        if(!p)        {            x=y=0;            return;        }        if(val[p]&lt;=k) x=p,split(rs[p],k,rs[p],y);        else y=p,split(ls[p],k,x,ls[p]);        pushup(p);    }    void insert(int v)    {        split(root,v,x,y);        merge(x,x,add(v));        merge(root,x,y);    }    void del(int v)    {        split(root,v,x,y);        split(x,v-1,x,z);        merge(z,ls[z],rs[z]);        merge(x,x,z);        merge(root,x,y);    }    void build(int l,int r)    {        for(int i=l;i&lt;=r;++i) insert(a[i]);    }    int kth(int v)    {        split(root,v-1,x,y);        int ans=siz[x]+1;        merge(root,x,y);        return ans;    }    int get(int p,int k)    {        if(k==siz[ls[p]]+1) return val[p];        if(k&lt;=siz[ls[p]]) return get(ls[p],k);        else return get(rs[p],k-siz[ls[p]]-1);    }    int pre(int v)    {        split(root,v-1,x,y);        int ans;        if(siz[x]) ans=get(x,siz[x]);        else ans=-inf;        merge(root,x,y);        return ans;    }    int nxt(int v)    {        split(root,v,x,y);        int ans;        if(siz[y]) ans=get(y,1);        else ans=inf;        merge(root,x,y);        return ans;    }}treap[maxn];int tree_cnt,root;int lc[maxn],rc[maxn];struct Segment_Tree{    void build(int l,int r,int &amp;cur)    {        cur=++tree_cnt;        treap[cur].build(l,r);        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(l,mid,lc[cur]),build(mid+1,r,rc[cur]);    }    int q_rnk(int L,int R,int l,int r,int k,int cur)    {        if(L&lt;=l&amp;&amp;R&gt;=r)  return treap[cur].kth(k)-1;        int mid=(l+r)&gt;&gt;1,ans=0;        if(L&lt;=mid) ans+=q_rnk(L,R,l,mid,k,lc[cur]);        if(R&gt;mid) ans+=q_rnk(L,R,mid+1,r,k,rc[cur]);        return ans;    }    int q_val(int L,int R,int rnk)    {        int l=0,r=1e8,ans;        while(l&lt;=r)        {            int mid=(l+r)&gt;&gt;1;            if(q_rnk(L,R,1,n,mid,root)+1&lt;=rnk) ans=mid,l=mid+1;            else r=mid-1;        }        return ans;    }    void modify(int l,int r,int pos,int k,int cur)    {        treap[cur].del(a[pos]),treap[cur].insert(k);        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        if(pos&lt;=mid) modify(l,mid,pos,k,lc[cur]);        if(pos&gt;mid) modify(mid+1,r,pos,k,rc[cur]);    }    int lower(int L,int R,int l,int r,int k,int cur)    {        if(L&gt;r||R&lt;l) return -inf;        if(L&lt;=l&amp;&amp;R&gt;=r) return treap[cur].pre(k);        int mid=(l+r)&gt;&gt;1;        return max(lower(L,R,l,mid,k,lc[cur]),lower(L,R,mid+1,r,k,rc[cur]));    }    int upper(int L,int R,int l,int r,int k,int cur)    {        if(L&gt;r||R&lt;l) return inf;        if(L&lt;=l&amp;&amp;R&gt;=r) return treap[cur].nxt(k);        int mid=(l+r)&gt;&gt;1;        return min(upper(L,R,l,mid,k,lc[cur]),upper(L,R,mid+1,r,k,rc[cur]));    }}tree;int main(){\tread(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    tree.build(1,n,root);    for(int i=1;i&lt;=m;++i)    {        int opt,l,r,p,k;        read(opt);        if(opt==1)        {            read(l),read(r),read(k);            write(tree.q_rnk(l,r,1,n,k,root)+1),puts(\"\");        }        if(opt==2)        {            read(l),read(r),read(k);            write(tree.q_val(l,r,k)),puts(\"\");        }        if(opt==3)        {            read(p),read(k);            tree.modify(1,n,p,k,root),a[p]=k;        }        if(opt==4)        {            read(l),read(r),read(k);            write(tree.lower(l,r,1,n,k,root)),puts(\"\");        }        if(opt==5)        {            read(l),read(r),read(k);            write(tree.upper(l,r,1,n,k,root)),puts(\"\");        }    }\treturn 0;}\r\nCDQ 分治\r\n三维偏序。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define lowbit(x) (x&amp;(-x))using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,k,cnt,tot;int num[maxn],tree[maxn];struct node{\tint a,b,c,val,ans;}p[maxn],q[maxn];bool cmp1(node x,node y){    if(x.a==y.a)    {        if(x.b==y.b) return x.c&lt;y.c;        return x.b&lt;y.b;    }    return x.a&lt;y.a;}bool cmp2(node x,node y){    if(x.b==y.b) return x.c&lt;y.c;    return x.b&lt;y.b;}void update(int x,int v){\twhile(x&lt;=k)\t{\t\ttree[x]+=v;\t\tx+=lowbit(x);\t}}int query(int x){\tint sum=0;\twhile(x)\t{\t\tsum+=tree[x];\t\tx-=lowbit(x);\t}\treturn sum;}void cdq(int l,int r){\tif(l==r) return;\tint mid=(l+r)&gt;&gt;1;\tcdq(l,mid),cdq(mid+1,r);\tsort(q+l,q+mid+1,cmp2);\tsort(q+mid+1,q+r+1,cmp2);\tint j=l;\tfor(int i=mid+1;i&lt;=r;++i)\t{\t\twhile(q[j].b&lt;=q[i].b&amp;&amp;j&lt;=mid)\t\t{\t\t\tupdate(q[j].c,q[j].val);\t\t\tj++;\t\t}\t\tq[i].ans+=query(q[i].c);\t}\tfor(int i=l;i&lt;j;++i) update(q[i].c,-q[i].val);}int main(){\tread(n),read(k);\tfor(int i=1;i&lt;=n;++i)\t\tread(p[i].a),read(p[i].b),read(p[i].c);\tsort(p+1,p+n+1,cmp1);\tfor(int i=1;i&lt;=n;++i)\t{\t\tcnt++;\t\tif(p[i].a!=p[i+1].a||p[i].b!=p[i+1].b||p[i].c!=p[i+1].c)\t\t{\t\t\tq[++tot]=p[i];\t\t\tq[tot].val=cnt;\t\t\tcnt=0;\t\t}\t}\tcdq(1,tot);\tfor(int i=1;i&lt;=tot;++i)\t\tnum[q[i].ans+q[i].val-1]+=q[i].val;\tfor(int i=0;i&lt;n;++i) printf(\"%d\\n\",num[i]);\treturn 0;}\r\n分块\r\nvoid modify(int l,int r,ll v){    for(int i=l;i&lt;=min(S*bel[l],r);++i) a[i]+=v,sum[bel[l]]+=v;    if(bel[l]!=bel[r])        for(int i=S*(bel[r]-1)+1;i&lt;=r;++i)            a[i]+=v,sum[bel[r]]+=v;    for(int i=bel[l]+1;i&lt;=bel[r]-1;++i) add[i]+=v;}ll query(int l,int r){    ll ans=0;    for(int i=l;i&lt;=min(S*bel[l],r);++i) ans+=a[i]+add[bel[l]];    if(bel[l]!=bel[r])        for(int i=S*(bel[r]-1)+1;i&lt;=r;++i)            ans+=a[i]+add[bel[r]];    for(int i=bel[l]+1;i&lt;=bel[r]-1;++i) ans+=sum[i]+S*add[i];    return ans;}......for(int i=1;i&lt;=n;++i)\tread(a[i]),bel[i]=(i-1)/S+1,sum[bel[i]]+=a[i];\r\n点分治\r\n求出树上两点距离小于等于 \r\n的点对数量。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 80010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,k,root,tot,cnt;ll ans;int siz[maxn],mx[maxn],len[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void dfs_root(int x,int fa){    siz[x]=1,mx[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa||vis[y]) continue;        dfs_root(y,x),siz[x]+=siz[y];        mx[x]=max(mx[x],siz[y]);    }    mx[x]=max(mx[x],tot-siz[x]);    if(mx[x]&lt;mx[root]) root=x;}void dfs_get(int x,int fa,int dis){    len[++cnt]=dis;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa||vis[y]) continue;        dfs_get(y,x,dis+e[i].v);    }}ll calc(int x,int dis){    cnt=0,dfs_get(x,0,dis),sort(len+1,len+cnt+1);    ll v=0,pos=cnt;    for(int i=1;i&lt;=cnt;++i)    {        while(pos&amp;&amp;len[i]+len[pos]&gt;k) pos--;        v+=pos-(i&lt;=pos);    }    return v/2;}void solve(int x){    int now=tot;    vis[x]=true,ans+=calc(x,0);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]) continue;        ans-=calc(y,e[i].v);        root=0,tot=siz[y]&gt;siz[x]?now-siz[x]:siz[y];        dfs_root(y,x),solve(root);    }}int main(){    read(n);    for(int i=1;i&lt;n;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    read(k),tot=mx[0]=n,dfs_root(1,0),solve(root),printf(\"%lld\",ans);    return 0;}\r\n点分树\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,dfn_cnt,tot,root,ans;int v[maxn],de[maxn],fa[maxn],ma[maxn],siz[maxn],si[maxn];int pos[maxn],f[maxn][20],lg[maxn];bool vis[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}struct node{    int tree_cnt;    int ls[maxm],rs[maxm],rt[maxn],sum[maxm];    void modify(int l,int r,int pos,int v,int &amp;cur)    {        if(!cur) cur=++tree_cnt;        sum[cur]+=v;        if(l==r) return;        if(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);        else modify(mid+1,r,pos,v,rs[cur]);    }    int query(int L,int R,int l,int r,int cur)    {        if(L&gt;R||!cur) return 0;        if(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];        int v=0;        if(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);        if(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);        return v;    }}T1,T2;void dfs_pre(int x,int fa){    de[x]=de[fa]+1,f[++dfn_cnt][0]=de[x],pos[x]=dfn_cnt;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_pre(y,x),f[++dfn_cnt][0]=de[x];    }}void st(){    lg[0]=-1;    for(int i=1;i&lt;=dfn_cnt;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int j=1;j&lt;=18;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=dfn_cnt;++i)            f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);}int ask(int x,int y){    int l=pos[x],r=pos[y],len;    if(l&gt;r) swap(l,r);    len=lg[r-l+1];    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);}int dis(int x,int y){    return de[x]+de[y]-2*ask(x,y);}void dfs_root(int x,int fath){    siz[x]=1,ma[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]||y==fath) continue;        dfs_root(y,x),siz[x]+=siz[y],ma[x]=max(ma[x],siz[y]);    }    ma[x]=max(ma[x],tot-siz[x]);    if(ma[x]&lt;ma[root]) root=x;}void solve(int x){    int now=tot;    vis[x]=true,si[x]=now;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]) continue;        root=0,tot=siz[y];        if(siz[y]&gt;siz[x]) tot=now-siz[x];        dfs_root(y,x),fa[root]=x,solve(root);    }}void update(int x,int val){    T1.modify(0,si[x],0,val,T1.rt[x]);    for(int i=x;fa[i];i=fa[i])    {        T1.modify(0,si[fa[i]],dis(x,fa[i]),val,T1.rt[fa[i]]);        T2.modify(0,si[fa[i]],dis(x,fa[i]),val,T2.rt[i]);    }}int query(int x,int k){    int v=T1.query(0,k,0,si[x],T1.rt[x]);    for(int i=x;fa[i];i=fa[i])    {        v+=T1.query(0,k-dis(x,fa[i]),0,si[fa[i]],T1.rt[fa[i]]);        v-=T2.query(0,k-dis(x,fa[i]),0,si[fa[i]],T2.rt[i]);    }    return v;}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(v[i]);    for(int i=1;i&lt;n;++i)    {        int x,y;        read(x),read(y);        add(x,y),add(y,x);    }    dfs_pre(1,0),st(),tot=ma[0]=n,dfs_root(1,0),solve(root);    for(int i=1;i&lt;=n;++i) update(i,v[i]);    while(m--)    {        int opt,x,k;        read(opt),read(x),read(k),x^=ans,k^=ans;        if(!opt) printf(\"%d\\n\",ans=query(x,k));        else update(x,k-v[x]),v[x]=k;    }    return 0;}\r\n笛卡尔树\r\nvoid build(){    for(int i=1;i&lt;=n;++i)    {        while(top&amp;&amp;a[st[top]]&gt;a[i]) ls[i]=st[top--];        if(top) rs[st[top]]=i;        st[++top]=i;    }}\r\n左偏树\r\n维护 \r\n个小根堆，支持堆的合并，查询最小值。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 100010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int fa[maxn],ls[maxn],rs[maxn],dis[maxn],val[maxn];int find(int x){    return fa[x]==x?x:fa[x]=find(fa[x]);}int merge(int x,int y){\tif(!x||!y) return x+y;\tif(val[x]&gt;val[y]) swap(x,y);\trs[x]=merge(rs[x],y),fa[rs[x]]=x;\tif(dis[ls[x]]&lt;dis[rs[x]]) swap(ls[x],rs[x]);\tdis[x]=dis[rs[x]]+1;\treturn x;}void del(int x){    val[x]=-1,fa[ls[x]]=ls[x],fa[rs[x]]=rs[x];    fa[x]=merge(ls[x],rs[x]);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(val[i]),fa[i]=i;    while(m--)    {        int opt,x,y;        read(opt);        if(opt==1)        {            read(x),read(y);            if(val[x]==-1||val[y]==-1) continue;            x=find(x),y=find(y);            if(x!=y) merge(x,y);        }        else        {            read(x);            if(val[x]==-1) puts(\"-1\");            else x=find(x),printf(\"%d\\n\",val[x]),del(x);        }    }    return 0;}\r\nK-D Tree\r\n查询二维平面上欧氏距离下的第 \r\n远点对。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010#define inf 200000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,k,root,type;struct KD_tree{    ll d[2];    int mi[2],ma[2],ls,rs,id;}t[maxn];bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }}void build(int l,int r,int k,int &amp;cur){    int mid=(l+r)&gt;&gt;1;    cur=mid,type=k;    nth_element(t+l+1,t+mid+1,t+r+1,cmp);    if(l&lt;mid) build(l,mid-1,k^1,t[mid].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[mid].rs);    pushup(cur);}ll calc(ll x){    return x*x;}ll dis(int cur,ll x,ll y){    return calc(t[cur].d[0]-x)+calc(t[cur].d[1]-y);}ll dist(int cur,ll x,ll y){    return max(calc(t[cur].ma[0]-x),calc(t[cur].mi[0]-x))+max(calc(t[cur].ma[1]-y),calc(t[cur].mi[1]-y));}priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q;void query(int cur,ll x,ll y){    ll d,dl,dr;    int ls=t[cur].ls,rs=t[cur].rs;    d=dis(cur,x,y);    if(d&gt;q.top()) q.pop(),q.push(d);    if(ls) dl=dist(ls,x,y);    else dl=-inf;    if(rs) dr=dist(rs,x,y);    else dr=-inf;    if(dl&gt;q.top()) query(ls,x,y);    if(dr&gt;q.top()) query(rs,x,y);}int main(){\tread(n),read(k);    for(int i=1;i&lt;=n;++i)        read(t[i].d[0]),read(t[i].d[1]);    build(1,n,0,root);    for(int i=1;i&lt;=2*k;++i) q.push(0);    for(int i=1;i&lt;=n;++i)        query(root,t[i].d[0],t[i].d[1]);    printf(\"%lld\",q.top());\treturn 0;}\r\n查询二维平面上满足 （每次询问给出 ）的点的权值和。\r\nstruct KD_tree{    int d[2],mi[2],ma[2],ls,rs,id;    ll val,sum;}t[maxn],dat[maxn];bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }    t[cur].sum=t[ls].sum+t[rs].sum+t[cur].val;}void build(int l,int r,int k,int &amp;cur){    cur=++tot,type=k;    int mid=(l+r)&gt;&gt;1;    nth_element(dat+l,dat+mid,dat+r+1,cmp);    t[cur]=dat[mid];    if(l&lt;mid) build(l,mid-1,k^1,t[cur].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[cur].rs);    pushup(cur);}bool check(ll x,ll y){    return a*x+b*y&lt;c;}ll query(int cur){    ll ans=0;    int ls=t[cur].ls,rs=t[cur].rs,cnt=0;    cnt+=check(t[cur].ma[0],t[cur].ma[1]);    cnt+=check(t[cur].ma[0],t[cur].mi[1]);    cnt+=check(t[cur].mi[0],t[cur].mi[1]);    cnt+=check(t[cur].mi[0],t[cur].ma[1]);    if(cnt==4) return t[cur].sum;    if(!cnt) return 0;    if(check(t[cur].d[0],t[cur].d[1])) ans+=t[cur].val;    if(ls) ans+=query(ls);    if(rs) ans+=query(rs);    return ans;}\r\n支持插入点和查询二维平面上矩形内所有点的权值和，强制在线，用 \r\n实现，当不平衡时，像替罪羊树一样重构。\r\nstruct KD_tree{    int d[2],mi[2],ma[2],ls,rs,val,sum,siz;}t[maxn],dat[maxn],p;bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}int add(){    if(top) return st[top--];    return ++tot;}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }    t[cur].sum=t[ls].sum+t[rs].sum+t[cur].val;    t[cur].siz=t[ls].siz+t[rs].siz+1;}void build(int l,int r,int k,int &amp;cur){    cur=add(),type=k;    int mid=(l+r)&gt;&gt;1;    nth_element(dat+l,dat+mid,dat+r+1,cmp);    t[cur]=dat[mid];    t[cur].ls=t[cur].rs=0;    if(l&lt;mid) build(l,mid-1,k^1,t[cur].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[cur].rs);    pushup(cur);}void del(int cur){    if(!cur) return;    dat[++now]=t[cur];    st[++top]=cur;    del(t[cur].ls),del(t[cur].rs);}void check(int &amp;cur,int k){    int ls=t[cur].ls,rs=t[cur].rs;    if(t[cur].siz*alpha&lt;max(t[ls].siz,t[rs].siz))        now=0,del(cur),build(1,t[cur].siz,k,cur);}void insert(KD_tree p,int k,int &amp;cur){    if(!cur)    {        cur=add();        t[cur]=p;        t[cur].ls=t[cur].rs=0;        pushup(cur);        return;    }    if(p.d[k]&lt;=t[cur].d[k]) insert(p,k^1,t[cur].ls);    else insert(p,k^1,t[cur].rs);    pushup(cur);    check(cur,k);}bool check_p(KD_tree p){    return p.d[0]&lt;=bx&amp;&amp;p.d[0]&gt;=ax&amp;&amp;p.d[1]&lt;=by&amp;&amp;p.d[1]&gt;=ay;}bool check_in(KD_tree p){    return p.mi[0]&gt;=ax&amp;&amp;p.ma[0]&lt;=bx&amp;&amp;p.mi[1]&gt;=ay&amp;&amp;p.ma[1]&lt;=by;}bool check_out(KD_tree p){    return p.mi[0]&gt;bx||p.ma[0]&lt;ax||p.mi[1]&gt;by||p.ma[1]&lt;ay;}int query(int cur){    int ls=t[cur].ls,rs=t[cur].rs,val=t[cur].val,sum=t[cur].sum,ans=0;    if(check_in(t[cur])) return sum;    if(check_out(t[cur])) return 0;    if(check_p(t[cur])) ans+=val;    if(ls) ans+=query(ls);    if(rs) ans+=query(rs);    return ans;}\r\n图论\r\n强连通分量\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt,top,tot,ans;int dfn[maxn],low[maxn],col[maxn],st[maxn],d[maxn];int v[maxn],val[maxn],f[maxn];bool vis[maxn];struct Edge{\tint x,y;}ed[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]},head[from]=edge_cnt;}void tarjan(int x){\tdfn[x]=low[x]=++cnt,vis[st[++top]=x]=true;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);\t\telse if(vis[y]) low[x]=min(low[x],dfn[y]);\t}\tif(dfn[x]==low[x])\t{\t\ttot++;\t\tint now;\t\tdo\t\t{\t\t\tvis[now=st[top--]]=false;\t\t\tval[col[now]=tot]+=v[now]; \t\t}while(now!=x);\t}}void clear(){\tfor(int i=1;i&lt;=n;++i) head[i]=0;\tfor(int i=1;i&lt;=edge_cnt;++i) e[i].nxt=e[i].to=0;\tedge_cnt=0;}void dp(){\tqueue&lt;int&gt; q;\tfor(int i=1;i&lt;=tot;++i)\t{\t\tf[i]=val[i];\t\tif(!d[i]) q.push(i);\t}\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\td[y]--,f[y]=max(f[y],f[x]+val[y]);\t\t\tif(!d[y]) q.push(y);\t\t}\t}\tfor(int i=1;i&lt;=tot;++i) ans=max(ans,f[i]);}int main(){    read(n),read(m);\tfor(int i=1;i&lt;=n;++i) read(v[i]);\tfor(int i=1;i&lt;=m;++i)\t{\t\tread(ed[i].x),read(ed[i].y);\t\tadd(ed[i].x,ed[i].y);\t}\tfor(int i=1;i&lt;=n;++i)\t\tif(!dfn[i])\t\t\ttarjan(i);\tclear();\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x=col[ed[i].x],y=col[ed[i].y];\t\tif(x==y) continue;\t\tadd(x,y),d[y]++;\t}\tdp(),printf(\"%d\",ans);\t    return 0;}\r\n2-SAT\r\nvoid tarjan(int x){    dfn[x]=low[x]=++dfn_cnt;    st[++top]=x;    vis[x]=true;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(!dfn[y])        {            tarjan(y);            low[x]=min(low[x],low[y]);        }        else if(vis[y])            low[x]=min(low[x],dfn[y]);    }    if(low[x]==dfn[x])    {        co_cnt++;        int now;        do        {            now=st[top--];            vis[now]=false;            co[now]=co_cnt;        }while(now!=x);    }}bool check(){    for(int i=1;i&lt;=2*n;++i)        if(!dfn[i])            tarjan(i);    for(int i=1;i&lt;=n;++i)        if(co[i]==co[i+n])            return false;    return true;}......add(x+(a^1)*n,y+b*n),add(y+(b^1)*n,x+a*n);\r\n点双连通分量\r\nvoid tarjan(int x,int root){\tint son=0;\tdfn[x]=low[x]=++dfn_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y])\t\t{\t\t\ttarjan(y,root),low[x]=min(low[x],low[y]);\t\t\tif(x!=root&amp;&amp;dfn[x]&lt;=low[y]) cut[x]=true;\t\t\tif(x==root) son++;\t\t}\t\telse low[x]=min(low[x],dfn[y]);\t}\tif(son&gt;1) cut[x]=true;}......for(int i=1;i&lt;=n;++i)    if(!dfn[i])        tarjan(i,i);\r\n求割点时维护一个栈即可求出每个点双连通分量。当  满足为割点时，就依次弹栈，直到弹出\r\n 就停止， 还需留在栈中，因为割点  可能属于多个点双连通分量。\r\nvoid tarjan(int x){    dfn[x]=low[x]=++dfn_cnt,st[++top]=x;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(!dfn[y])        {            tarjan(y),low[x]=min(low[x],low[y]);            if(dfn[x]&lt;=low[y])            {                col_cnt++;                int now;                do now=st[top--],col[now]=col_cnt; while(now!=y);            }        }        else low[x]=min(low[x],dfn[y]);    }}\r\n边双连通分量\r\nvoid tarjan(int x,int link){\tdfn[x]=low[x]=++dfn_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y])\t\t{\t\t\ttarjan(y,i),low[x]=min(low[x],low[y]);\t\t\tif(dfn[x]&lt;low[y]) bri[i]=bri[i^1]=true;\t\t}\t\telse if(i!=(link^1)) low[x]=min(low[x],dfn[y]);\t}}void dfs_col(int x){\tcol[x]=co_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(col[y]||bri[i]) continue;\t\tdfs_col(y);\t}}......for(int i=1;i&lt;=n;++i)\tif(!dfn[i])\t\ttarjan(i,0);for(int i=1;i&lt;=n;++i)    if(!col[i])\t    col_cnt++,dfs_col(i);\r\n最短路\r\nspfa\r\n#include&lt;bits/stdc++.h&gt;#define maxn 15010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void spfa(){    queue&lt;int&gt; q;    for(int i=1;i&lt;=n;++i) dis[i]=inf;    q.push(s),dis[s]=0,vis[s]=true;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)            {                dis[y]=dis[x]+v;                if(!vis[y]) q.push(y),vis[y]=true;            }        }    }}int main(){    read(n),read(m),read(s),read(t);    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    spfa(),printf(\"%lld\",dis[t]);    return 0;}\r\ndijkstra\r\n#include&lt;bits/stdc++.h&gt;#define maxn 15010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void dij(){    priority_queue&lt;pair&lt;ll,int&gt; &gt; q;    for(int i=1;i&lt;=n;++i) dis[i]=inf;    q.push({0,s}),dis[s]=0;    while(!q.empty())    {        int x=q.top().second;        q.pop();        if(vis[x]) continue;        vis[x]=true;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)                dis[y]=dis[x]+v,q.push({-dis[y],y});        }    }}int main(){    read(n),read(m),read(s),read(t);    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    dij(),printf(\"%lld\",dis[t]);    return 0;}\r\n负环\r\n#include&lt;bits/stdc++.h&gt;#define maxn 10010#define inf 1000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int T,n,m;int cnt[maxn],dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;    if(val&gt;=0) e[++edge_cnt]={from,head[to],val},head[to]=edge_cnt;}bool spfa(){    for(int i=1;i&lt;=n;++i) cnt[i]=vis[i]=0,dis[i]=inf;    queue&lt;int&gt; q;    q.push(1),vis[1]=true,dis[1]=0;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        if(++cnt[x]&gt;n) return true;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)            {                dis[y]=dis[x]+v;                if(!vis[y]) q.push(y),vis[y]=true;            }        }    }    return false;}int main(){    read(T);    while(T--)    {        read(n),read(m);        edge_cnt=0,memset(head,0,sizeof(head));        for(int i=1;i&lt;=m;++i)        {            int x,y,v;            read(x),read(y),read(v);            add(x,y,v);        }        puts(spfa()?\"YES\":\"NO\");    }    return 0;}\r\nLCA\r\n重链剖分\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s;struct edge{\tint to;\tint nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=(edge){to,head[from]};\thead[from]=edge_cnt;}int fa[maxn],siz[maxn],de[maxn],son[maxn];void dfs_son(int x,int fath){\tfa[x]=fath;\tsiz[x]=1;\tde[x]=de[fath]+1;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fath) continue;\t\tdfs_son(y,x);\t\tsiz[x]+=siz[y];\t\tif(siz[y]&gt;siz[son[x]]) son[x]=y;\t}}int top[maxn],dfn[maxn];int dfn_cnt;void dfs_chain(int x,int tp){\ttop[x]=tp;\tdfn[x]=++dfn_cnt;\tif(son[x]) dfs_chain(son[x],tp);\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(dfn[y]) continue;\t\tdfs_chain(y,y);\t}}int lca(int x,int y){\twhile(top[x]!=top[y])\t{\t\tif(de[top[x]]&lt;de[top[y]]) swap(x,y);\t\tx=fa[top[x]];\t}\tif(de[x]&gt;de[y]) swap(x,y);\treturn x;}int main(){\tread(n),read(m),read(s);\tfor(int i=1;i&lt;n;++i)\t{\t\tint a,b;\t\tread(a),read(b);\t\tadd(a,b),add(b,a);\t}\tdfs_son(s,0);\tdfs_chain(s,s);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint a,b;\t\tread(a),read(b);\t\tprintf(\"%d\\n\",lca(a,b));\t}\treturn 0;}\r\nST 表\r\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,rt,cnt;int pos[maxn],dep[maxn],lg[maxn];pair&lt;int,int&gt; f[22][maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void dfs(int x,int fa){\tdep[x]=dep[fa]+1,f[0][pos[x]=++cnt]={dep[x],x};\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fa) continue;\t\tdfs(y,x),f[0][++cnt]={dep[x],x};\t}}void ST(){\tlg[0]=-1;\tfor(int i=1;i&lt;=cnt;++i) lg[i]=lg[i&gt;&gt;1]+1;\tfor(int j=1;j&lt;=19;++j)\t\tfor(int i=1;i+(1&lt;&lt;j)-1&lt;=cnt;++i)\t\t\tf[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);\t}int ask(int l,int r){\tl=pos[l],r=pos[r];\tif(l&gt;r) swap(l,r);\tint len=lg[r-l+1];\treturn min(f[len][l],f[len][r-(1&lt;&lt;len)+1]).second;}int main(){\tread(n),read(m),read(rt);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs(rt,0),ST();\twhile(m--)\t{\t\tint x,y;\t\tread(x),read(y),printf(\"%d\\n\",ask(x,y));\t}    return 0;}\r\n最大流\r\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;int d[maxn],cur[maxn];struct edge{\tint to,nxt;\tll v;\tedge(int a=0,int b=0,ll c=0)\t{\t\tto=a,nxt=b,v=c;\t}}e[maxn];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=edge(to,head[from],val),head[from]=edge_cnt;\te[++edge_cnt]=edge(from,head[to],0),head[to]=edge_cnt;}bool bfs(){\tfor(int i=1;i&lt;=n;++i) cur[i]=head[i],d[i]=0;\tqueue&lt;int&gt; q;\tq.push(s),d[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\tif(d[y]||!e[i].v) continue;\t\t\td[y]=d[x]+1,q.push(y);\t\t}\t}\treturn d[t];}ll dfs(int x,ll lim){\tif(x==t) return lim;\tll res=lim,flow;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tll v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(flow=dfs(y,min(res,v)))\t\t{\t\t\tres-=flow,e[i].v-=flow,e[i^1].v+=flow;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}ll dinic(){\tll v=0,flow;\twhile(bfs())\t\twhile(flow=dfs(s,inf))\t\t\tv+=flow;\treturn v;}int main(){\tread(n),read(m),read(s),read(t);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y,v;\t\tread(x),read(y),read(v),add(x,y,v);\t}\tprintf(\"%lld\",dinic());    return 0;}\r\n最小费用最大流\r\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll ans,sum;ll dis[maxn];bool vis[maxn];struct edge{\tint to,nxt;\tll v,c;\tedge(int x=0,int y=0,ll z=0,ll w=0)\t{\t\tto=x,nxt=y,v=z,c=w;\t}}e[maxn];int head[maxn],edge_cnt=1;void add(int from,int to,int val,int cost){\te[++edge_cnt]=edge(to,head[from],val,cost),head[from]=edge_cnt;\te[++edge_cnt]=edge(from,head[to],0,-cost),head[to]=edge_cnt;}bool bfs(){\tfor(int i=1;i&lt;=n;++i) dis[i]=inf,vis[i]=false;\tqueue&lt;int&gt; q;\tq.push(s),dis[s]=0,vis[s]=true;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop(),vis[x]=false;\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\tll c=e[i].c;\t\t\tif(dis[y]&lt;=dis[x]+c||!e[i].v) continue;\t\t\tdis[y]=dis[x]+c;\t\t\tif(!vis[y]) vis[y]=true,q.push(y);\t\t}\t}\treturn dis[t]!=inf;}ll dfs(int x,ll lim){\tif(x==t) return lim;\tvis[x]=true;\tll res=lim,flow;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tll v=e[i].v;\t\tif(dis[y]!=dis[x]+e[i].c||!v||vis[y]) continue;\t\tif(flow=dfs(y,min(res,v)))\t\t{\t\t\tres-=flow,e[i].v-=flow,e[i^1].v+=flow;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}void dinic(){\tll flow;\twhile(bfs())\t\twhile(flow=dfs(s,inf))\t\t\tans+=flow,sum+=flow*dis[t];}int main(){\tread(n),read(m),s=1,t=n;\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y,v,w;\t\tread(x),read(y),read(v),read(w);\t\tadd(x,y,v,w);\t}\tdinic(),printf(\"%lld %lld\",ans,sum);    return 0;}\r\n无源汇有上下界可行流\r\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 1002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn],low[maxn];bool bfs(){\tfor(int i=s;i&lt;=t;++i) cur[i]=head[i];\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(res&lt;=0) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,ans=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tans+=k; \t\t}\t}\treturn ans;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,high;        read(a),read(b),read(low[i]),read(high);        in[a]-=low[i],in[b]+=low[i];        add(a,b,high-low[i]);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    dinic();    if(check())     {        puts(\"YES\");        for(int i=1;i&lt;=m;i++) printf(\"%d\\n\",e[(i&lt;&lt;1)^1].v+low[i]);    }    else puts(\"NO\");\treturn 0;}\r\n有源汇有上下界最大流\r\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 1002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t,S,T,ans;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn],low[maxn];bool bfs(){\tmemcpy(cur,head,sizeof(head));\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(res&lt;=0) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,flow=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tflow+=k; \t\t}\t}\treturn flow;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),read(S),read(T),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,up;        read(a),read(b),read(low[i]),read(up);        in[a]-=low[i],in[b]+=low[i];        add(a,b,up-low[i]);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    add(T,S,inf);    dinic();    ans=e[edge_cnt].v;    e[edge_cnt].v=e[edge_cnt^1].v=0;    if(check())     {        s=S,t=T;        printf(\"%d\",ans+dinic());    }    else puts(\"please go home to sleep\");\treturn 0;}\r\n有源汇有上下界最小流\r\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define maxm 5002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t,S,T;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn];bool bfs(){\tfor(int i=0;i&lt;=n+1;++i) cur[i]=head[i];\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,flow=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tflow+=k; \t\t}\t}\treturn flow;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),read(S),read(T),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,up,low;        read(a),read(b),read(low),read(up);        in[a]-=low,in[b]+=low;        add(a,b,up-low);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    dinic();    add(T,S,inf);    dinic();    if(!check())    {        puts(\"please go home to sleep\");        return 0;    }    printf(\"%d\",e[edge_cnt].v);\treturn 0;}\r\n最大费用循环流\r\n对于边 ，若费用为正，则将其先流满，记录费用总和\r\n，通过建立源汇点来实现补流，边正常连。若费用为负，则连边\r\n。然后跑最小费用最大流得出费用\r\n，最终最大费用循环流求解的答案为\r\n。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define maxm 5000010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int T,n,m,s,t;ll ans;int in[maxn],de[maxn];ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;    ll c;}e[maxm];int head[maxn],edge_cnt;void add(int from,int to,int val,int cost){    e[++edge_cnt]=(edge){to,head[from],val,cost};\thead[from]=edge_cnt;    e[++edge_cnt]=(edge){from,head[to],0,-cost};\thead[to]=edge_cnt;}void Add(int from,int to,int val,ll cost){    in[from]+=val,in[to]-=val,ans+=cost,add(from,to,val,cost);}struct Edge{    int to,nxt,v;}ed[maxn];int hd[maxn],e_cnt;void link(int from,int to,int val){    ed[++e_cnt]=(Edge){to,hd[from],val};    hd[from]=e_cnt;}void dfs_pre(int x,int fa){\tde[x]=de[fa]+1;\tfor(int i=hd[x];i;i=ed[i].nxt)\t{\t\tint y=ed[i].to;\t\tif(y==fa) continue;        Add(x,y,ed[i].v,0),dfs_pre(y,x);\t}\t}bool spfa(){    for(int i=s;i&lt;=t;++i) vis[i]=0,dis[i]=inf;    queue&lt;int&gt; q;    q.push(s),dis[s]=0,vis[s]=true;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to;            ll v=e[i].v,c=e[i].c;            if(dis[y]&gt;dis[x]+c&amp;&amp;v)            {                dis[y]=dis[x]+c;                if(!vis[y])                {                    vis[y]=true;                    q.push(y);                }            }        }    }    return dis[t]!=inf;}ll dfs(int x,ll lim){    if(x==t) return lim;    vis[x]=true;    ll res=lim,flow;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v,c=e[i].c;        if(dis[y]!=dis[x]+c||!v||vis[y]) continue;        if(flow=dfs(y,min(res,v)))        {            res-=flow;            e[i].v-=flow;            e[i^1].v+=flow;            if(!res) break;        }    }    return lim-res;}ll dinic(){    ll flow,sum=0;    while(spfa())        while(flow=dfs(s,inf))            sum+=flow*dis[t];    return sum;}void clear(){    e_cnt=ans=0,edge_cnt=1;    memset(in,0,sizeof(in));    memset(hd,0,sizeof(hd));    memset(head,0,sizeof(head));}int main(){    read(T);    while(T--)    {        clear(),read(n),read(m),t=n+1;        for(int i=1;i&lt;n;++i)        {            int x,y,v;            read(x),read(y),read(v);            link(x,y,v),link(y,x,v);        }        dfs_pre(1,0);        for(int i=1;i&lt;=m;++i)        {            int x,y,v;            read(x),read(y),read(v);            if(de[x]&lt;de[y]) swap(x,y);            Add(x,y,1,v);        }        for(int i=1;i&lt;=n;++i)        {            if(in[i]&gt;0) add(s,i,in[i],0);            else add(i,t,-in[i],0);        }        printf(\"%lld\\n\",ans-dinic());    }    return 0;}\r\n最小割树\r\n通过建最小割树来快速求解无向图中两点间的最小割。最小割树中的一条边的权值，为其两端点的最小割，那么任意两点之间的最小割即为路径上的最小值。通过递归建树即可。\r\nvoid build(int l,int r){    if(l==r) return;    s=p[l],t=p[l+1];    int v=F.dinic(),cnt1=0,cnt2=0;    add(s,t,v),add(t,s,v);    for(int i=l;i&lt;=r;++i)    {        int x=p[i];        if(F.d[x]) p1[++cnt1]=x;        else p2[++cnt2]=x;    }    for(int i=1;i&lt;=cnt1;++i) p[l+i-1]=p1[i];    for(int i=1;i&lt;=cnt2;++i) p[l+cnt1+i-1]=p2[i];    build(l,l+cnt1-1),build(l+cnt1,r);}\r\n树的直径\r\n可以通过两次  或 \r\n求出树的直径，从任意结点出发，搜索得出直径的一个端点，然后从这个端点继续搜索，得出另一个端点，但无法处理负边权。也可以用树形求直径，考虑每个结点，求出经过结点的最长链长度，则树的直径长度就是这些最长链长度的最大值，但无法求出直径的端点。\r\nvoid dp(int x,int fa){    for(int i=head[x];i;i=e[i].nxt)\t{        int y=e[i].to,v=e[i].v;\t\tif(y==fa) continue;        dp(y,x);        maxd=max(maxd,dis[x]+dis[y]+v);        dis[x]=max(dis[x],dis[y]+v);    }}\r\n树上 k 级祖先\r\n#include&lt;bits/stdc++.h&gt;#define maxn 500010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,q,root,cnt;ll ans,last;int son[maxn],top[maxn],de[maxn],dep[maxn];int lg[maxn],f[maxn][22],u[maxn],d[maxn],dfn[maxn];unsigned int s;struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}unsigned int get(){    s^=s&lt;&lt;13,s^=s&gt;&gt;17,s^=s&lt;&lt;5;\treturn s; }void dfs_son(int x){    de[x]=dep[x]=de[f[x][0]]+1;    for(int i=1;i&lt;=19;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        dfs_son(y),dep[x]=max(dep[x],dep[y]);        if(dep[y]&gt;dep[son[x]]) son[x]=y;    }}void dfs_dfn(int x,int tp,int anc){    top[x]=tp,dfn[x]=++cnt,u[cnt]=anc,d[cnt]=x;    if(son[x]) dfs_dfn(son[x],tp,f[anc][0]);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==son[x]) continue;        dfs_dfn(y,y,y);    }}int ask(int x,int k){    if(!k) return x;    x=f[x][lg[k]],k-=(1&lt;&lt;lg[k])+de[x]-de[top[x]],x=top[x];    if(k&gt;=0) return u[dfn[x]+k];    else return d[dfn[x]-k];}int main(){    read(n),read(q),read(s),lg[0]=-1;    for(int i=1;i&lt;=n;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int i=1;i&lt;=n;++i)    {        read(f[i][0]);        if(!f[i][0]) root=i;        else add(f[i][0],i);    }    dfs_son(root),dfs_dfn(root,root,root);    for(int i=1;i&lt;=q;++i)    {        int x=(get()^last)%n+1,k=(get()^last)%de[x];        last=ask(x,k),ans^=last*i;    }    printf(\"%lld\",ans);    return 0;}\r\n无向图三元环计数\r\nfor(int i=1;i&lt;=m;++i){    int x=ed[i].x,y=ed[i].y;    if(deg[x]&gt;deg[y]||(deg[x]==deg[y]&amp;&amp;x&gt;y)) swap(x,y);    add(x,y);}for(int x=1;x&lt;=n;++x){    for(int i=head[x];i;i=e[i].nxt) vis[e[i].to]=x;    for(int i=head[x];i;i=e[i].nxt)        for(int j=head[e[i].to];j;j=e[j].nxt)            if(vis[e[j].to]==x)                ans++;}\r\n欧拉回路\r\n 为无向图， 为有向图。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 400010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t,cnt;int deg[maxn],p[maxn];bool vis[maxn];struct edge{    int to,nxt;    edge(int a=0,int b=0)    {        to=a,nxt=b;    }}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void dfs1(int x){    for(int &amp;i=head[x];i;i=e[i].nxt)    {        if(vis[i]) continue;        int l=i;        vis[i]=vis[i^1]=true,dfs1(e[i].to),p[++cnt]=l&amp;1?-(l&gt;&gt;1):(l&gt;&gt;1);    }}void dfs2(int x){    for(int &amp;i=head[x];i;i=e[i].nxt)    {        if(vis[i]) continue;        int l=i;        vis[i]=true,dfs2(e[i].to),p[++cnt]=l;    }}bool check(){    for(int i=1;i&lt;=n;++i)        if(deg[i])            return false;    return true;}int main(){    read(t),read(n),read(m),edge_cnt=t==1;    for(int i=1;i&lt;=m;++i)    {        int x,y;        read(y),read(x),add(x,y),s=x;        if(t==1) add(y,x),deg[x]^=1,deg[y]^=1;        else deg[x]++,deg[y]--;    }    if(!check())    {        puts(\"NO\");        return 0;    }       if(t==1) dfs1(s);    else dfs2(s);    if(cnt!=m)    {        puts(\"NO\");        return 0;    }    puts(\"YES\");    for(int i=1;i&lt;=m;++i) printf(\"%d \",p[i]);    return 0;}\r\nKruskal 重构树\r\n用 \r\n构建生成树的顺序来构建 \r\n重构树。两个连通块合并时，新建一个节点，点权为联通这两个连通块边的边权，新节点向两个连通块的根连边，新节点为合并后的连通块的根。得到的树为有\r\n\r\n个叶子节点的二叉树，其满足堆的性质。求一个点  在只经过边权不大于  的边所能到达的点。边权从小到大排序，建\r\n\r\n重构树，得到的是一个大根堆，从 \r\n向上倍增，到达满足点权不大于 \r\n深度最浅的节点，该节点子树中的所有叶子节点  都可到达。\r\nfor(int i=1;i&lt;=m;++i){    int x=find(ed[i].x),y=find(ed[i].y);    if(x==y) continue;    val[++tot]=ed[i].v,add(tot,x),add(tot,y);    fa[x]=fa[y]=f[x][0]=f[y][0]=tot;    if(tot==2*n-1) break;}\r\n静态仙人掌\r\n询问两点最短路。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 40010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,q,tot,dfn_cnt;int dfn[maxn],low[maxn],fa[maxn],pre[maxn],sum[maxn],dis[maxn],de[maxn],f[maxn][18];struct node{    struct edge    {        int to,nxt,v;    }e[maxn];    int head[maxn],edge_cnt;    void add(int from,int to,int val)    {        e[++edge_cnt]=(edge){to,head[from],val};        head[from]=edge_cnt;    }}T1,T2;void build(int x,int y,int v){    int s=v;    for(int i=y;i!=fa[x];i=fa[i]) sum[i]=s,s+=pre[i];    sum[++tot]=sum[x],sum[x]=0;    for(int i=y;i!=fa[x];i=fa[i])        T2.add(tot,i,min(sum[i],sum[tot]-sum[i])),T2.add(i,tot,min(sum[i],sum[tot]-sum[i]));}void tarjan(int x,int fath){    dfn[x]=low[x]=++dfn_cnt;    for(int i=T1.head[x];i;i=T1.e[i].nxt)    {        int y=T1.e[i].to,v=T1.e[i].v;        if(y==fath) continue;        if(!dfn[y])        {            fa[y]=x,pre[y]=v,tarjan(y,x);            low[x]=min(low[x],low[y]);        }        else low[x]=min(low[x],dfn[y]);        if(dfn[x]&lt;low[y]) T2.add(x,y,v),T2.add(y,x,v);    }    for(int i=T1.head[x];i;i=T1.e[i].nxt)    {        int y=T1.e[i].to;        if(fa[y]!=x&amp;&amp;dfn[x]&lt;dfn[y])            build(x,y,T1.e[i].v);    }}void dfs(int x,int fath){    f[x][0]=fath,de[x]=de[fath]+1;    for(int i=1;i&lt;=15;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=T2.head[x];i;i=T2.e[i].nxt)    {        int y=T2.e[i].to;        if(y==fath) continue;        dis[y]=dis[x]+T2.e[i].v,dfs(y,x);    }}int lca(int x,int y){    if(de[x]&lt;de[y]) swap(x,y);    for(int i=15;i&gt;=0;--i)        if(de[f[x][i]]&gt;=de[y])            x=f[x][i];    if(x==y) return x;    for(int i=15;i&gt;=0;--i)        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    return f[x][0];}int find(int x,int k){    for(int i=0;i&lt;=15;++i)        if(k&amp;(1&lt;&lt;i))            x=f[x][i];    return x;}int main(){    read(n),read(m),read(q),tot=n;    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        T1.add(x,y,v),T1.add(y,x,v);    }    tarjan(1,0),dfs(1,0);    while(q--)    {        int x,y,anc;        read(x),read(y),anc=lca(x,y);        if(anc&lt;=n) printf(\"%d\\n\",dis[x]+dis[y]-dis[anc]*2);        else        {            int sx=find(x,de[x]-de[anc]-1),sy=find(y,de[y]-de[anc]-1);            if(sum[sx]&lt;sum[sy]) swap(sx,sy);            printf(\"%d\\n\",dis[x]-dis[sx]+dis[y]-dis[sy]+min(sum[sx]-sum[sy],sum[anc]+sum[sy]-sum[sx]));        }    }    return 0;}\r\n虚树\r\n给出一棵单位边权的树和若干关键点，求出每两个关键点间的距离之和以及距离最大、最小值。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010#define inf 200000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,q;ll ans,tot,maxd,mind;ll dma[maxn],dmi[maxn];bool flag;int query[maxn];struct edge{    int to,nxt;    ll v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,ll val=0){    e[++edge_cnt]=(edge){to,head[from],val};    head[from]=edge_cnt;}int dfn_cnt;int dfn[maxn],top_fa[maxn],fa[maxn],son[maxn];ll de[maxn],siz[maxn];void dfs_son(int x,int fath){    siz[x]=1;    fa[x]=fath;    de[x]=de[fath]+1;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fath) continue;        dfs_son(y,x);        siz[x]+=siz[y];        if(siz[son[x]]&lt;siz[y]) son[x]=y;    }}void dfs_chain(int x,int tp){    dfn[x]=++dfn_cnt,top_fa[x]=tp;    if(son[x]) dfs_chain(son[x],tp);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(dfn[y]) continue;        dfs_chain(y,y);    }}int lca(int x,int y){    while(top_fa[x]!=top_fa[y])    {        if(de[top_fa[x]]&lt;de[top_fa[y]]) swap(x,y);        x=fa[top_fa[x]];    }    if(dfn[x]&gt;dfn[y]) swap(x,y);    return x;}ll dis(int x,int y){    return de[x]+de[y]-de[lca(x,y)]*2;}bool cmp(const int &amp;a,const int &amp;b){    return dfn[a]&lt;dfn[b];}int st[maxn],top;void insert(int x){    if(x==1) return;    if(top==1)    {        st[++top]=x;        return;    }    int anc=lca(x,st[top]);    if(anc==st[top])    {        st[++top]=x;        return;    }    while(top&gt;1&amp;&amp;dfn[anc]&lt;=dfn[st[top-1]])         add(st[top-1],st[top],dis(st[top-1],st[top])),top--;    if(anc!=st[top]) add(anc,st[top],dis(anc,st[top])),st[top]=anc;    st[++top]=x;}bool vis[maxn];void dp(int x){    dma[x]=-inf,dmi[x]=inf;    if(vis[x]) dma[x]=dmi[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        dp(y);        maxd=max(maxd,dma[x]+dma[y]+v);        dma[x]=max(dma[x],dma[y]+v);        mind=min(mind,dmi[x]+dmi[y]+v);        dmi[x]=min(dmi[x],dmi[y]+v);    }}void dfs_ans(int x){    if(vis[x]) siz[x]=1;    else siz[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        dfs_ans(y);        siz[x]+=siz[y];        ans+=siz[y]*(tot-siz[y])*v;    }    head[x]=0;}void clear(){    edge_cnt=0;    memset(siz,0,sizeof(siz));    memset(head,0,sizeof(head));}int main(){\tread(n);    for(int i=1;i&lt;n;++i)    {        int a,b;        read(a),read(b);        add(a,b),add(b,a);    }    dfs_son(1,0),dfs_chain(1,1),clear();    read(q);    while(q--)    {        int k;        read(k);        tot=k;        edge_cnt=ans=0;        mind=inf,maxd=-inf;        for(int i=1;i&lt;=k;++i)        {            read(query[i]);            vis[query[i]]=true;        }        sort(query+1,query+k+1,cmp);        st[top=1]=1;        for(int i=1;i&lt;=k;++i) insert(query[i]);        while(top) add(st[top-1],st[top],dis(st[top-1],st[top])),top--;        dp(1),dfs_ans(1);        for(int i=1;i&lt;=k;++i) vis[query[i]]=false;        printf(\"%lld %lld %lld\\n\",ans,mind,maxd);    }\treturn 0;}\r\n最小树形图\r\n给定包含  个结点，  条有向边的一个图。试求一棵以结点 \r\n为根的最小树形图，并输出最小树形图每条边的权值之和，如果没有以  为根的最小树形图，输出 。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 20010#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,root;struct edge{    int x,y,v;}e[maxn];int id[maxn],pre[maxn],ine[maxn],vis[maxn];int zhuliu(){    int ans=0,cnt;    while(1)    {        cnt=0;        for(int i=1;i&lt;=n;++i) ine[i]=inf,id[i]=vis[i]=0;        for(int i=1;i&lt;=m;++i)        {            int x=e[i].x,y=e[i].y,v=e[i].v;            if(x!=y&amp;&amp;v&lt;ine[y]) ine[y]=v,pre[y]=x;        }        for(int i=1;i&lt;=n;++i)            if(i!=root&amp;&amp;ine[i]==inf)                return -1;        for(int i=1;i&lt;=n;++i)        {            if(i==root) continue;            ans+=ine[i];            int y=i;            while(vis[y]!=i&amp;&amp;!id[y]&amp;&amp;y!=root)            {                vis[y]=i;                y=pre[y];            }            if(!id[y]&amp;&amp;y!=root)            {                id[y]=++cnt;                for(int x=pre[y];x!=y;x=pre[x]) id[x]=cnt;            }        }        if(!cnt) break;        for(int i=1;i&lt;=n;++i)            if(!id[i])                id[i]=++cnt;        for(int i=1;i&lt;=m;++i)        {            int x=e[i].x,y=e[i].y;            e[i].x=id[x],e[i].y=id[y];            if(id[x]!=id[y]) e[i].v-=ine[y];        }        root=id[root];        n=cnt;    }    return ans;}int main(){\tread(n),read(m),read(root);    for(int i=1;i&lt;=m;++i)        read(e[i].x),read(e[i].y),read(e[i].v);    printf(\"%d\",zhuliu());\treturn 0;}\r\n支配树\r\n给定一张有向图，求从 \r\n号点出发，每个点能支配的点的个数（包括自己）。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 600010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m;struct node{\tstruct edge\t{\t\tint to,nxt;\t}e[maxm];\tint head[maxn],edge_cnt;\tvoid add(int from,int to)\t{\t\te[++edge_cnt]=(edge){to,head[from]};\t\thead[from]=edge_cnt;\t}}a,b,c,d;int dfn_cnt;int dfn[maxn],id[maxn],fa[maxn];int sdom[maxn],idom[maxn],fath[maxn],val[maxn],ans[maxn];void dfs_dfn(int x){\tdfn[x]=++dfn_cnt;\tid[dfn_cnt]=x;\tfor(int i=a.head[x];i;i=a.e[i].nxt)\t{\t\tint y=a.e[i].to;\t\tif(dfn[y]) continue;\t\tfa[y]=x;\t\tdfs_dfn(y);\t}}int find(int x){\tif(x==fath[x]) return x;\tint tmp=find(fath[x]);\tif(dfn[sdom[val[fath[x]]]]&lt;dfn[sdom[val[x]]])\t\tval[x]=val[fath[x]];\treturn fath[x]=tmp;}void tarjan(){\tfor(int i=1;i&lt;=n;++i) sdom[i]=fath[i]=val[i]=i;\tfor(int i=dfn_cnt;i&gt;1;--i)\t{\t\tint x=id[i];\t\tfor(int i=b.head[x];i;i=b.e[i].nxt)\t\t{\t\t\tint y=b.e[i].to;\t\t\tif(!dfn[y]) continue;\t\t\tfind(y);\t\t\tif(dfn[sdom[val[y]]]&lt;dfn[sdom[x]])\t\t\t\tsdom[x]=sdom[val[y]];\t\t}\t\tc.add(sdom[x],x);\t\tfath[x]=fa[x];\t\tx=fa[x];\t\tfor(int i=c.head[x];i;i=c.e[i].nxt)\t\t{\t\t\tint y=c.e[i].to;\t\t\tfind(y);\t\t\tif(sdom[val[y]]==x) idom[y]=x;\t\t\telse idom[y]=val[y];\t\t}\t\tc.head[x]=0;\t}\tfor(int i=2;i&lt;=dfn_cnt;++i)\t{\t\tint x=id[i];\t\tif(idom[x]!=sdom[x])\t\t\tidom[x]=idom[idom[x]];\t}\tfor(int i=2;i&lt;=n;++i) d.add(idom[i],i);}void dfs_ans(int x){\tans[x]=1;\tfor(int i=d.head[x];i;i=d.e[i].nxt)\t{\t\tint y=d.e[i].to;\t\tdfs_ans(y);\t\tans[x]+=ans[y];\t}}int main(){\tread(n),read(m);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\ta.add(x,y),b.add(y,x);\t}\tdfs_dfn(1);\ttarjan();\tdfs_ans(1);\tfor(int  i=1;i&lt;=n;++i) printf(\"%d \",ans[i]);\treturn 0;}\r\n动态规划\r\n单调队列优化 DP\r\n优化形如  的  方程。\r\n\r\nwhile(h&lt;=t&amp;&amp;f[x][y]&gt;q[t].val+dis(x,y,q[t].x,q[t].y)) t--;q[++t]=(que){f[x][y],x,y};while(h&lt;=t&amp;&amp;(abs(x-q[h].x)&gt;len||abs(y-q[h].y)&gt;len)) h++;f[x][y]=max(f[x][y],q[h].val+dis(x,y,q[h].x,q[h].y));ans=max(ans,f[x][y]);\r\n数位 DP\r\n不含前导零且相邻两个数字之差至少为  的正整数被称为 windy 数。windy\r\n想知道，在  和  之间，包括  和  ，总共有多少个 windy 数？\r\n#include&lt;bits/stdc++.h&gt;#define maxn 15using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll a,b,cnt;ll num[maxn],f[maxn][maxn][2][2][2];ll dp(int pos,int las,bool lim,bool lead,bool flag){    if(!pos) return flag;    if(f[pos][las][lim][lead][flag]!=-1) return f[pos][las][lim][lead][flag];    ll v=0,ma=9;    if(lim) ma=num[pos];    for(int i=0;i&lt;=ma;++i)    {        if(!i&amp;&amp;lead) v+=dp(pos-1,12,0,1,1);        else v+=dp(pos-1,i,lim&amp;&amp;i==ma,0,flag&amp;&amp;(abs(las-i)&gt;=2));    }    return f[pos][las][lim][lead][flag]=v;}ll solve(ll x){    cnt=0,memset(f,-1,sizeof(f));    while(x) num[++cnt]=x%10,x/=10;    return dp(cnt,12,1,1,1);}int main(){    read(a),read(b),printf(\"%lld\",solve(b)-solve(a-1));    return 0;}\r\n斜率优化\r\n最小值\r\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,h,t;ll f[maxn],p[maxn],s[maxn],c[maxn],dis[maxn],q[maxn];double x(int i){    return p[i];}double y(int i){    return f[i]+s[i];}double slope(int j,int k){    return (y(j)-y(k))/(x(j)-x(k));}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        read(dis[i]),read(p[i]),read(c[i]);        s[i]=s[i-1]+dis[i]*p[i],p[i]+=p[i-1];    }    for(int i=1;i&lt;=n;++i)    {        while(h&lt;t&amp;&amp;slope(q[h],q[h+1])&lt;dis[i]) h++;        f[i]=f[q[h]]+dis[i]*(p[i]-p[q[h]])-(s[i]-s[q[h]])+c[i];        while(h&lt;t&amp;&amp;slope(q[t],q[t-1])&gt;slope(q[t],i)) t--;        q[++t]=i;    }    printf(\"%lld\",f[n]);\treturn 0;}\r\n最大值\r\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,h,t,a,b,c;ll f[maxn],s[maxn],q[maxn];ll calc(ll x){    return x*x;}double x(int i){    return s[i];}double y(int i){    return f[i]+a*calc(s[i])-b*s[i];}double slope(int j,int k){    return (y(j)-y(k))/(x(j)-x(k));}int main(){    read(n),read(a),read(b),read(c);    for(int i=1;i&lt;=n;++i) read(s[i]),s[i]+=s[i-1];    for(int i=1;i&lt;=n;++i)    {        while(h&lt;t&amp;&amp;slope(q[h],q[h+1])&gt;2*a*s[i]) h++;        f[i]=f[q[h]]+a*calc(s[i]-s[q[h]])+b*(s[i]-s[q[h]])+c;        while(h&lt;t&amp;&amp;slope(q[t],q[t-1])&lt;slope(q[t],i)) t--;        q[++t]=i;    }    printf(\"%lld\",f[n]);\treturn 0;}\r\n决策单调性\r\n\r\n二分栈：\r\ndouble calc(int i,int j){    return a[j]-a[i]+sqrt(i-j);}int find(node t,int x){\tint l=t.l,r=t.r,ans=t.r+1;\twhile(l&lt;=r)\t{\t\tint mid=(l+r)&gt;&gt;1;\t\tif(calc(mid,x)&gt;=calc(mid,t.pos)) r=mid-1,ans=mid;\t\telse l=mid+1;\t}\treturn ans;}void dp(double *f){\tq[h=t=1]=node(1,n,0);\tfor(int i=1;i&lt;=n;++i)\t{\t\twhile(h&lt;=t&amp;&amp;q[h].r&lt;i) h++;\t\tf[i]=calc(i,q[h].pos);\t\tif(calc(n,i)&gt;=calc(n,q[t].pos))\t\t{\t\t\twhile(h&lt;=t&amp;&amp;calc(q[t].l,i)&gt;=calc(q[t].l,q[t].pos)) t--;\t\t\tif(h&gt;t) q[++t]=node(i,n,i);\t\t\telse\t\t\t{\t\t\t\tint x=find(q[t],i);\t\t\t\tq[t].r=x-1,q[++t]=node(x,n,i);\t\t\t}\t\t}\t}}\r\n分治：\r\n对于区间 ，已知其最优决策范围为 。取  后扫一遍区间  来得出  的  值和最优决策点 ，那么左区间的最优决策范围为 ，右区间的最优决策范围为 。应用分治时要求保证区间 \r\n的信息都已存在，因此应用分治大部分时候都是分层的两维 。\r\ndouble calc(int i,int j){    return a[j]-a[i]+sqrt(i-j);}void solve(int l,int r,int L,int R,double *f){    if(l&gt;r) return;    int pos,mid=(l+r)&gt;&gt;1;    for(int i=L;i&lt;=min(mid,R);++i)    {        double v=calc(mid,i);        if(v&gt;f[mid]) f[mid]=v,pos=i;    }    solve(l,mid-1,L,pos,f),solve(mid+1,r,pos,R,f);}\r\n可以处理无法快速  计算  的 。，其中\r\n 为区间  相同元素的对数。\r\nvoid add(int c){    sum+=cnt[c],cnt[c]++;}void del(int c){    sum-=cnt[c]-1,cnt[c]--;}ll get(int ql,int qr){    while(l&lt;ql) del(a[l++]);    while(r&gt;qr) del(a[r--]);    while(l&gt;ql) add(a[--l]);    while(r&lt;qr) add(a[++r]);    return sum;}void solve(int id,int l,int r,int L,int R){    if(l&gt;r) return;    int pos,mid=(l+r)&gt;&gt;1;    for(int i=L;i&lt;=min(mid,R);++i)    {        ll v=f[i][id-1]+get(i+1,mid);        if(v&lt;f[mid][id]) f[mid][id]=v,pos=i;    }    solve(id,l,mid-1,L,pos),solve(id,mid+1,r,pos,R);}\r\n指针的移动均摊是  的。\r\n长链剖分\r\n给定一棵以  为根， 个节点的树。设  为  子树中到  距离为  的节点数。 对于每个点，求一个最小的\r\n，使得  最大。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n;int len[maxn],son[maxn],ans[maxn];vector&lt;int&gt; f[maxn];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void dfs_son(int x,int fa){    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_son(y,x);\t\tif(len[y]&gt;=len[son[x]]) son[x]=y,len[x]=len[y]+1;    }}void dfs(int x,int fa){\tif(!son[x])\t{\t\tf[x].push_back(1);\t\treturn;\t}\tdfs(son[x],x),swap(f[x],f[son[x]]),f[x].push_back(1),ans[x]=ans[son[x]]+1;\tif(f[x][len[x]-ans[x]]==1) ans[x]=0;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fa||y==son[x]) continue;\t\tdfs(y,x);\t\tfor(int j=0;j&lt;=len[y];++j)\t\t{\t\t\tf[x][len[x]-j-1]+=f[y][len[y]-j];\t\t\tif(f[x][len[x]-j-1]&gt;f[x][len[x]-ans[x]]||(f[x][len[x]-j-1]==f[x][len[x]-ans[x]]&amp;&amp;j+1&lt;ans[x]))\t\t\t\tans[x]=j+1;\t\t}\t}}int main(){\tread(n);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs_son(1,0),dfs(1,0);\tfor(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]);\treturn 0;}\r\n凸优化\r\n理解可以是二分斜率切凸包，也可以是上下平移凸函数的导函数，来左右平移导函数的零点，使原凸函数的取到极值的位置发生变化。可以优化一种有限制个数的\r\n，即恰好选 \r\n个，通过二分来去掉一维来实现优化。通过题面性质来证明凸函数，费用流模型都为凸函数。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 600010#define inf 1000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,k;ll l,r,ans;struct edge{    int to,nxt;    ll v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]=(edge){to,head[from],val};    head[from]=edge_cnt;}struct node{    ll val,cnt;}f[maxn][3],g[3];bool operator &lt;(const node &amp;a,const node &amp;b){    if(a.val==b.val) return a.cnt&lt;b.cnt;    return a.val&lt;b.val;}node operator +(const node &amp;a,const node &amp;b){    return (node){a.val+b.val,a.cnt+b.cnt};}void dfs(int x,int fa,ll delta){    f[x][0]=(node){0,0},f[x][1]=(node){-inf,-inf},f[x][2]=(node){delta,1};    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        if(y==fa) continue;        dfs(y,x,delta),g[0]=g[1]=g[2]=(node){-inf,-inf};        for(int j=0;j&lt;3;++j)            for(int k=0;k&lt;3;++k)                g[j]=max(g[j],f[x][j]+f[y][k]);        g[1]=max(g[1],max(f[x][0]+f[y][0]+(node){v+delta,1},f[x][0]+f[y][1]+(node){v,0}));        g[2]=max(g[2],max(f[x][1]+f[y][1]+(node){v-delta,-1},f[x][1]+f[y][0]+(node){v,0}));        f[x][0]=g[0],f[x][1]=g[1],f[x][2]=g[2];    }}bool check(ll x){    dfs(1,0,x);    return max(f[1][0],max(f[1][1],f[1][2])).cnt&gt;=k;}int main(){    read(n),read(k),k++;    for(int i=1;i&lt;n;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v),r+=abs(v);    }    l=-r;    while(l&lt;=r)    {        ll mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,r=mid-1;        else l=mid+1;    }    check(ans),printf(\"%lld\",max(f[1][0],max(f[1][1],f[1][2])).val-ans*k);    return 0;}\r\n通过限制二分来处理选至多选 \r\n个的问题。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,k,pos,l=-inf,r=0;ll ans,sum,cnt;struct node{    ll v,p;}a[maxn],b[maxn];bool cmp(const node &amp;a,const node &amp;b){    if(a.p==b.p) return a.v&lt;b.v;    return a.p&lt;b.p;}bool check(int x){    priority_queue&lt;int&gt; q;    sum=cnt=0,pos=1;    for(int i=1;i&lt;=n;++i)    {        while(pos&lt;=m&amp;&amp;a[i].p&gt;=b[pos].p) q.push(b[pos++].v);        if(q.empty()) continue;        if(q.top()-a[i].v+x&gt;=0)            sum+=q.top()-a[i].v+x,cnt++,q.pop();    }    return cnt&lt;=k;}int main(){    read(n),read(m),read(k);    for(int i=1;i&lt;=n;++i) read(a[i].v),read(a[i].p);    for(int i=1;i&lt;=m;++i) read(b[i].v),read(b[i].p);    sort(a+1,a+n+1,cmp),sort(b+1,b+m+1,cmp);    while(l&lt;=r)    {        int mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,l=mid+1;        else r=mid-1;    }    check(ans),printf(\"%lld\\n\",sum-ans*cnt);    return 0;}\r\n整体 DP\r\n\r\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 15000010#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,k,tot;int d[maxn],w[maxn],rt[maxn],ls[maxm],rs[maxm];ll mx[maxm],tag[maxm];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void pushtag(int cur,ll v){\tif(cur) mx[cur]+=v,tag[cur]+=v;}void pushdown(int cur){\tif(tag[cur]) pushtag(ls[cur],tag[cur]),pushtag(rs[cur],tag[cur]),tag[cur]=0;}void modify(int l,int r,int p,ll v,int &amp;cur){\tif(!cur) cur=++tot;\tif(l==r)\t{\t\tmx[cur]=v;\t\treturn;\t}\tpushdown(cur);\tif(p&lt;=mid) modify(l,mid,p,v,ls[cur]);\telse modify(mid+1,r,p,v,rs[cur]);\tmx[cur]=max(mx[ls[cur]],mx[rs[cur]]);}ll query(int L,int R,int l,int r,int cur){\tif(!cur) return 0;\tif(L&lt;=l&amp;&amp;R&gt;=r) return mx[cur];\tll v=0;\tpushdown(cur);\tif(L&lt;=mid) v=max(v,query(L,R,l,mid,ls[cur]));\tif(R&gt;mid) v=max(v,query(L,R,mid+1,r,rs[cur]));\treturn v;}int get(int x,int y,int l,int r,ll v1,ll v2){\tif(!x&amp;&amp;!y) return 0;\tif(x&amp;&amp;!y)\t{\t\tpushtag(x,v2);\t\treturn x;\t}\tif(!x&amp;&amp;y)\t{\t\tpushtag(y,v1);\t\treturn y;\t}\tif(l==r)\t{\t\tmx[x]=max(mx[x],v1)+max(mx[y],v2);\t\treturn x;\t}\tpushdown(x),pushdown(y);\trs[x]=get(rs[x],rs[y],mid+1,r,max(v1,mx[ls[x]]),max(v2,mx[ls[y]]));\tls[x]=get(ls[x],ls[y],l,mid,v1,v2);\tmx[x]=max(mx[ls[x]],mx[rs[x]]);\treturn x;}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tdfs(y),rt[x]=get(rt[x],rt[y],1,k,0,0);\t}\tif(d[x]) modify(1,k,d[x],w[x]+query(1,d[x],1,k,rt[x]),rt[x]);}int main(){\tread(n),read(m),read(k);\tfor(int i=2,p;i&lt;=n;++i) read(p),add(p,i);\tfor(int i=1,x;i&lt;=m;++i) read(x),read(d[x]),read(w[x]);\tdfs(1),printf(\"%lld\\n\",mx[rt[1]]);    return 0;}\r\n动态 DP\r\n给定一棵 \r\n个点的树，点带点权。有 \r\n次操作，每次操作给定 ，表示修改点  的权值为 。你需要在每次操作之后求出这棵树的最大权独立集的权值大小。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m;int f[maxn][2],a[maxn],ch[maxn][2],fa[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}struct matrix{    int a[2][2];    matrix()    {        a[0][0]=a[0][1]=a[1][0]=a[1][1]=-inf;    }    int get()    {        return max(a[0][0],a[1][0]);    }}val[maxn],mul[maxn];matrix operator *(const matrix &amp;x,const matrix &amp;y){    matrix z;    for(int k=0;k&lt;=1;++k)        for(int i=0;i&lt;=1;++i)            for(int j=0;j&lt;=1;++j)                z.a[i][j]=max(z.a[i][j],x.a[i][k]+y.a[k][j]);    return z;}void pushup(int x) {    mul[x]=val[x];    if(ch[x][0]) mul[x]=mul[ch[x][0]]*mul[x];    if(ch[x][1]) mul[x]=mul[x]*mul[ch[x][1]];}bool check(int x){    return ch[fa[x]][1]==x;}bool notroot(int x){    return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void rotate(int x){    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];    if(notroot(y)) ch[z][check(y)]=x;    ch[x][k^1]=y,ch[y][k]=w;    if(w) fa[w]=y;    fa[x]=z,fa[y]=x;    pushup(y),pushup(x);}void splay(int x){    for(int y;notroot(x);rotate(x))        if(notroot(y=fa[x]))            rotate(check(x)^check(y)?x:y);}void access(int x){    for(int y=0;x;y=x,x=fa[x])    {            splay(x);        if(ch[x][1]) val[x].a[0][0]+=mul[ch[x][1]].get(),val[x].a[1][0]+=mul[ch[x][1]].a[0][0];        if(y) val[x].a[0][0]-=mul[y].get(),val[x].a[1][0]-=mul[y].a[0][0];        val[x].a[0][1]=val[x].a[0][0],ch[x][1]=y,pushup(x);    }}void modify(int x,int v){    access(x),splay(x);    val[x].a[1][0]-=a[x]-v;    pushup(x),a[x]=v;}void dfs(int x,int fath){    fa[x]=fath,f[x][1]=a[x];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fath) continue;        dfs(y,x),f[x][0]+=max(f[y][0],f[y][1]),f[x][1]+=f[y][0];    }    val[x].a[0][0]=val[x].a[0][1]=f[x][0],val[x].a[1][0]=f[x][1],mul[x]=val[x];}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    for(int i=1;i&lt;n;++i)    {        int x,y;        read(x),read(y);        add(x,y),add(y,x);    }    dfs(1,0);    while(m--)    {        int x,y;        read(x),read(y),modify(x,y),splay(1);        printf(\"%d\\n\",mul[1].get());    }\treturn 0;}\r\n字符串\r\nKMP\r\nfor(int i=2;i&lt;=m;++i){    while(pos&amp;&amp;t[i]!=t[pos+1]) pos=nxt[pos];    if(t[i]==t[pos+1]) pos++;    nxt[i]=pos;}pos=0;for(int i=1;i&lt;=n;++i){    while(pos&amp;&amp;s[i]!=t[pos+1]) pos=nxt[pos];    if(s[i]==t[pos+1]) pos++;    if(pos==m) printf(\"%d\\n\",i-m+1);}\r\nManacher\r\n设  为以 \r\n为中心的长度为奇数的回文串个数，也就是最长回文串的回文半径。\r\nvoid manacher(){\ts[0]='/',s[1]='#';\tfor(int i=1;i&lt;=n;++i) s[i&lt;&lt;1]=t[i],s[i&lt;&lt;1|1]='#';\tn=n&lt;&lt;1|1,s[n+1]='!';\tfor(int i=1,mr=1,mid=0;i&lt;=n;++i)\t{\t\tf[i]=i&lt;mr?min(f[mid*2-i],mr-i):1;\t\twhile(s[i+f[i]]==s[i-f[i]]) f[i]++;\t\tif(i+f[i]&gt;mr) mr=i+f[i],mid=i;\t}}\r\nAC 自动机\r\n给你一个文本串  和  个模式串 ，请你分别求出每个模式串\r\n 在  中出现的次数。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot,root;int ch[maxn][28],fail[maxn],siz[maxn],bel[maxn];char s[maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}int insert(char *s){\tint len=strlen(s+1),p=root;\tfor(int i=1;i&lt;=len;++i)\t{\t\tint c=s[i]-'a';\t\tif(!ch[p][c]) ch[p][c]=++tot;\t\tp=ch[p][c];\t}\treturn p;}void build(){\tqueue&lt;int&gt; q;\tfor(int i=0;i&lt;26;++i)\t\tif(ch[root][i])\t\t\tq.push(ch[root][i]);\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=0;i&lt;26;++i)\t\t{\t\t\tint y=ch[x][i];\t\t\tif(y) fail[y]=ch[fail[x]][i],q.push(y);\t\t\telse ch[x][i]=ch[fail[x]][i];\t\t}\t}\tfor(int i=1;i&lt;=tot;++i) add(fail[i],i);}void update(){\tscanf(\"%s\",s+1);\tint len=strlen(s+1);\tfor(int i=1,p=root;i&lt;=len;++i) p=ch[p][s[i]-'a'],siz[p]++;}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt) dfs(e[i].to),siz[x]+=siz[e[i].to];}int main(){\tread(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%s\",s+1),bel[i]=insert(s);\tbuild(),update(),dfs(root);\tfor(int i=1;i&lt;=n;++i) printf(\"%d\\n\",siz[bel[i]]);    return 0;}\r\n后缀排序\r\n将字符串每个后缀按照字典序排序。 表示排名为  的后缀的起始位置。 表示起始位置为  的后缀的排名。。两个后缀的\r\n 为区间  数组的最小值。\r\nvoid rsort(){    for(int i=0;i&lt;=m;++i) b[i]=0;    for(int i=1;i&lt;=n;++i) b[rk[i]]++;    for(int i=1;i&lt;=m;++i) b[i]+=b[i-1];    for(int i=n;i;--i) sa[b[rk[tp[i]]]--]=tp[i];}void SA(){    for(int i=1;i&lt;=n;++i) rk[i]=s[i],tp[i]=i;    rsort();    for(int k=1;k&lt;=n;k&lt;&lt;=1)    {        int num=0;        for(int i=n-k+1;i&lt;=n;++i) tp[++num]=i;        for(int i=1;i&lt;=n;++i)             if(sa[i]&gt;k)                tp[++num]=sa[i]-k;        rsort();        memcpy(tp,rk,sizeof(rk));        rk[sa[1]]=num=1;        for(int i=2;i&lt;=n;++i)            rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k])?num:++num;        if(num==n) break;        m=num;    }}void height(){    int k=0;    for(int i=1;i&lt;=n;++i) rk[sa[i]]=i;    for(int i=1;i&lt;=n;++i)    {        if(rk[i]==1) continue;        if(k) k--;        int j=sa[rk[i]-1];        while(s[i+k]==s[j+k]) k++;        ht[rk[i]]=k;    }}void ST(){    lg[0]=-1;    for(int i=1;i&lt;=n;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int i=1;i&lt;=n;++i) f[i][0]=ht[i];    for(int j=1;j&lt;=20;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)            f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);}int lcp(int l,int r){    l=rk[l],r=rk[r];    if(l&gt;r) swap(l,r);    l++;    int len=lg[r-l+1];    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);}\r\n后缀自动机\r\n后缀自动机可以理解为是将字符串所有后缀所建出的  进行压缩后得出的 。对于一个子串 ，它结束位置的集合称为 ，如 ，。 为原串的两个子串，设 ，则  是  的后缀当且仅当 ，\r\n不是  的后缀当且仅当 。由 \r\n的包含关系可以得出一个树形结构，称为  树。\r\n后缀自动机的节点就是 \r\n树的节点，每个节点表示一个 。 的节点数不超过 ，边数不超过 ，数组大小应开成两倍。为一个 \r\n所对应的子串中最长子串的长度。为转移函数。为后缀连接。设  为一个 \r\n所对应的子串中最短子串的长度，得 。后缀自动机是一张有向无环图，其中顶点是状态，而边代表了状态之间的转移。每一个状态包含了它包含的最长子串的一些连续长度的后缀，不是所有后缀，再短的其他后缀在\r\n\r\n连接的状态，也就是该串的所有后缀在  树的链上。一个字符串的 \r\n树，是其反串的后缀树。从初始状态经由任意路径走到某一终止状态，得到的字符串为原串的某一后缀。从初始状态经由任意路径走到某一状态，得到的字符串为原串的某一子串。所有终止状态包含了原串的所有后缀，整串状态是终止状态，整串状态在\r\n\r\n树上的祖先也都是终止状态。一个状态的 \r\n集合大小等于该状态转移到终止状态的方案数。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot=1,las=1;ll ans;int len[maxn],fa[maxn],ch[maxn][28],siz[maxn];char s[maxn];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void insert(int c){\tint p=las,np=las=++tot;\tlen[np]=len[p]+1,siz[np]=1;\twhile(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p];\tif(!p) fa[np]=1;\telse\t{\t\tint q=ch[p][c];\t\tif(len[q]==len[p]+1) fa[np]=q;\t\telse\t\t{\t\t\tint nq=++tot;\t\t\tmemcpy(ch[nq],ch[q],sizeof(ch[q]));\t\t\tlen[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;\t\t\twhile(ch[p][c]==q) ch[p][c]=nq,p=fa[p];\t\t}\t}}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tdfs(y),siz[x]+=siz[y];\t}\tif(siz[x]&gt;1) ans=max(ans,(ll)len[x]*siz[x]);}int main(){\tscanf(\"%s\",s+1),n=strlen(s+1);\tfor(int i=1;i&lt;=n;++i) insert(s[i]-'a');\tfor(int i=2;i&lt;=tot;++i) add(fa[i],i);\tdfs(1),printf(\"%lld\",ans);\t    return 0;}\r\n广义后缀自动机\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,las,tot=1,root=1;ll ans;int fa[maxn],len[maxn],ch[maxn][26];char s[maxn];int insert(int c){    if(ch[las][c]&amp;&amp;len[las]+1==len[ch[las][c]]) return ch[las][c];    int p=las,np=++tot;    len[np]=len[p]+1;    while(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p];    if(!p) fa[np]=root;    else    {        int q=ch[p][c];        if(len[q]==len[p]+1) fa[np]=q;        else        {            int nq=++tot;            bool flag=las==p;            memcpy(ch[nq],ch[q],sizeof(ch[q]));            len[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;            while(ch[p][c]==q) ch[p][c]=nq,p=fa[p];            return flag?nq:np;        }    }    return np;}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        int lenth;        scanf(\"%s\",s+1),lenth=strlen(s+1),las=1;        for(int j=1;j&lt;=lenth;++j) las=insert(s[j]-'a');    }    for(int i=2;i&lt;=tot;++i) ans+=len[i]-len[fa[i]];    printf(\"%lld\",ans);    return 0;}\r\n回文自动机\r\n回文树可以用来处理一个字符串中所有的回文子串。一个串的本质不同回文子串个数最多为\r\n\r\n个。一个字符串的回文树由两棵树组成，一个维护所有长度为奇数的回文子串，一个维护所有长度为偶数的回文子串。树上除根节点外的每个节点都表示串中的一个回文子串。\r\n\r\n节点对应的回文子串长度。\r\n\r\n指向该节点所对应的回文子串的最长回文后缀所对应的节点。\r\n\r\n转移到该树的另一个节点，转移为向当前回文子串两端加上一个字符。\r\n\r\n以一个位置结尾对应节点的回文子串个数\r\n为方便处理，偶树的根的  设为\r\n， 设为奇树的根，奇树的根的  设为 ， 设为其本身。构造时用增量法即可。\r\nvoid init(){    len[1]=-1,fail[0]=fail[1]=tot=1;}void insert(int i){    int p=las,c=s[i]-'a';    while(s[i-1-len[p]]!=s[i]) p=fail[p];    if(ch[p][c])    {        las=ch[p][c];        return;    }    int x=fail[p],y=++tot;    while(s[i-1-len[x]]!=s[i]) x=fail[x];    fail[y]=ch[x][c],len[y]=len[p]+2,ch[p][c]=las=y,cnt[y]=cnt[fail[y]]+1;}\r\n建  树：\r\nfor(int i=0;i&lt;=tot;++i)    if(i!=1)    \tadd(fail[i],i);\r\n一个字符串的本质不同回文子串个数即为其回文树除了两个根的节点个数。字符串中一个位置的回文后缀个数即为该位置对应的节点的\r\n\r\n链长度。在维护每个本质不同回文子串的出现次数时，还需在  树上用儿子来更新父亲。\r\nfor(int i=tot;i;--i) cnt[fail[i]]+=cnt[i];\r\n有时还需用到 ，指向长度小于等于其回文子串长度一半的最长回文后缀的节点，建树时维护即可。\r\nvoid insert(int i){    int p=las,c=s[i]-'a';    while(s[i-1-len[p]]!=s[i]) p=fail[p];    if(ch[p][c])    {        las=ch[p][c];        return;    }    int x=fail[p],y=++tot;    while(s[i-1-len[x]]!=s[i]) x=fail[x];    fail[y]=ch[x][c],len[y]=len[p]+2,ch[p][c]=las=y;    if(len[y]&lt;=2) trans[y]=fail[y];    else    {        int q=trans[p];        while(s[i-1-len[q]]!=s[i]||(len[q]+2)*2&gt;len[y]) q=fail[q];        trans[y]=ch[q][c];    }}\r\n扩展 KMP\r\n扩展  可以  得出一个字符串的  函数， 为以  开头的后缀和整个串的 。\r\nz[1]=n;for(int i=2;i&lt;=n;++i){    if(i&lt;=r) z[i]=min(z[i-l+1],r-i+1);    while(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+1]) z[i]++;    if(i+z[i]-1&gt;r) l=i,r=i+z[i]-1;}\r\n计算几何\r\n二维凸包\r\n求凸包周长。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,top;double ans;int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }}p[maxn],st[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}double operator &amp; (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double dis(const Vec &amp;a,const Vec &amp;b){    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}bool cmp(const Vec &amp;a,const Vec &amp;b){    double A=atan2(a.y-p[1].y,a.x-p[1].x),B=atan2(b.y-p[1].y,b.x-p[1].x);    return sgn(A-B)?A&lt;B:a.x&lt;b.x;}void graham(){\tint k=1;\tfor(int i=2;i&lt;=n;++i)\t\tif(p[i].x&lt;p[k].x||(p[i].x==p[k].x&amp;&amp;p[i].y&lt;p[k].y))\t\t\tk=i;\tswap(p[1],p[k]),sort(p+2,p+n+1,cmp),st[top=1]=p[1];\tfor(int i=2;i&lt;=n;++i)\t{\t\twhile(top&gt;1&amp;&amp;sgn((p[i]-st[top-1])&amp;(st[top]-st[top-1]))&gt;=0) top--;\t\tst[++top]=p[i];\t}}int main(){    read(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y);\tgraham();\tfor(int i=1;i&lt;top;++i) ans+=dis(st[i],st[i+1]);\tprintf(\"%.2lf\",ans+dis(st[top],st[1]));\treturn 0;}\r\n旋转卡壳\r\n求凸包直径。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 50010#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,top;int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }}p[maxn],st[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double operator % (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}int dis(const Vec &amp;a,const Vec &amp;b){    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}bool cmp(const Vec &amp;a,const Vec &amp;b){    double A=atan2(a.y-p[1].y,a.x-p[1].x),B=atan2(b.y-p[1].y,b.x-p[1].x);    return sgn(A-B)?A&lt;B:a.x&lt;b.x;}void graham(){\tint k=1;\tfor(int i=2;i&lt;=n;++i)\t\tif(p[i].x&lt;p[k].x||(p[i].x==p[k].x&amp;&amp;p[i].y&lt;p[k].y))\t\t\tk=i;\tswap(p[1],p[k]),sort(p+2,p+n+1,cmp),st[top=1]=p[1];\tfor(int i=2;i&lt;=n;++i)\t{\t\twhile(top&gt;1&amp;&amp;sgn((p[i]-st[top-1])*(st[top]-st[top-1]))&gt;=0) top--;\t\tst[++top]=p[i];\t}}int calc(){\tif(top==2) return dis(st[1],st[2]);\tint j=3,v=0;;\tst[top+1]=st[1];\tfor(int i=1;i&lt;=top;++i)\t{\t\twhile((st[i+1]-st[i])*(st[j]-st[i])&lt;=(st[i+1]-st[i])*(st[j+1]-st[i])) j=j%top+1;\t\tv=max(v,max(dis(st[j],st[i]),dis(st[j],st[i+1])));\t}\treturn v;}int main(){    read(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y);\tgraham(),printf(\"%d\",calc());\treturn 0;}\r\n半平面交\r\n求半平面交面积。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 510#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,cnt,tot,h,t;int q[maxn];int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }    void in()    {        scanf(\"%lf%lf\",&amp;x,&amp;y);    }    double len()    {        return sqrt(x*x+y*y);    }}p[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double operator % (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}struct Line{    Vec a,b,c;    double k;    void init()    {        c=b-a,k=atan2(c.y,c.x);    }}l[maxn];bool cmp(const Line &amp;u,const Line &amp;v){    return sgn(u.k-v.k)?u.k&lt;v.k:sgn(u.c*(v.b-u.a))==-1;}Vec cross(Line u,Line v){    return v.a+v.c*((v.a-u.a)*u.c)/(u.c*v.c);}bool check(Line u,Line v,Line w){    return sgn(w.c*(cross(u,v)-w.a))==-1;}double get(){    double v=0;    sort(l+1,l+cnt+1,cmp);    for(int i=1;i&lt;=cnt;++i)        if(sgn(l[i].k-l[i-1].k))            l[++tot]=l[i];    q[h=t=1]=1,q[++t]=2;    for(int i=3;i&lt;=tot;++i)    {        while(h&lt;t&amp;&amp;check(l[q[t-1]],l[q[t]],l[i])) t--;        while(h&lt;t&amp;&amp;check(l[q[h]],l[q[h+1]],l[i])) h++;        q[++t]=i;    }    while(h&lt;t&amp;&amp;check(l[q[t-1]],l[q[t]],l[q[h]])) t--;    if(t-h+1&lt;=2) return 0;    q[t+1]=q[h],cnt=0;    for(int i=h;i&lt;=t;++i) p[++cnt]=cross(l[q[i]],l[q[i+1]]);    p[cnt+1]=p[1];    for(int i=1;i&lt;=cnt;++i) v+=p[i]*p[i+1];    return v/2;}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        int k;        read(k);        for(int j=1;j&lt;=k;++j)            l[++cnt].b.in(),l[cnt].a=l[cnt-1].b;        l[cnt-k+1].a=l[cnt].b;    }    for(int i=1;i&lt;=cnt;++i) l[i].init();    printf(\"%.3lf\",get());\treturn 0;}\r\n数学\r\nFFT\r\n#include&lt;bits/stdc++.h&gt;#define maxn 8000010#define Pi acos(-1.0)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int rev[maxn];struct Complex{\tdouble x,y;\tComplex(double a=0,double b=0)\t{\t\tx=a,y=b;\t}}f[maxn],g[maxn];Complex operator +(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x+b.x,a.y+b.y);}Complex operator -(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x-b.x,a.y-b.y);}Complex operator *(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void FFT(Complex *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tComplex T(cos(Pi/len),type*sin(Pi/len));\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tComplex t(1,0);\t\t\tfor(int j=i;j&lt;i+len;++j,t=t*T)\t\t\t{\t\t\t\tComplex x=a[j],y=t*a[j+len];\t\t\t\ta[j]=x+y,a[j+len]=x-y;\t\t\t}\t\t}\t}    if(type==1) return;    for(int i=0;i&lt;lim;++i) a[i].x=a[i].x/lim+0.5;}void mul(Complex *f,Complex *g){    int lim=calc(n+m);    FFT(f,lim,1),FFT(g,lim,1);    for(int i=0;i&lt;lim;++i) f[i]=f[i]*g[i];    FFT(f,lim,-1);}int main(){    read(n),read(m);    for(int i=0,x;i&lt;=n;++i) read(x),f[i].x=x;    for(int i=0,x;i&lt;=m;++i) read(x),g[i].x=x;    mul(f,g);    for(int i=0;i&lt;=n+m;++i) printf(\"%d \",(int)f[i].x);    return 0;}\r\n多项式全家桶\r\n#include&lt;bits/stdc++.h&gt;#define maxn 400010#define P 998244353#define G 3#define Gi (P+1)/Gusing namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,k,T,lenth;ll rev[maxn],f[maxn],g[maxn];char s[maxn];ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%P;        x=x*x%P,y&gt;&gt;=1;    }    return v;}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void NTT(ll *a,int lim,int type){    for(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);    for(int len=1;len&lt;lim;len&lt;&lt;=1)    {        ll wn=qp(type==1?G:Gi,(P-1)/(len&lt;&lt;1));        for(int i=0;i&lt;lim;i+=len&lt;&lt;1)        {            ll w=1;            for(int j=i;j&lt;i+len;++j,w=w*wn%P)            {                ll x=a[j],y=w*a[j+len]%P;                a[j]=(x+y)%P,a[j+len]=(x-y+P)%P;            }        }    }    if(type==1) return;    ll inv=qp(lim,P-2);    for(int i=0;i&lt;lim;++i) a[i]=a[i]*inv%P;}void Inv(int deg,ll *a,ll *b){    static ll t[maxn];    if(deg==1)    {        b[0]=qp(a[0],P-2);        return;    }    Inv((deg+1)&gt;&gt;1,a,b);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=b[i]*(2-t[i]*b[i]%P+P)%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Ln(int deg,ll *a,ll *b){    static ll inva[maxn],dera[maxn];    Inv(deg,a,inva);    for(int i=0;i&lt;deg-1;++i) dera[i]=a[i+1]*(i+1)%P;    dera[deg-1]=0;    int lim=calc(deg&lt;&lt;1);    for(int i=deg;i&lt;lim;++i) dera[i]=inva[i]=0;    NTT(dera,lim,1),NTT(inva,lim,1);    for(int i=0;i&lt;lim;++i) b[i]=dera[i]*inva[i]%P;    NTT(b,lim,-1);    for(int i=deg-1;i&gt;=1;--i) b[i]=b[i-1]*qp(i,P-2)%P;    b[0]=0;    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Exp(int deg,ll *a,ll *b){    static ll t[maxn],lnb[maxn];    if(deg==1)    {        b[0]=1;        return;    }    Exp((deg+1)&gt;&gt;1,a,b),Ln(deg,b,lnb);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1),NTT(lnb,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=b[i]*(1-lnb[i]+t[i]+P)%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Pow(int deg,ll *a,ll *b,ll k){    static ll lna[maxn];    Ln(deg,a,lna);    for(int i=0;i&lt;deg;++i) lna[i]=lna[i]*k%P;    Exp(deg,lna,b);}void Sqrt(int deg,ll *a,ll *b){    static ll t[maxn],invb[maxn];    if(deg==1)    {        b[0]=1;        return;    }    Sqrt((deg+1)&gt;&gt;1,a,b);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=2*b[i]%P,invb[i]=0;    for(int i=deg;i&lt;lim;++i) t[i]=invb[i]=0;    Inv(deg,t,invb);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1),NTT(invb,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=(b[i]*b[i]%P+t[i])%P*invb[i]%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}int main(){\tread(n);    for(int i=0;i&lt;n;++i) read(f[i]);    Sqrt(n,f,g);    for(int i=0;i&lt;n;++i) printf(\"%lld \",g[i]);\treturn 0;}\r\n分治 FFT\r\n#include&lt;bits/stdc++.h&gt;#define maxn 400010#define p 998244353using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n;int rev[maxn];ll f[maxn],g[maxn];ll qp(ll x,ll y){\tll v=1;\twhile(y)\t{\t\tif(y&amp;1) v=v*x%p;\t\tx=x*x%p,y&gt;&gt;=1;\t}\treturn v;}int calc(int n){\tint lim=1;\twhile(lim&lt;=n) lim&lt;&lt;=1;\tfor(int i=0;i&lt;lim;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);\treturn lim;}void NTT(ll *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)\t\tif(i&lt;rev[i])\t\t\tswap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tll wn=qp(3,(p-1)/(len&lt;&lt;1));\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tll w=1;\t\t\tfor(int j=i;j&lt;i+len;++j,w=w*wn%p)\t\t\t{\t\t\t\tll x=a[j],y=w*a[j+len]%p;\t\t\t\ta[j]=(x+y)%p,a[j+len]=(x-y+p)%p;\t\t\t}\t\t}\t}\tif(type==1) return;\tll inv=qp(lim,p-2);\tfor(int i=0;i&lt;lim;++i) a[i]=a[i]*inv%p;\treverse(a+1,a+lim);}void Inv(int deg,ll *f,ll *g){\tif(deg==1)\t{\t\tg[0]=qp(f[0],p-2);\t\treturn;\t}\tstatic ll t[maxn];\tInv((deg+1)&gt;&gt;1,f,g);\tint lim=calc(deg&lt;&lt;1);\tfor(int i=0;i&lt;deg;++i) t[i]=f[i];\tfor(int i=deg;i&lt;lim;++i) t[i]=0;\tNTT(t,lim,1),NTT(g,lim,1);\tfor(int i=0;i&lt;lim;++i) g[i]=(2*g[i]-t[i]*g[i]%p*g[i]%p+p)%p;\tNTT(g,lim,-1);\tfor(int i=deg;i&lt;lim;++i) g[i]=0;}int main(){\tread(n),f[0]=1;\tfor(int i=1;i&lt;n;++i) read(f[i]),f[i]=p-f[i];\tInv(n,f,g);\tfor(int i=0;i&lt;n;++i) printf(\"%lld \",g[i]);    return 0;}\r\n任意模数多项式乘法\r\n#include&lt;bits/stdc++.h&gt;#define maxn 800010#define all 262144#define M 32767#define Pi acos(-1.0)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,p;int rev[maxn],f[maxn],g[maxn],h[maxn];struct Complex{\tlong double x,y;\tComplex(long double a=0,long double b=0)\t{\t\tx=a,y=b;\t}}w[maxn];Complex operator +(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x+b.x,a.y+b.y);}Complex operator -(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x-b.x,a.y-b.y);}Complex operator *(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}Complex operator ~(const Complex &amp;a){\treturn Complex(a.x,-a.y);}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void init(int n){    int lim=calc(n);    for(int len=1;len&lt;lim;len&lt;&lt;=1)        for(int i=0;i&lt;len;++i)            w[i+len]=Complex(cos(Pi*i/len),sin(Pi*i/len));}void FFT(Complex *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tfor(int j=0;j&lt;len;++j)\t\t\t{\t\t\t\tComplex x=a[i+j],y=w[j+len]*a[i+j+len];\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\t\t\t}\t\t}\t}    if(type==1) return;    reverse(a+1,a+lim);    for(int i=0;i&lt;lim;++i)        a[i].x=a[i].x/lim+0.5,a[i].y=a[i].y/lim+0.5;} void MTT(int *f,int *g,int *h){    static Complex a[maxn],b[maxn],a0[maxn],b0[maxn];    int lim=calc(n+m);    for(int i=0;i&lt;lim;++i) a[i]=Complex(f[i]&gt;&gt;15,f[i]&amp;M);    for(int i=0;i&lt;lim;++i) b[i]=Complex(g[i]&gt;&gt;15,g[i]&amp;M);    FFT(a,lim,1),FFT(b,lim,1),a0[0]=~a[0],b0[0]=~b[0];    for(int i=1;i&lt;lim;++i) a0[i]=~a[lim-i],b0[i]=~b[lim-i];    for(int i=0;i&lt;lim;++i)    {        Complex v1=a[i],v2=a0[i],v3=b[i],v4=b0[i];        a[i]=(v1+v2)*Complex(0.5,0),a0[i]=(v1-v2)*Complex(0,-0.5);        b[i]=(v3+v4)*Complex(0.5,0),b0[i]=(v3-v4)*Complex(0,-0.5);    }    for(int i=0;i&lt;lim;++i)        a[i]=a[i]*b[i]+(a[i]*b0[i]+a0[i]*b[i])*Complex(0,1),b[i]=a0[i]*b0[i];    FFT(a,lim,-1),FFT(b,lim,-1);    for(int i=0;i&lt;lim;++i)        h[i]=((((ll)a[i].x%p&lt;&lt;30)%p+((ll)a[i].y%p&lt;&lt;15)%p)%p+(ll)b[i].x)%p;}int main(){    read(n),read(m),read(p),n++,m++,init(n+m);    for(int i=0;i&lt;n;++i) read(f[i]),f[i]%=p;    for(int i=0;i&lt;m;++i) read(g[i]),g[i]%=p;    MTT(f,g,h);    for(int i=0;i&lt;n+m-1;++i) printf(\"%d \",h[i]);    return 0;}\r\nFWT\r\n#include&lt;bits/stdc++.h&gt;#define maxn 131082#define p 998244353#define inv 499122177using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,all;ll va[maxn],vb[maxn],a[maxn],b[maxn];void FWT_or(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t\ta[j+len]=(a[j+len]+a[j]*type+p)%p;}void FWT_and(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t\ta[j]=(a[j]+a[j+len]*type+p)%p;}void FWT_xor(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t{\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t{\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t{\t\t\t\tll x=a[j],y=a[j+len];\t\t\t\ta[j]=(x+y)%p,a[j+len]=(x-y+p)%p;\t\t\t\tif(type==-1) a[j]=a[j]*inv%p,a[j+len]=a[j+len]*inv%p;\t\t\t}\t\t}\t}}void copy(){\tmemcpy(a,va,sizeof(va)),memcpy(b,vb,sizeof(vb));}void Or(){\tcopy(),FWT_or(a,1),FWT_or(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_or(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\tputchar('\\n');}void And(){\tcopy(),FWT_and(a,1),FWT_and(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_and(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\t\tputchar('\\n');}void Xor(){\tcopy(),FWT_xor(a,1),FWT_xor(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_xor(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\tputchar('\\n');}int main(){\tread(n),all=1&lt;&lt;n;\tfor(int i=0;i&lt;all;++i) read(va[i]);\tfor(int i=0;i&lt;all;++i) read(vb[i]);\tOr(),And(),Xor();    return 0;}\r\n子集卷积\r\n#include&lt;bits/stdc++.h&gt;#define maxn 21#define maxs 1200010#define p 1000000009#define lowbit(x) (x&amp;(-x))using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,all;int cnt[maxs],h[maxn][maxs],f[maxn][maxs],g[maxn][maxs];void FWT(int *a,int type){    for(int len=1;len&lt;all;len&lt;&lt;=1)        for(int i=0;i&lt;all;i+=len&lt;&lt;1)            for(int j=i;j&lt;i+len;++j)                a[j+len]=((a[j+len]+a[j]*type)%p+p)%p;}int main(){    read(n),all=1&lt;&lt;n;    for(int i=1;i&lt;all;++i) cnt[i]=cnt[i-lowbit(i)]+1;    for(int i=0;i&lt;all;++i) read(f[cnt[i]][i]);    for(int i=0;i&lt;all;++i) read(g[cnt[i]][i]);    for(int i=0;i&lt;=n;++i) FWT(f[i],1),FWT(g[i],1);    for(int i=0;i&lt;=n;++i)        for(int j=0;j&lt;=i;++j)            for(int s=0;s&lt;all;++s)                h[i][s]=(h[i][s]+(ll)f[i-j][s]*g[j][s]%p)%p;    for(int i=0;i&lt;=n;++i) FWT(h[i],-1);    for(int i=0;i&lt;all;++i) printf(\"%lld \",h[cnt[i]][i]);    return 0;}\r\n拉格朗日插值法\r\n 个点  可以唯一地确定一个多项式 。现在，给定这  个点，请你确定这个多项式，并求出  的值。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 2010#define mod 998244353using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,k,ans;ll x[maxn],y[maxn];ll qp(ll x,ll y){\tll ans=1;\twhile(y)\t{\t\tif(y&amp;1) ans=(ans*x)%mod;\t\tx=(x*x)%mod;\t\ty&gt;&gt;=1;\t}\treturn ans;}int main(){\tread(n),read(k);\tfor(int i=1;i&lt;=n;++i) read(x[i]),read(y[i]);\tfor(int i=1;i&lt;=n;++i)\t{\t\tll p=1;\t\tfor(int j=1;j&lt;=n;++j)\t\t\tif(i!=j)\t\t\t\tp=p*(((x[i]-x[j])%mod+mod)%mod)%mod;\t\tp=qp(p,mod-2);\t\tfor(int j=1;j&lt;=n;++j)\t\t\tif(i!=j)\t\t\t\tp=p*(((k-x[j])%mod+mod)%mod)%mod;\t\tp=p*y[i]%mod;\t\tans=(ans+p)%mod;\t}\tprintf(\"%lld\\n\",ans);\treturn 0;}\r\n矩阵树定理\r\n给定一张  个结点 \r\n条边的带权图（可能为无向图，可能为有向图）。定义其一个生成树  的权值为 \r\n中所有边权的乘积。求其所有不同生成树的权值之和，对  取模。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 310#define p 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,type;ll a[maxn][maxn];void add1(int x,int y,int v){    a[x][x]=(a[x][x]+v)%p;    a[y][y]=(a[y][y]+v)%p;    a[x][y]=(a[x][y]-v)%p;    a[y][x]=(a[y][x]-v)%p;}void add2(int x,int y,int v){    a[y][y]=(a[y][y]+v)%p;    a[x][y]=(a[x][y]-v)%p;}ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll det(){    ll ans=1;    for(int i=2;i&lt;=n;++i)    {        int ma=i;        for(int j=i+1;j&lt;=n;++j)            if(a[j][i]&gt;a[ma][i])                ma=j;        if(ma!=i) swap(a[i],a[ma]),ans*=-1;        if(!a[i][i]) return 0;        ll inv=qp(a[i][i],p-2);        for(int j=i+1;j&lt;=n;++j)        {            ll d=a[j][i]*inv%p;            for(int k=i;k&lt;=n;++k) a[j][k]=((a[j][k]-a[i][k]*d%p)%p+p)%p;        }        ans=ans*a[i][i]%p;    }    return (ans%p+p)%p;}int main(){    read(n),read(m),read(type);    for(int i=1;i&lt;=m;++i)    {        int a,b,v;        read(a),read(b),read(v);        if(!type) add1(a,b,v);        else add2(a,b,v);    }    printf(\"%lld\",det());    return 0;}\r\n高斯消元\r\n#include&lt;bits/stdc++.h&gt;#define maxn 110#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n;double a[maxn][maxn];bool gauss(){    for(int i=1;i&lt;=n;++i)    {        int ma=i;        for(int j=i+1;j&lt;=n;++j)            if(fabs(a[j][i])&gt;fabs(a[ma][i]))                ma=j;        swap(a[ma],a[i]);        double d=a[i][i];        if(fabs(d)&lt;eps) return false;        for(int j=i;j&lt;=n+1;++j) a[i][j]/=d;        for(int j=i+1;j&lt;=n;++j)        {            d=a[j][i];            for(int k=i;k&lt;=n+1;++k)                a[j][k]-=a[i][k]*d;        }    }    for(int i=n;i;--i)        for(int j=i-1;j;--j)            a[j][n+1]-=a[j][i]*a[i][n+1];    return true;}int main(){\tread(n);    for(int i=1;i&lt;=n;++i)    {        for(int j=1;j&lt;=n+1;++j)        {            int val;            read(val);            a[i][j]=val;        }    }    if(!gauss())    {        puts(\"No Solution\");        return 0;    }    for(int i=1;i&lt;=n;++i)         printf(\"%.2lf\\n\",a[i][n+1]);\treturn 0;}\r\n矩阵求逆\r\n#include&lt;bits/stdc++.h&gt;#define maxn 810#define mod 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m;ll a[maxn][maxn];ll inv(ll x){    ll y=mod-2,ans=1;    while(y)    {        if(y&amp;1) ans=ans*x%mod;        x=x*x%mod;        y&gt;&gt;=1;    }    return ans;}bool gauss(){    for(int i=1;i&lt;=n;++i)    {        for(int j=i;j&lt;=n;++j)        {               if(a[j][i])            {                swap(a[j],a[i]);                break;            }        }        if(!a[i][i]) return false;        ll d=inv(a[i][i]);        for(int j=i;j&lt;=m;++j) a[i][j]=a[i][j]*d%mod;        for(int j=1;j&lt;=n;++j)        {            if(i==j) continue;            d=a[j][i]%mod;            for(int k=i;k&lt;=m;++k)                a[j][k]=((a[j][k]-a[i][k]*d%mod)%mod+mod)%mod;        }    }    return true;}int main(){    read(n),m=2*n;    for(int i=1;i&lt;=n;++i)    {        for(int j=1;j&lt;=n;++j) read(a[i][j]);        a[i][i+n]=1;    }    if(gauss())    {        for(int i=1;i&lt;=n;++i)        {            for(int j=n+1;j&lt;=m;++j)                printf(\"%lld \",a[i][j]);            puts(\"\");        }    }    else puts(\"No Solution\");    return 0;}\r\n欧拉筛\r\nvoid init(){    mu[1]=1;    for(int i=2;i&lt;=all;++i)    {        if(!tag[i]) pri[++tot]=i,mu[i]=-1;        for(int j=1;j&lt;=tot;++j)        {            int k=i*pri[j];            if(k&gt;all) break;            tag[k]=true;            if(i%pri[j]) mu[k]=mu[i]*mu[pri[j]];            else            {                mu[k]=0;                break;            }        }    }}\r\nPollard's rho\r\n求最大质因子。\r\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll T,n,fac_max;ll pri[14]={2,3,5,7,11,13,17,19,23,29};ll mul(ll x,ll y,ll mod){\tll c=(long double)x*y/mod+0.5;\tc=x*y-c*mod;\treturn c&lt;0?c+mod:c;}ll qp(ll x,ll y,ll mod){    ll ans=1;    while(y)    {        if(y&amp;1) ans=mul(ans,x,mod);        x=mul(x,x,mod);        y&gt;&gt;=1;    }    return ans%mod;}bool check(ll x,ll p,ll mod){    ll t=qp(x,p,mod);    if(t==mod-1) return true;    if(t==1) return p&amp;1?true:check(x,p/2,mod);    return false;}bool Miller_Rabin(ll n){    if(n==1) return false;    if(n&lt;=3) return true;    if(!(n&amp;1)) false;    for(int i=0;i&lt;10;++i)    {        if(n==pri[i]) return true;        if(!check(pri[i],n-1,n)) return false;    }    return true;}ll gcd(ll a,ll b){    return b?gcd(b,a%b):a;}ll f(ll x,ll y,ll mod){    return (mul(x,x,mod)+y)%mod;}ll Pollard_Rho(ll x){    ll s=0,t=0,c=(ll)1*rand()%(x-1)+1,val=1;    for(ll goal=1;;goal&lt;&lt;=1,s=t,val=1)    {        for(ll step=1;step&lt;=goal;++step)        {            t=f(t,c,x);            val=mul(val,abs(t-s),x);            if(step%127==0)            {                ll d=gcd(val,x);                if(d&gt;1) return d;            }        }        ll d=gcd(val,x);        if(d&gt;1) return d;    }}void fac(ll x){    if(x&lt;=fac_max||x&lt;2) return;    if(Miller_Rabin(x))     {        fac_max=max(fac_max,x);        return;    }    ll p=x;    while(p&gt;=x) p=Pollard_Rho(x);    while(x%p==0) x/=p;    fac(x),fac(p);}int main(){    read(T);    while(T--)    {        srand(114514);        read(n);        fac_max=0;        fac(n);        if(fac_max==n) puts(\"Prime\");        else printf(\"%lld\\n\",fac_max);    }\treturn 0;}\r\n杜教筛\r\n求  的前缀和。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 5000010#define all 5000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n,tot;ll p[maxn],phi[maxn],mu[maxn];bool tag[maxn];unordered_map&lt;int,ll&gt; s_phi,s_mu;void init(){    mu[1]=phi[1]=1;    for(int i=2;i&lt;=all;++i)    {        if(!tag[i]) p[++tot]=i,phi[i]=i-1,mu[i]=-1;        for(int j=1;j&lt;=tot;++j)        {            int k=i*p[j];            if(k&gt;all) break;            tag[k]=true;            if(i%p[j]) phi[k]=phi[i]*phi[p[j]],mu[k]=mu[i]*mu[p[j]];            else            {                mu[k]=0,phi[k]=phi[i]*p[j];                break;               }        }    }    for(int i=1;i&lt;=all;++i) phi[i]+=phi[i-1],mu[i]+=mu[i-1];}ll getphi(ll n){    if(n&lt;=all) return phi[n];    if(s_phi[n]) return s_phi[n];    ll v=n*(n+1)/2;    for(int l=2,r;l&lt;=n;l=r+1)        r=n/(n/l),v-=(r-l+1)*getphi(n/l);    return s_phi[n]=v;}ll getmu(ll n){    if(n&lt;=all) return mu[n];    if(s_mu[n]) return s_mu[n];    ll v=1;    for(int l=2,r;l&lt;=n;l=r+1)        r=n/(n/l),v-=(r-l+1)*getmu(n/l);    return s_mu[n]=v;}int main(){    init(),read(T);    while(T--) read(n),printf(\"%lld %lld\\n\",getphi(n),getmu(n));    return 0;}\r\n扩展 BSGS\r\n给定 ，求满足  的最小自然数 。\r\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll a,b,p,x,y,ans;unordered_map&lt;ll,int&gt; h;ll qp(ll x,ll y,ll p){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll exgcd(ll a,ll b){    if(!b)    {        x=1,y=0;        return a;    }    ll g=exgcd(b,a%b),tmp=x;    x=y,y=tmp-a/b*y;    return g;}ll inv(ll a,ll p){    exgcd(a,p);    return (x%p+p)%p;}ll bsgs(ll a,ll b,ll p){    ll s=ceil(sqrt(p)),v=b,val;    for(int i=0;i&lt;=s;++i,v=v*a%p) h[v]=i;    v=val=qp(a,s,p);    for(int i=1;i&lt;=s;++i,v=v*val%p)        if(h.count(v))            return i*s-h[v];    return -1;}ll exbsgs(ll a,ll b,ll p){    a%=p,b%=p;    if(b==1||p==1) return 0;    ll g,cnt=0,mul=1,v=a;    for(int i=1;i&lt;=30;++i,v=v*a%p)        if(v==b)            return i;    while((g=exgcd(a,p))!=1)    {        if(b%g!=0) return -1;        cnt++,b/=g,p/=g,mul=mul*(a/g)%p;    }    ll ans=bsgs(a,b*inv(mul,p)%p,p);    if(~ans) return ans+cnt;    return -1;}int main(){    while(1)    {        read(a),read(p),read(b);        if(!a&amp;&amp;!b&amp;&amp;!p) break;        h.clear(),ans=exbsgs(a,b,p);        if(~ans) printf(\"%lld\\n\",ans);        else puts(\"No Solution\");    }\treturn 0;}\r\n扩展中国剩余定理\r\n给定  组非负整数  ，求解关于  的方程组的最小非负整数解。 \r\n#include&lt;bits/stdc++.h&gt;#define maxn 100010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll n,x,y;ll a[maxn],m[maxn];ll mul(ll x,ll y,ll mod){    ll ans=0;    while(y)     {        if(y&amp;1) ans=(ans+x)%mod;        x=(x+x)%mod;        y&gt;&gt;=1;    }    return ans%mod;}ll exgcd(ll a,ll b){    if(!b)    {        x=1,y=0;        return a;    }    ll ans=exgcd(b,a%b);    ll tmp=x;    x=y,y=tmp-a/b*y;    return ans;}ll excrt(){    ll ans=a[1],M=m[1];    for(int i=2;i&lt;=n;++i)    {        ll g=exgcd(M,m[i]),tmp=((a[i]-ans)%m[i]+m[i])%m[i];        if(tmp%g!=0) return -1;        ans+=mul(x,tmp/g,m[i])*M,M*=m[i]/g,ans=(ans%M+M)%M;    }    return ans;}int main(){    read(n);    for(int i=1;i&lt;=n;++i) read(m[i]),read(a[i]);    printf(\"%lld\",excrt());\treturn 0;}\r\n扩展欧拉定理\r\n给你三个正整数，，你需要求：。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 20000010 using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll a,m,b,phi,len;char s[maxn];bool flag;ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%m;        x=x*x%m,y&gt;&gt;=1;    }    return v%m;}ll get_phi(ll x){\tll v=x,t=sqrt(x);\tfor(int i=2;i&lt;=t;++i)    {\t\tif(x%i) continue;\t\tv=v*(i-1)/i;\t\twhile(x%i==0) x/=i;\t}\tif(x&gt;1) v=v*(x-1)/x;\treturn v;}int main(){\tread(a),read(m),phi=get_phi(m);    scanf(\"%s\",s+1),len=strlen(s+1);    for(int i=1;i&lt;=len;++i)     {        b=((b&lt;&lt;1)+(b&lt;&lt;3)+(s[i]^48));        if(b&gt;=phi) b%=phi,flag=true;    }    if(flag) b+=phi;    printf(\"%lld\",qp(a,b));\treturn 0;}\r\n扩展卢卡斯定理\r\n求 。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 12#define maxm 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,p,cnt;ll pri[maxn],pk[maxn],a[maxn][maxm];void exgcd(ll a,ll b,ll &amp;x,ll &amp;y){    if(!b) x=1,y=0;    else exgcd(b,a%b,y,x),y-=a/b*x;}ll inv(ll a,ll p){    ll x,y;    exgcd(a,p,x,y);    return (x%p+p)%p;}ll qp(ll x,ll y,ll p){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll f(ll n,int x){    if(!n) return 1;    ll k=pk[x];    return f(n/pri[x],x)*qp(a[x][k],n/k,k)%k*a[x][n%k]%k;}ll C(ll n,ll m,int x){    ll v=0,p=pri[x],k=pk[x];    for(ll i=n;i;i=i/p) v+=i/p;    for(ll i=m;i;i=i/p) v-=i/p;    for(ll i=n-m;i;i=i/p) v-=i/p;    return f(n,x)*inv(f(m,x),k)%k*inv(f(n-m,x),k)%k*qp(p,v,k)%k;}ll crt(ll x,ll m,ll p){    return x*(m/p)*inv(m/p,p);}ll exlucas(ll n,ll m){    ll v=0;    for(int i=1;i&lt;=cnt;++i) v=(v+crt(C(n,m,i),p,pk[i]))%p;    return v;}void init(int x){    a[x][0]=1;    for(int i=1;i&lt;=pk[x];++i)    {        a[x][i]=a[x][i-1];        if(i%pri[x]) a[x][i]=a[x][i]*i%pk[x];    }}void pre(ll x){    for(int i=2;i*i&lt;=x;++i)    {        if(x%i) continue;        ll v=1;        while(x%i==0) x/=i,v*=i;        pri[++cnt]=i,pk[cnt]=v;    }    if(x!=1) pri[++cnt]=x,pk[cnt]=x;    for(int i=1;i&lt;=cnt;++i) init(i);}int main(){    read(n),read(m),read(p),pre(p),printf(\"%lld\",exlucas(n,m));    return 0;}\r\n二次剩余\r\n给出 ，求解方程 ，保证  是奇素数。\r\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n,p,t,v1,v2;struct Complex{    ll x,y;    Complex(ll a=0,ll b=0)    {        x=a,y=b;    }};Complex operator * (const Complex &amp;a,const Complex &amp;b){    return Complex((a.x*b.x%p+a.y*b.y%p*t%p)%p,(a.x*b.y%p+a.y*b.x%p)%p);}Complex qp(Complex x,ll y){    Complex v=Complex(1,0);    while(y)    {        if(y&amp;1) v=v*x;        x=x*x,y&gt;&gt;=1;    }    return v;}ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll solve(ll n,ll p){    if(p==2) return n;    if(qp(n,(p-1)/2)==p-1) return -1;    ll a;    while(true)    {        a=rand()%p,t=((a*a%p-n)%p+p)%p;        if(qp(t,(p-1)/2)==p-1) break;    }    return qp(Complex(a,1),(p+1)/2).x;}int main(){    read(T);    while(T--)    {        read(n),read(p),n%=p;        if(!n)        {            puts(\"0\");            continue;        }        v1=solve(n,p);        if(v1==-1)        {            puts(\"Hola!\");            continue;        }        v2=p-v1;        if(v1&gt;v2) swap(v1,v2);        if(v1==v2) printf(\"%lld\\n\",v1);        else printf(\"%lld %lld\\n\",v1,v2);    }    return 0;}\r\n杂项\r\n矩阵快速幂\r\n#include&lt;bits/stdc++.h&gt;#define p 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n;struct matrix{    ll a[6][6];    matrix()    {        memset(a,0,sizeof(a));    }}m,ans;matrix operator *(const matrix &amp;a,const matrix &amp;b){    matrix c;    for(int i=0;i&lt;5;++i)        for(int j=0;j&lt;5;++j)            for(int k=0;k&lt;5;++k)                c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%p+p)%p;    return c;}matrix qp(matrix x,ll y){    matrix e;    for(int i=0;i&lt;5;++i) e.a[i][i]=1;    while(y)    {        if(y&amp;1) e=e*x;        x=x*x,y&gt;&gt;=1;    }    return e;}ll m1[6][6]={    {2,0,1,1,1}};ll m2[6][6]={    {1,1,0,0,0},    {1,0,0,0,0},    {2,0,1,1,1},    {0,0,1,0,0},    {2,0,0,0,1}};int main(){    read(T);    memcpy(ans.a,m1,sizeof(ans.a));    memcpy(m.a,m2,sizeof(m.a));    while(T--)    {        read(n);        if(n&lt;3) puts(\"0\");        else printf(\"%lld\\n\",(ans*qp(m,n-3)).a[0][0]);    }    return 0;}\r\n模拟退火\r\n最大化\r\n#include&lt;bits/stdc++.h&gt;#define maxn 55#define eps 1e-10using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,ans,cnt=1000;struct node{    int a,b;}p[maxn];int calc(){    int v=0;    for(int i=1;i&lt;=n+m;++i)    {        v+=p[i].a+p[i].b;        if(p[i-1].a==10) v+=p[i].a+p[i].b;        else if(p[i-1].a+p[i-1].b==10) v+=p[i].a;    }    return v;}void SA(){    double T=1000000,delta=0.9895;\twhile(T&gt;eps)\t{\t\tint x=rand()%(n+m)+1,y=rand()%(n+m)+1,v;        while(x==y||(m&amp;&amp;(x==n||y==n))) x=rand()%(n+m)+1,y=rand()%(n+m)+1;\t\tswap(p[x],p[y]),v=calc();\t\tif(v&gt;ans) ans=v;\t\telse if(exp((v-ans)/T)*RAND_MAX&lt;rand()) swap(p[x],p[y]);\t\tT*=delta;\t}}int main(){    srand((long long)new char),read(n);    for(int i=1;i&lt;=n;++i) read(p[i].a),read(p[i].b);    if(p[n].a==10) m=1,read(p[n+1].a),read(p[n+1].b);    while(cnt--) SA();    printf(\"%d\",ans);    return 0;}\r\n最小化\r\n#include&lt;bits/stdc++.h&gt;#define maxn 35#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=x*10+(c^48);c=getchar();}\tif(flag)x=-x;}int t,n,num;int a[maxn];int ans;int work(){\tint u=0,v=0;\tfor(int i=1;i&lt;=(n+1)/2;++i) u+=a[i];\tfor(int i=(n+1)/2+1;i&lt;=n;++i) v+=a[i];\treturn abs(u-v);}void SA(){\tdouble T=3000,delta=0.925;\twhile(T&gt;1e-10)\t{\t\tint x=rand()%n+1, y=rand()%n+1;\t\tswap(a[x],a[y]);\t\tint now=work();\t\tif(now&lt;ans) ans=now;\t\telse if(exp((ans-now)/T)*RAND_MAX&lt;rand())  swap(a[x],a[y]);\t\tT*=delta;\t}}void clear(){\tans=inf;\tnum=1111;}int main(){\tsrand(19260817);\tread(t);\twhile(t--)\t{\t\tclear();\t\tread(n);\t\tfor(int i=1;i&lt;=n;++i) read(a[i]);\t\twhile(num--) SA();\t\tprintf(\"%d\\n\",ans);\t}\treturn 0;}\r\n整体二分\r\n带修区间第  小。\r\n#include&lt;bits/stdc++.h&gt;#define maxn 600010#define inf 1000000000#define lowbit(x) (x&amp;(-x))using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt;int a[maxn],ans[maxn],tr[maxn];char s[8];struct node{    int l,r,k,id,pos;}p[maxn],q1[maxn],q2[maxn];void update(int x,int v){    while(x&lt;=n)        tr[x]+=v,x+=lowbit(x);}int query(int x){    int ans=0;    while(x)        ans+=tr[x],x-=lowbit(x);    return ans;}void solve(int L,int R,int l,int r){    if(L&gt;R) return;    if(l==r)    {        for(int i=L;i&lt;=R;++i)            if(p[i].l)                ans[p[i].id]=l;        return;    }    int mid=(l+r)&gt;&gt;1,cnt1=0,cnt2=0;    for(int i=L;i&lt;=R;++i)    {        if(p[i].l)        {            int v=query(p[i].r)-query(p[i].l-1);            if(p[i].k&lt;=v) q1[++cnt1]=p[i];            else p[i].k-=v,q2[++cnt2]=p[i];        }        else        {            if(p[i].k&lt;=mid) q1[++cnt1]=p[i],update(p[i].pos,p[i].id);            else q2[++cnt2]=p[i];        }    }    for(int i=1;i&lt;=cnt1;++i) p[L+i-1]=q1[i];    for(int i=1;i&lt;=cnt2;++i) p[L+cnt1+i-1]=q2[i];    for(int i=1;i&lt;=cnt1;++i)        if(q1[i].pos)            update(q1[i].pos,-q1[i].id);    solve(L,L+cnt1-1,l,mid),solve(L+cnt1,R,mid+1,r);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i)        read(a[i]),p[++cnt].k=a[i],p[cnt].pos=i,p[cnt].id=1;    for(int i=1;i&lt;=m;++i)    {        scanf(\"%s\",s);        if(s[0]=='Q')            read(p[++cnt].l),read(p[cnt].r),read(p[cnt].k),p[cnt].id=i;        else        {            int x,y;            read(x),read(y);            p[++cnt].k=a[x],p[cnt].pos=x,p[cnt].id=-1;            p[++cnt].k=a[x]=y,p[cnt].pos=x,p[cnt].id=1;        }    }    solve(1,cnt,-inf,inf);    for(int i=1;i&lt;=cnt;++i)        if(ans[i])            printf(\"%d\\n\",ans[i]);    return 0;}\r\n树哈希\r\n#include&lt;bits/stdc++.h&gt;#define fi first#define se second#define mp make_pair#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;template&lt;typename T&gt; bool chkmax(T &amp;x,T y){return x&lt;y?x=y,1:0;}template&lt;typename T&gt; bool chkmin(T &amp;x,T y){return x&gt;y?x=y,1:0;}int readint(){\tint x=0,f=1; char ch=getchar();\twhile(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\treturn x*f;}int n,tot,cnt;int v[2000005],nxt[2000005],h[1000005];ull hs[1000005];mt19937_64 mrand(chrono::steady_clock::now().time_since_epoch().count());void addedge(int x,int y){\tv[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\tv[++tot]=x; nxt[tot]=h[y]; h[y]=tot;}ull f(ull x){return x*x*x+x+7;}ull calc(ull x){return f(x);}void dfs(int u,int fa){\ths[u]=1;\tfor(int p=h[u];p;p=nxt[p]){\t\tif(v[p]==fa) continue;\t\tdfs(v[p],u);\t\ths[u]+=hs[v[p]];\t}\ths[u]=calc(hs[u]);}int main(){\tn=readint();\tfor(int i=1;i&lt;n;i++) addedge(readint(),readint());\tdfs(1,-1);\tsort(hs+1,hs+n+1);\tprintf(\"%d\\n\",unique(hs+1,hs+n+1)-hs-1);\treturn 0;}\r\nPrufer 序列\r\n#include&lt;bits/stdc++.h&gt;#define maxn 5000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;ll ans;ll fa[maxn],p[maxn],d[maxn];void Prufer(){    for(int i=1;i&lt;n;++i) read(fa[i]),d[fa[i]]++;    int pos=1;    for(int i=1;i&lt;=n-2;++i)    {        while(d[pos]) pos++;        p[i]=fa[pos];        while(i&lt;=n-2&amp;&amp;--d[p[i]]==0&amp;&amp;p[i]&lt;pos) p[i+1]=fa[p[i]],i++;        pos++;    }    for(int i=1;i&lt;=n-2;++i) ans^=i*p[i];}void Father(){    for(int i=1;i&lt;=n-2;++i) read(p[i]),d[p[i]]++;    p[n-1]=n;    int pos=1;    for(int i=1;i&lt;n;++i)    {        while(d[pos]) pos++;        fa[pos]=p[i];        while(i&lt;n&amp;&amp;--d[p[i]]==0&amp;&amp;p[i]&lt;pos) fa[p[i]]=p[i+1],i++;        pos++;    }    for(int i=1;i&lt;n;++i) ans^=i*fa[i];}int main(){    read(n),read(m);    if(m==1) Prufer();    else Father();    printf(\"%lld\",ans);    return 0;}\r\n高精度\r\nstruct bign{     int len, s[30005];    bign (){        memset(s, 0, sizeof(s));        len = 1;    }    bign (int num) { *this = num; }    bign (const char *num) { *this = num; }    bign operator = (const int num){        char s[30005];        sprintf(s, \"%d\", num);        *this = s;        return *this;    }    void clean(){        while(len &gt; 1 &amp;&amp; !s[len-1]) len--;    }     bign operator = (const char *num){        memset(s, 0, sizeof s);        len = strlen(num);        for(int i = 0; i &lt; len; i++) {            if (isdigit(num[len-i-1])) s[i] = num[len-i-1] - '0';            else s[i] = num[len-i-1] - 'A' + 10;        }        clean();        return *this;    }    bign operator + (const bign &amp;b) const{        bign c;        c.len = max(len, b.len);        for (int i = 0; i &lt; c.len; i++){            c.s[i] += s[i] + b.s[i];            c.s[i+1] += c.s[i] / 10;            c.s[i] %= 10;        }        if (c.s[c.len]) c.len++;        c.clean();        return c;    }    bign operator += (const bign &amp;b){        *this = *this + b;        return *this;    }    bign operator * (const bign &amp;b) {        bign c;        c.len = len + b.len;        for(int i = 0; i &lt; len; i++)            for(int j = 0; j &lt; b.len; j++){                c.s[i+j] += s[i] * b.s[j];            }        for(int i = 0; i &lt; c.len; i++){            c.s[i+1] += c.s[i]/10;            c.s[i] %= 10;        }        c.clean();        return c;    }    bign operator *= (const bign &amp;b){        *this = *this * b;        return *this;    }    bign operator - (const bign &amp;b){        bign c;        c.len = 0;        for(int i = 0, g = 0; i &lt; len; i++){            int x = s[i] - g;            if(i &lt; b.len) x -= b.s[i];            if(x &gt;= 0) g = 0;            else{                g = 1;                x += 10;            }            c.s[c.len++] = x;        }        c.clean();        return c;    }    bign operator -= (const bign &amp;b){        *this = *this - b;        return *this;    }    bign operator / (const int &amp;b){        int f = 0;        bign c;        for (int i = len-1; i &gt;= 0; i--){            f = f *10 + s[i];            c.s[i] = f / b;            f %= b;        }        c.len = len;        c.clean();        return c;    }    bign operator / (const bign &amp;b){        bign c, f = 0;        for(int i = len-1; i &gt;= 0; i--){            f = f*10;             f.s[0] = s[i];             while(f &gt; b || f == b){                f -= b;                c.s[i]++;            }        }        c.len = len;        c.clean();        return c;    }    bign operator /= (const bign &amp;b){        *this  = *this / b;        return *this;    }    bign operator % (const bign &amp;b){        bign r = *this / b;        r = *this - r*b;        return r;    }    bign operator %= (const bign &amp;b){        *this = *this % b;        return *this;    }    bool operator &lt; (const bign &amp;b){        if(len != b.len) return len &lt; b.len;        for(int i = len-1; i &gt;= 0; i--){            if(s[i] != b.s[i]) return s[i] &lt; b.s[i];        }        return false;    }    bool operator &gt; (const bign &amp;b){        if(len != b.len) return len &gt; b.len;        for(int i = len-1; i &gt;= 0; i--){            if(s[i] != b.s[i]) return s[i] &gt; b.s[i];        }        return false;    }    bool operator == (const bign &amp;b){        return !(*this &gt; b) &amp;&amp; !(*this &lt; b);    }    string str() const{        string res = \"\";         for (int i = 0; i &lt; len; i++) {            if (s[i] &lt; 10) res = char(s[i]+'0') + res;            else res = char(s[i] + 'A' - 10) + res;        }        return res;    }} a, b, c;\r\n","categories":["算法竞赛"],"tags":["模板"]}]
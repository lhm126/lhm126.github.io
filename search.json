[{"title":"7.17 ç»„ä¼š","url":"/2023/07/16/7.17%20%E7%BB%84%E4%BC%9A/","content":"Chaitanya K. Joshi, Thomas Laurent, and Xavier Bresson. â€œAn Efficient Graph Convolutional Network Technique for the Travelling Salesman Problem.â€, Computing Research Repository abs/1906.01227 (2019)\nå’Œ  ä¸­çš„ä¸€æ ·ï¼Œç¥ç»ç½‘ç»œçš„è¾“å‡º  è¡¨ç¤ºè¯¥è¾¹åœ¨å›¾çš„æœ€ä¼˜è§£ä¸­çš„æ¦‚ç‡ï¼ŒæŸå¤±å‡½æ•°ä¸º  å’Œæœ€ä¼˜è§£çš„äº¤å‰ç†µæŸå¤±ï¼Œå³ä¸ºå°†é—®é¢˜çœ‹ä½œä¸ºä¸€ä¸ªåˆ†ç±»é—®é¢˜ã€‚\nå¾—åˆ°  åï¼Œé€šè¿‡æŸæœç´¢æ¥æ±‚è§£é—®é¢˜ã€‚\nWouter Kool, Herke van Hoof, and Max Welling. â€œAttention, Learn to Solve Routing Problems!â€, arXiv: Machine Learning (2019)\næ–‡ç« ç”±  æå‡ºäº†ä¸€ä¸ªåŸºäºæ³¨æ„åŠ›å±‚çš„æ¨¡å‹ï¼Œå¹¶ç”¨  ç®—æ³•æ¥è®­ç»ƒæ¨¡å‹ã€‚\nå°†  é—®é¢˜çš„è§£å®šä¹‰ä¸º ï¼Œæ˜¯èŠ‚ç‚¹çš„ä¸€ä¸ªæ’åˆ—ã€‚åŸºäºé—®é¢˜å®ä¾‹  æ‰¾åˆ°è§£  çš„éšæœºç­–ç•¥ï¼š\n\np_\\theta(\\pi|s)=\\prod_{t=1}^np_\\theta(\\pi_t|s,\\pi_{1:t-1})Encoder\næ²¡æœ‰é‡‡ç”¨ä½ç½®ç¼–ç ï¼Œè¾“å…¥çš„èŠ‚ç‚¹æ— æ¬¡åºä¹‹åˆ†ã€‚\nå…ˆå°†ç»´åº¦ä¸º  çš„èŠ‚ç‚¹åæ ‡ç‰¹å¾  åµŒå…¥åˆ°ç»´åº¦ä¸º  çš„å‘é‡  ä¸­ï¼š\n\n\\text{h}_i^{(0)}=W^{\\text{x}}\\text{x}_i+b^{\\text{x}}ç„¶å  é€šè¿‡  å±‚æ³¨æ„åŠ›å±‚æ¥æ›´æ–°ï¼ˆå®éªŒä¸­ ï¼‰ï¼Œç±»ä¼¼äº ï¼Œæ³¨æ„åŠ›å±‚æ¯ä¸€å±‚åŒ…å«ä¸¤ä¸ªå­å±‚ï¼Œä¸€ä¸ª  å¤´æ³¨æ„åŠ›å±‚ï¼ˆï¼‰å’Œä¸€ä¸ªå…¨è¿æ¥å±‚ï¼ˆï¼‰ï¼Œæ¯ä¸ªå­å±‚ä¸­è¿˜æœ‰æ®‹å·®é“¾æ¥å’Œæ‰¹å½’ä¸€åŒ–ï¼š\n\n\\begin{aligned}\n\\hat{\\text{h}}_i&=\\text{BN}^l(\\text{h}_i^{(l-1)}+\\text{MHA}_i^l(\\text{h}_1^{(l-1)},\\dots,\\text{h}_n^{(l-1)})) \\\\\n\\text{h}_i^{(l)}&=\\text{BN}^l(\\hat{\\text{h}}_i+\\text{FF}^l(\\hat{\\text{h}}_i))\n\\end{aligned}é€šè¿‡  å¾—åˆ°ç‚¹åµŒå…¥  å’Œå›¾åµŒå…¥ ï¼Œéƒ½ä½œä¸º  çš„è¾“å…¥ã€‚\nAttention mechanism\n\\begin{aligned}\n\\text q_i &= W^Q\\text h_i,\\text k_i=W^K \\text h_i,\\text v_i=W^V \\text h_i \\\\\nu_{ij}&=\n\\begin{cases}\n\\frac{\\text q_i^T\\text k_j}{\\sqrt d_k} & \\text{if}\\ i \\ \\text{adjacent to}\\ j\\\\\n- \\infty & \\text{otherwise}\n\\end{cases} \\\\\na_{ij}&=\\frac{e^{u_{ij}}}{\\sum_{j^{'}}e^{u_{ij^{'}}}} \\\\\n\\text{h}^{'}_i&=\\sum_ja_{ij}\\text v_j\n\\end{aligned}Multi-head attention\n\\text{MHA}_i(\\text h_1,\\dots,\\text h_n)=\\sum_{m=1}^M W_m^O \\text h_{im}^{'}Feed-forward sublayer\n\\begin{aligned}\n\\text{FF}(\\hat{\\text{h}}_i)&=W^{\\text{ff},1} \\cdot \\text{Relu}(W^{\\text{ff},0}\\hat{\\text{h}}_i+b^{\\text{ff},0})+b^{\\text{ff},1} \\\\\n\\end{aligned}Batch normalization\n\\text{BN}(\\text h_i)=w^{\\text{bn}} \\odot \\overline {\\text{BN}}(\\text h_i)+b^{\\text{bn}}Decoder\n ç”±ä¸¤å±‚æ³¨æ„åŠ›å±‚æ„æˆï¼Œä¸€å±‚å¤šå¤´æ³¨æ„åŠ›å±‚ï¼Œä¸€å±‚å•å¤´æ³¨æ„åŠ›ï¼Œè¿™é‡Œçš„æ³¨æ„åŠ›å±‚æ²¡æœ‰é‡‡ç”¨æ®‹å·®è¿æ¥ã€æ‰¹å½’ä¸€åŒ–ã€å…¨è¿æ¥å±‚æ“ä½œï¼Œè€Œæ˜¯ç›´æ¥å¾—åˆ°ç›¸å…³æ€§åˆ†æ•°ã€‚\nï¼š åœ¨  æ—¶åˆ»çš„è¾“å…¥æ¥è‡ª  å’Œ  ä¹‹å‰å…¶æœ¬èº«çš„è¾“å‡ºï¼š\n\n{\\text{h}}^{(N)}_{(c)}=\n\\begin{cases}\n[ \\bar {\\text{h}}^{(N)},\\text{h}^{(N)}_{\\pi_{t-1}},\\text{h}^{(N)}_{\\pi_{t-1}}], & t>1\\\\\n[\\bar {\\text{h}}^{(N)},\\text{v}^\\text 1,\\text{v}^\\text f], & t=1\n\\end{cases}å…¶ä¸­  å’Œ  æ˜¯ç»´åº¦ä¸º  çš„å­¦ä¹ åˆ°çš„å‚æ•°ã€‚\nå°†  å’Œ  è®¡ç®—ï¼š\n\n\\begin{aligned}\n\\text q_{(c)} &= W^Q\\text h_{(c)},\\text k_i=W^K \\text h_i,\\text v_i=W^V \\text h_i \\\\\nu_{(c)j}&=\n\\begin{cases}\n\\frac{\\text q_{(c)}^T\\text k_j}{\\sqrt d_k} & \\text{if}\\ j \\not = \\pi_{t^{'}}, \\forall t^{'}","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®ºæ–‡","ML4CO","äººå·¥æ™ºèƒ½"]},{"title":"Crash Course Computer Science","url":"/2022/10/23/Crash%20Course%20Computer%20Science/","content":"4. äºŒè¿›åˆ¶ä½ï¼Œbitï¼Œå³ä¸ºäºŒè¿›åˆ¶çš„ä¸€ä½ï¼Œ ä½å‚¨å­˜çš„ä¿¡æ¯å¤§å°ä¸º ã€‚å­—èŠ‚ï¼Œbyteâ€‹ï¼Œ å­—èŠ‚ä¸º  ä½ã€‚\nIEEE 754 æ ‡å‡†ï¼Œç”¨æ¥å­˜å‚¨æµ®ç‚¹æ•°ã€‚å¦‚  å†™æˆ ï¼Œ ä¸ºæœ‰æ•ˆä½æ•°ï¼Œ ä¸ºæŒ‡æ•°ã€‚å¯¹äº  ä½æµ®ç‚¹æ•°ï¼ˆfloat å‹æµ®ç‚¹æ•°ï¼‰ï¼Œ ä½è¡¨ç¤ºæ­£è´Ÿï¼Œ ä½å­˜å‚¨æŒ‡æ•°ï¼Œ ä½å­˜å‚¨æœ‰æ•ˆä½æ•°ã€‚\n5. ç®—æœ¯é€»è¾‘å•å…ƒç®—æœ¯é€»è¾‘å•å…ƒï¼ˆALUï¼‰ï¼Œå«æœ‰ç®—æœ¯å•å…ƒå’Œé€»è¾‘å•å…ƒã€‚\nç®—æ³•å•å…ƒï¼šä¸¤ä¸ªåŠåŠ å™¨ï¼ˆå¯ä»¥è¾“å…¥ä¸¤ä¸ª ï¼‰ç»„æˆå…¨åŠ å™¨ï¼ˆå¯ä»¥è¾“å…¥ä¸‰ä¸ª ï¼Œä¸¤ä¸ªæ•°å­—ç›¸åŠ ä»¥åŠè¿›ä½æƒ…å†µï¼‰ï¼Œ ä¸ªå…¨åŠ å™¨å¯åˆ¶ä½œ  ä½åŠ æ³•å™¨ã€‚å½“  ä½åŠ æ³•å™¨ä¸­æœ€åä¸€ä¸ªå…¨åŠ å™¨äº§ç”Ÿè¿›ä½æ—¶ï¼Œå°±æ˜¯å‘ç”Ÿæº¢å‡ºï¼ˆoverflowï¼‰äº†ã€‚ç°ä»£è®¡ç®—æœºä½¿ç”¨è¶…å‰è¿›ä½åŠ æ³•å™¨ã€‚\n6. å¯„å­˜å™¨ &amp; å†…å­˜éšæœºå­˜å–å­˜å‚¨å™¨ï¼ˆRAMï¼‰ï¼ŒæŒä¹…å­˜å‚¨ã€‚\n AND-OR é”å­˜å™¨ï¼ˆå­˜å‚¨ä¸€ä½ä¿¡æ¯ï¼‰ï¼Œå…«ä¸ªç»„æˆä¸€ä¸ª  ä½å¯„å­˜å™¨ã€‚ç”¨çŸ©é˜µæ¥å®ç°æ›´é«˜ä½çš„å¯„å­˜å™¨ï¼Œæœ‰åˆ—åœ°å€å’Œè¡Œåœ°å€ã€‚å¤šè·¯å¤ç”¨å™¨ç”¨æ¥æ‰¾åˆ°å¯¹åº”çš„åœ°å€ï¼ˆå¯»å€ï¼‰ã€‚\nSRAMï¼ˆé™æ€éšæœºå­˜å–å­˜å‚¨å™¨ï¼‰ã€‚\nå¯„å­˜å™¨ï¼šå¾ˆå°çš„ä¸€å—å†…å­˜ï¼Œèƒ½å­˜ä¸€ä¸ªå€¼ã€‚\nRAMï¼šä¸€å¤§å—å†…å­˜ï¼Œèƒ½åœ¨ä¸åŒåœ°å€å­˜å¤§é‡æ•°å­—ã€‚\n7. ä¸­å¤®å¤„ç†å™¨(CPU)CPU è´Ÿè´£æ‰§è¡Œç¨‹åºï¼Œç¨‹åºç”±æŒ‡ä»¤ç»„æˆã€‚æ•°å­¦æŒ‡ä»¤ï¼šCPU ç”¨ ALU è¿›è¡Œæ•°å­¦è¿ç®—ã€‚å†…å­˜æŒ‡ä»¤ï¼šCPU å’Œå†…å­˜é€šä¿¡ï¼Œè¿›è¡Œè¯»å€¼æˆ–å†™å€¼ã€‚\nå¯„å­˜å™¨ç”¨æ¥ä¸´æ—¶å­˜æ•°æ®å’Œæ“ä½œæ•°æ®ã€‚\nCPU çŠ¶æ€ï¼šå–æŒ‡ä»¤ï¼Œè§£ç ï¼Œæ‰§è¡Œã€‚\n9. é«˜çº§CPUè®¾è®¡ç»™ CPU åŠ ä¸€ç‚¹ RAMï¼Œå«ç¼“å­˜ï¼ˆcacheï¼‰ã€‚\nç¼“å­˜å‘½ä¸­ï¼ˆcache hitï¼‰ï¼šæƒ³è¦çš„æ•°æ®å·²ç»åœ¨ç¼“å­˜ã€‚\nç¼“å­˜æœªå‘½ä¸­ï¼ˆcache missï¼‰ï¼šæƒ³è¦çš„æ•°æ®ä¸åœ¨ç¼“å­˜ã€‚\nè„ä½ï¼ˆdirty bitï¼‰ï¼šåŒæ­¥ä¸€èˆ¬å‘ç”Ÿåœ¨å½“ç¼“å­˜æ»¡äº†è€Œ CPU åˆè¦ç¼“å­˜æ—¶ã€‚åœ¨æ¸…ç†ç¼“å­˜è…¾å‡ºç©ºé—´ä¹‹å‰ï¼Œä¼šå…ˆæ£€æŸ¥â€è„ä½â€œï¼Œå¦‚æœæ˜¯â€è„â€œçš„ï¼Œåœ¨åŠ è½½æ–°å†…å®¹ä¹‹å‰ï¼Œä¼šæŠŠæ•°æ®å†™å› RAMã€‚\nè„ä½çš„æ„ä¹‰ï¼šä¿®æ”¹æ•°æ®æ—¶ï¼Œä¸ºæé«˜é€Ÿåº¦ï¼Œä¼šç›´æ¥åœ¨ç¼“å­˜ä¿®æ”¹ï¼Œè€Œ RAM æœªä¿®æ”¹ã€‚\næŒ‡ä»¤æµæ°´çº¿ï¼šå¹¶è¡Œå¤„ç†ï¼Œä½†è¦å…ˆå¼„æ¸…æ•°æ®ä¾èµ–æ€§ï¼Œå¿…è¦æ—¶åœæ­¢æµæ°´çº¿ã€‚é«˜ç«¯ CPU ä¼šåŠ¨æ€æ’åºæœ‰ä¾èµ–å…³ç³»çš„æŒ‡ä»¤ï¼Œæœ€å°åŒ–æµæ°´çº¿çš„åœå·¥æ—¶é—´ï¼Œè¿™å«åšâ€ä¹±åºæ‰§è¡Œâ€œã€‚æ¡ä»¶è·³è½¬ä¼šäº§ç”Ÿâ€å²”è·¯å£â€œï¼Œé«˜ç«¯ CPU ä¼šçŒœé‚£æ¡è·¯å¯èƒ½æ€§å¤§ä¸€äº›ï¼Œç„¶åæå‰æŠŠæŒ‡ä»¤æ”¾è¿›æµæ°´çº¿ï¼Œè¿™å«åšâ€æ¨æµ‹æ‰§è¡Œâ€œã€‚\nå¤šæ ¸å¤„ç†å™¨ï¼šåŒæ—¶è¿è¡Œå¤šä¸ªæŒ‡ä»¤æµã€‚\n11. ç¼–ç¨‹è¯­è¨€å‘å±•å²äºŒè¿›åˆ¶æ˜¯å¤„ç†å™¨çš„â€œæ¯è¯­â€ï¼Œè¿™å«â€œæœºå™¨è¯­è¨€â€æˆ–â€œæœºå™¨ç â€ã€‚\n æ±‡ç¼–å™¨è¯»å–ç”¨â€œæ±‡ç¼–è¯­è¨€â€å†™çš„ç¨‹åºï¼Œç„¶åè½¬æˆâ€œæœºå™¨ç â€ã€‚ \né«˜çº§ç¼–ç¨‹è¯­è¨€ï¼šç¨‹åºå‘˜åªéœ€åˆ›å»ºä»£è¡¨å†…å­˜åœ°å€çš„æŠ½è±¡ï¼Œå«â€œå˜é‡â€ã€‚   \n16. è½¯ä»¶å·¥ç¨‹æŠŠå‡½æ•°æ‰“åŒ…æˆå±‚çº§ï¼ŒæŠŠç›¸å…³ä»£ç éƒ½æ”¾åœ¨ä¸€èµ·ï¼Œæ‰“åŒ…æˆå¯¹è±¡ï¼ˆobjectsï¼‰ã€‚æŠŠå‡½æ•°æ‰“åŒ…æˆå¯¹è±¡çš„æ€æƒ³å«â€œé¢å‘å¯¹è±¡ç¼–ç¨‹â€ã€‚\nç¨‹åºç¼–ç¨‹æ¥å£ï¼Œç®€ç§° APIï¼Œå¸®åŠ©ä¸åŒç¨‹åºå‘˜åˆä½œã€‚API æ§åˆ¶å“ªäº›å‡½æ•°å’Œæ•°æ®è®©å¤–éƒ¨è®¿é—®ï¼Œå“ªäº›ä»…ä¾›å†…éƒ¨ï¼ˆè®¾å®š public æˆ– privateï¼‰ã€‚\né›†æˆå¼€å‘ç¯å¢ƒï¼Œç®€ç§° IDEã€‚\næºä»£ç ç®¡ç†ï¼Œä¹Ÿå«â€œç‰ˆæœ¬æ§åˆ¶â€ï¼Œæ¯”å¦‚ GITï¼ŒSVNã€‚\næµ‹è¯•å¯ä»¥ç»Ÿç§°â€œè´¨é‡ä¿è¯æµ‹è¯•â€ï¼Œæ£€æŸ¥ QAã€‚\n17. é›†æˆç”µè·¯&amp;æ‘©å°”å®šå¾‹é›†æˆç”µè·¯ï¼ˆICï¼‰ï¼Œå°è£…ä¸€å®šæ•°é‡çš„å¸¸ç”¨ç”µå­å…ƒä»¶ï¼ŒæŠŠåˆ†ç«‹å…ƒä»¶å°è£…æˆä¸€ä¸ªç‹¬ç«‹å•å…ƒã€‚\nå°åˆ·ç”µè·¯æ¿ï¼Œç®€ç§° PCBã€‚\nå…‰åˆ»ï¼Œç”¨å…‰æŠŠå¤æ‚å›¾æ¡ˆå°åˆ°ææ–™ä¸Šï¼Œæ¯”å¦‚åŠå¯¼ä½“ã€‚\n18. æ“ä½œç³»ç»Ÿæ“ä½œç³»ç»Ÿï¼Œç®€ç§° OSï¼Œå……å½“è½¯ä»¶å’Œç¡¬ä»¶ä¹‹é—´çš„åª’ä»‹ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œæ“ä½œç³»ç»Ÿæä¾› API æ¥æŠ½è±¡ç¡¬ä»¶ï¼Œå«â€œè®¾å¤‡é©±åŠ¨ç¨‹åºâ€ã€‚\nè™šæ‹Ÿå†…å­˜ï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨å¤„ç†è™šæ‹Ÿå†…å­˜å’Œç‰©ç†å†…å­˜ä¹‹é—´çš„æ˜ å°„ï¼ˆç‰©ç†å†…å­˜åœ°å€ä¸è¿ç»­ï¼Œä½†è™šæ‹Ÿå†…å­˜åœ°å€è¿ç»­ï¼‰ã€‚ è¿™ç§æœºåˆ¶ä½¿ç¨‹åºçš„å†…å­˜å¤§å°å¯ä»¥çµæ´»å¢å‡ï¼Œå«â€œåŠ¨æ€å†…å­˜åˆ†é…â€ã€‚å¯¹ç¨‹åºæ¥è¯´ï¼Œå†…å­˜çœ‹èµ·æ¥æ˜¯è¿ç»­çš„ã€‚è¿™ä¸ºæ“ä½œç³»ç»ŸåŒæ—¶è¿è¡Œå¤šä¸ªç¨‹åºæä¾›äº†æå¤§çš„çµæ´»æ€§ã€‚\nç»™ç¨‹åºåˆ†é…ä¸“ç”¨çš„å†…å­˜èŒƒå›´çš„å¦ä¸€ä¸ªå¥½å¤„ï¼šç¨‹åºå‡ºé”™åï¼Œåªèƒ½æ£ä¹±è‡ªå·±çš„å†…å­˜ï¼Œä¸ä¼šå½±å“åˆ°å…¶å®ƒç¨‹åºï¼Œè¿™å«â€œå†…å­˜ä¿æŠ¤â€ã€‚\nåˆ†æ—¶æ“ä½œç³»ç»Ÿï¼Œæ¯ä¸ªç”¨æˆ·åªèƒ½ç”¨ä¸€å°éƒ¨åˆ†å¤„ç†å™¨ï¼Œå†…å­˜ç­‰ã€‚\n19. å†…å­˜&amp;å‚¨å­˜ä»‹è´¨å­˜å‚¨å™¨ï¼Œå¦‚ç¡¬ç›˜ï¼Œå…·æœ‰éæ˜“å¤±æ€§ã€‚\n20. æ–‡ä»¶ç³»ç»Ÿæ•°æ®çš„æ•°æ®ï¼Œå«â€œå…ƒæ•°æ®â€ï¼ˆmeta dataï¼‰ï¼Œæä¾›ä¿¡æ¯æ¥æ­£ç¡®è¯»å–æ•°æ®ï¼Œå­˜åœ¨æ–‡ä»¶å¼€å¤´ï¼Œåœ¨å®é™…æ•°æ®å‰é¢ï¼Œå› æ­¤ä¹Ÿå«æ–‡ä»¶å¤´ï¼ˆHeaderï¼‰ã€‚\næ–‡ä»¶ç³»ç»Ÿç§»åŠ¨æ–‡ä»¶æ—¶ï¼Œä¸ç”¨ç§»åŠ¨ä»»ä½•æ•°æ®å—ï¼Œåªéœ€æ”¹ä¸¤ä¸ªç›®å½•æ–‡ä»¶ï¼Œä¸€ä¸ªæ–‡ä»¶é‡Œåˆ ä¸€æ¡è®°å½•ï¼Œå¦ä¸€ä¸ªæ–‡ä»¶é‡ŒåŠ ä¸€æ¡è®°å½•ã€‚\n21. å‹ç¼©æ¸¸ç¨‹ç¼–ç ï¼ˆRun-Length Encodingï¼‰ï¼Œé€‚åˆç»å¸¸å‡ºç°ç›¸åŒå€¼çš„æ–‡ä»¶ï¼Œå‹ç¼©è¿ç»­ç›¸åŒå€¼ã€‚\nDFTBAï¼Œå­—å…¸ç¼–ç ï¼Œç´§å‡‘ä»£ç ï¼Œç”¨éœå¤«æ›¼æ ‘ä¸ºå‡ºç°é¢‘ç‡é«˜çš„æ•°æ®åˆ†é…é•¿åº¦çŸ­çš„ä»£ç ï¼ˆç¼–å·ï¼‰ã€‚\næ¸¸ç¨‹ç¼–ç å’Œå­—å…¸ç¼–ç å®ç°äº†â€œæ— æŸå‹ç¼©â€ï¼Œæ²¡æœ‰ä¸¢å¤±ä»»ä½•æ•°æ®ã€‚\nå¦‚æœå½•éŸ³ä¹ï¼Œè¶…å£°æ³¢æ•°æ®éƒ½å¯ä»¥æ‰”æ‰ã€‚äººå¯¹äººå£°æ•æ„Ÿï¼Œå¯¹ä½éŸ³ä¸æ•æ„Ÿï¼Œæ‰€ä»¥æœ‰æŸéŸ³é¢‘å‹ç¼©åˆ©ç”¨è¿™ä¸€ç‚¹ï¼Œç”¨ä¸åŒç²¾åº¦ç¼–ç ä¸åŒé¢‘æ®µã€‚è¿™ç§åˆ æ‰äººç±»æ— æ³•æ„ŸçŸ¥çš„æ•°æ®çš„æ–¹æ³•ï¼Œå«â€œæ„ŸçŸ¥ç¼–ç â€ï¼ˆperceptual codingï¼‰ã€‚\n27. 3D å›¾å½¢3D æŠ•å½±ï¼ŒæŠŠ 3D åæ ‡â€œæ‹å¹³â€æ˜¾ç¤ºåˆ° 2D å±å¹•ä¸Šã€‚3D è½¬ 2D åç”¨ç”» 2D çº¿æ®µçš„å‡½æ•°æ¥è¿æ¥ç‚¹ï¼Œè¿™å«â€œçº¿æ¡†æ¸²æŸ“â€ã€‚\nå¡«å……å›¾å½¢çš„ç»å…¸ç®—æ³•å«æ‰«æçº¿æ¸²æŸ“ã€‚\næŠ—é”¯é½¿ï¼Œå¦‚æœåƒç´ åœ¨å¤šè¾¹å½¢å†…éƒ¨ï¼Œå°±ç›´æ¥æ¶‚é¢œè‰²ï¼Œå¦‚æœå¤šè¾¹å½¢åˆ’è¿‡åƒç´ ï¼Œé¢œè‰²å°±æµ…ä¸€äº›ã€‚\nå®ç°é®æŒ¡ï¼Œæ’åºåä»è¿œåˆ°è¿‘æ¸²æŸ“ï¼Œè¿™å«ç”»å®¶ç®—æ³•ã€‚è¿˜æœ‰ä¸€ç§æ–¹æ³•å«æ·±åº¦ç¼“å†²ï¼Œä¸ç”¨æ’åºï¼Œå¯¹æ¯ä¸ªåƒç´ å–è·ç¦»çš„æœ€å°å€¼ï¼Œä»è€Œå¾—åˆ°æœ€å‰é¢çš„å¤šè¾¹å½¢ã€‚ä½†è·ç¦»ç›¸åŒæ—¶æ— æ³•å¤„ç†ï¼Œä¸å¯é¢„æµ‹å“ªä¸ªç”»åœ¨ä¸Šé¢ï¼Œå¯¼è‡´å‡ºç° Z-fighting æ•ˆæœã€‚\nèƒŒé¢å‰”é™¤ï¼Œå¿½ç•¥å¤šè¾¹å½¢èƒŒé¢ã€‚\næ˜æš—å¤„ç†ï¼Œå¤šè¾¹å½¢é¢å¯¹çš„æ–¹å‘å«â€œè¡¨é¢æ³•çº¿â€ï¼Œæ ¹æ®æ–¹å‘æ¥è¿›è¡Œå¹³é¢ç€è‰²ã€‚è¿˜æœ‰æ›´å¤šç®—æ³•ï¼Œå¦‚é«˜è½å¾·ç€è‰²å’Œå†¯æ°ç€è‰²ã€‚\nçº¹ç†æ˜ å°„ï¼ŒæŸ¥è¯¢çº¹ç†ï¼Œä»ç›¸åº”åŒºåŸŸå–å¹³å‡é¢œè‰²ï¼Œå¹¶å¡«å……å¤šè¾¹å½¢ã€‚\nGPUï¼Œå›¾å½¢å¤„ç†å•å…ƒï¼Œåœ¨æ˜¾å¡ä¸Šï¼Œå‘¨å›´æœ‰ä¸“ç”¨çš„ RAMã€‚\n28. è®¡ç®—æœºç½‘ç»œè®¡ç®—æœºè¿‘è·ç¦»æ„æˆçš„å°å‹ç½‘ç»œï¼Œå«å±€åŸŸç½‘ï¼Œç®€ç§° LANã€‚\nä¸ºäº†çŸ¥é“æ•°æ®ä¼ é€’æ–¹å‘ï¼Œä»¥å¤ªç½‘éœ€è¦æ¯å°è®¡ç®—æœºæœ‰å”¯ä¸€çš„åª’ä½“è®¿é—®æ§åˆ¶åœ°å€ï¼Œç®€ç§° MAC åœ°å€ã€‚\nå¤šå°ç”µè„‘å…±äº«ä¸€ä¸ªä¼ è¾“åª’ä»‹ï¼Œè¿™ç§æ–¹æ³•å«â€œè½½æ³¢ä¾¦å¬å¤šè·¯è®¿é—®â€ï¼Œç®€ç§°â€œCSMAâ€ã€‚å¾ˆå¤šè®¡ç®—æœºåŒæ—¶ä¾¦å¬è½½ä½“ï¼Œæ‰€ä»¥å«â€œä¾¦å¬â€å’Œâ€œå¤šè·¯è®¿é—®â€ã€‚è½½ä½“ä¼ è¾“æ•°æ®çš„é€Ÿåº¦å«â€œå¸¦å®½â€ã€‚\næŒ‡æ•°é€€é¿ï¼Œå‘ç”Ÿå†²çªåç­‰ 1 ç§’ã€‚è‹¥ä»å†²çªï¼Œç­‰ 2 ç§’ã€‚è‹¥ä»å†²çªï¼Œç­‰ 4 ç§’â€¦â€¦\næˆ‘ä»¬éœ€è¦å‡å°‘åŒä¸€è½½ä½“ä¸­è®¾å¤‡çš„æ•°é‡ï¼Œè½½ä½“å’Œå…¶ä¸­çš„è®¾å¤‡æ€»ç§°â€œå†²çªåŸŸâ€ã€‚ä¸ºäº†å‡å°‘å†²çªï¼Œå¯ä»¥ç”¨äº¤æ¢æœºå°†ä¸€ä¸ªå†²çªåŸŸæ‹†æˆä¸¤ä¸ªå†²çªåŸŸã€‚\nå¤§å‹ç½‘ç»œä¸­ï¼Œä»ä¸€ä¸ªåœ°ç‚¹åˆ°å¦ä¸€ä¸ªåœ°ç‚¹é€šå¸¸æœ‰å¤šæ¡è·¯çº¿ã€‚æ¶ˆæ¯æ²¿ç€è·¯ç”±è·³è½¬çš„æ¬¡æ•°ï¼Œå«â€œè·³æ•°â€ï¼ˆhop countï¼‰ã€‚\n29. äº’è”ç½‘WIFI è·¯ç”±å™¨è¿ç€çš„æ‰€æœ‰è®¾å¤‡ï¼Œç»„æˆäº†å±€åŸŸç½‘ï¼Œå±€åŸŸç½‘å†è¿åˆ°å¹¿åŸŸç½‘ï¼ˆWANï¼‰ï¼ŒWAN çš„è·¯ç”±å™¨ä¸€èˆ¬å±äºâ€œäº’è”ç½‘æœåŠ¡æä¾›å•†â€ï¼Œç®€ç§° ISPã€‚\nä¼ è¾“çš„æ•°æ®ä¼šè¢«æ‹†æˆå¤šä¸ªå°æ•°æ®åŒ…ï¼ˆpacketï¼‰ã€‚æ•°æ®åŒ…æƒ³åœ¨äº’è”ç½‘ä¸Šä¼ è¾“ï¼Œè¦ç¬¦åˆâ€œäº’è”ç½‘åè®®â€çš„æ ‡å‡†ï¼Œç®€ç§° IPã€‚ä¸ºè§£å†³æ•°æ®åŒ…ä¼ ç»™å“ªä¸ªç¨‹åºï¼Œè¿˜éœ€æ›´å¤šåè®®ï¼Œå…¶ä¸­æœ€ç®€å•æœ€å¸¸è§çš„å«â€œç”¨æˆ·æ•°æ®æŠ¥åè®®â€ï¼Œç®€ç§° UDPã€‚IP è´Ÿè´£æŠŠæ•°æ®åŒ…é€åˆ°æ­£ç¡®çš„è®¡ç®—æœºï¼ŒUDP è´Ÿè´£æŠŠæ•°æ®åŒ…é€åˆ°æ­£ç¡®çš„ç¨‹åºã€‚\nå¦‚æœâ€œæ‰€æœ‰æ•°æ®å¿…é¡»åˆ°è¾¾â€ï¼Œå°±ç”¨â€œä¼ è¾“æ§åˆ¶åè®®â€ï¼Œç®€ç§° TCPã€‚1. TCP æ•°æ®åŒ…æœ‰åºå·ã€‚2. TCP è¦æ±‚æ¥æ”¶æ–¹çš„ç”µè„‘æ”¶åˆ°æ•°æ®åŒ…å¹¶ä¸”â€œæ ¡éªŒå’Œâ€æ£€æŸ¥æ— è¯¯åï¼ˆæ•°æ®æ²¡æœ‰æŸåï¼‰ï¼Œç»™å‘é€æ–¹å‘ä¸€ä¸ªç¡®è®¤ç ï¼ˆACKï¼‰ï¼Œä»£è¡¨æ”¶åˆ°äº†ã€‚\nå½“è®¡ç®—æœºè®¿é—®ä¸€ä¸ªç½‘ç«™æ—¶ï¼Œéœ€è¦ IP åœ°å€å’Œç«¯å£å·ã€‚åŸŸåç³»ç»Ÿï¼ˆDNSï¼‰è´Ÿè´£æŠŠåŸŸåå’Œ IP åœ°å€ä¸€ä¸€å¯¹åº”ã€‚\n30. ä¸‡ç»´ç½‘ä¸ºäº†ä½¿ç½‘é¡µèƒ½ç›¸äº’è¿æ¥ï¼Œæ¯ä¸ªç½‘é¡µéœ€è¦ä¸€ä¸ªå”¯ä¸€çš„åœ°å€ï¼Œè¿™ä¸ªåœ°å€å«â€œç»Ÿä¸€èµ„æºå®šä½å™¨â€ï¼Œç®€ç§° URLã€‚\nè¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼ˆHTTPï¼‰ã€‚\nè¶…æ–‡æœ¬æ ‡è®°è¯­è¨€ï¼ˆHTMLï¼‰ã€‚\nç½‘ç»œä¸­ç«‹æ€§ï¼Œåº”è¯¥å¹³ç­‰å¯¹å¾…æ‰€æœ‰æ•°æ®åŒ…ã€‚\n31. è®¡ç®—æœºå®‰å…¨è®¡ç®—æœºå®‰å…¨æ˜¯ä¿æŠ¤ç³»ç»Ÿå’Œæ•°æ®çš„ä¿å¯†æ€§ï¼Œå®Œæ•´æ€§å’Œå¯ç”¨æ€§ã€‚\nâ€œä¿å¯†æ€§â€æ˜¯åªæœ‰æœ‰æƒé™çš„äººæ‰èƒ½è¯»å–è®¡ç®—æœºç³»ç»Ÿå’Œæ•°æ®ã€‚â€œå®Œæ•´æ€§â€æ˜¯åªæœ‰æœ‰æƒé™çš„äººæ‰èƒ½ä½¿ç”¨å’Œä¿®æ”¹ç³»ç»Ÿå’Œæ•°æ®ã€‚â€œå¯ç”¨æ€§â€æ˜¯æœ‰æƒé™çš„äººåº”è¯¥éšæ—¶å¯ä»¥è®¿é—®ç³»ç»Ÿå’Œæ•°æ®ã€‚\næ‹’ç»æœåŠ¡æ”»å‡»ï¼ˆDDOSï¼‰å°±æ˜¯é»‘å®¢å‘å¤§é‡çš„å‡è¯·æ±‚åˆ°æœåŠ¡å™¨ï¼Œè®©ç½‘ç«™å¾ˆæ…¢æˆ–è€…æŒ‚æ‰ã€‚è¿™å°±æ˜¯æ”»å‡»â€œå¯ç”¨æ€§â€ã€‚\nä¸ºäº†ä¿æŠ¤è¿™ä¸‰æ–¹é¢ï¼Œå®‰å…¨ä¸“å®¶ä¼šä»æŠ½è±¡å±‚é¢æƒ³è±¡â€œæ•Œäººâ€å¯èƒ½æ˜¯è°ï¼Œè¿™å«â€œå¨èƒæ¨¡å‹åˆ†æâ€ã€‚\néš”ç¦»ï¼Œè®¡åˆ’å½“ç¨‹åºè¢«æ”»ç ´åï¼Œå¦‚ä½•é™åˆ¶æŸå®³ï¼Œæ§åˆ¶æŸå®³çš„æœ€å¤§ç¨‹åº¦ï¼Œå¹¶ä¸”ä¸è®©å®ƒå±å®³åˆ°è®¡ç®—æœºä¸Šå…¶ä»–ä¸œè¥¿ã€‚å¯ä»¥ç”¨â€œæ²™ç›’â€ç¨‹åºå®ç°éš”ç¦»ï¼Œç»™æ¯ä¸ªç¨‹åºç‹¬æœ‰çš„å†…å­˜å—ï¼Œå…¶ä»–ç¨‹åºä¸èƒ½åŠ¨ã€‚\n32. é»‘å®¢&amp;æ”»å‡»â€œç¤¾ä¼šå·¥ç¨‹å­¦â€ï¼Œæ¬ºéª—åˆ«äººè®©äººæ³„å¯†ä¿¡æ¯ã€‚æœ€å¸¸è§çš„æ”»å‡»æ˜¯ç½‘ç»œé’“é±¼ã€‚\nè¿œç¨‹æ”»å‡»ä¸€èˆ¬éœ€è¦æ”»å‡»è€…åˆ©ç”¨ç³»ç»Ÿæ¼æ´æ¥è·å¾—æŸäº›èƒ½åŠ›æˆ–è®¿é—®æƒé™ï¼Œè¿™å«â€œæ¼æ´åˆ©ç”¨â€ã€‚ä¸€ç§å¸¸è§çš„æ¼æ´åˆ©ç”¨å«â€œç¼“å†²åŒºæº¢å‡ºâ€ã€‚â€œç¼“å†²åŒºâ€æ˜¯ä¸€ç§æ¦‚ç§°ï¼ŒæŒ‡é¢„ç•™çš„ä¸€å—å†…å­˜ç©ºé—´ã€‚å¯ä»¥åˆ©ç”¨ç¼“å†²åŒºæº¢å‡ºæ¥ä¿®æ”¹å†…å­˜ã€‚\nä¸ºäº†é˜²æ­¢ç¼“å†²åŒºæº¢å‡ºè¢«åˆ©ç”¨ï¼Œæœ€ç®€å•çš„æ–¹æ³•æ˜¯å¤åˆ¶ä¹‹å‰å…ˆæ£€æŸ¥é•¿åº¦ï¼Œé˜²æ­¢å†…å­˜è¢«ä¿®æ”¹ï¼Œè¿™å«â€œè¾¹ç•Œæ£€æŸ¥â€ã€‚ç¨‹åºä¹Ÿä¼šéšæœºå­˜æ”¾å˜é‡åœ¨å†…å­˜ä¸­çš„ä½ç½®ï¼Œå¯¼è‡´é»‘å®¢æ›´å®¹æ˜“è®©ç¨‹åºå´©æºƒï¼Œè€Œä¸æ˜¯è·å¾—è®¿é—®æƒé™ã€‚\nç¨‹åºä¹Ÿå¯ä»¥åœ¨ç¼“å†²åŒºåï¼Œç•™ä¸€äº›ä¸ç”¨çš„ç©ºé—´ï¼Œç„¶åè·Ÿè¸ªé‡Œé¢çš„å€¼ï¼Œçœ‹æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚å¦‚æœå‘ç”Ÿäº†å˜åŒ–ï¼Œè¯´æ˜æœ‰æ”»å‡»è€…åœ¨ä¹±æ¥ï¼Œè¿™äº›ä¸ç”¨çš„å†…å­˜ç©ºé—´å«â€œé‡‘ä¸é›€â€ã€‚\nä»£ç æ³¨å…¥ï¼Œæœ€å¸¸ç”¨äºæ”»å‡»ç”¨æ•°æ®åº“çš„ç½‘ç«™ã€‚ç”¨â€œç»“æ„åŒ–æŸ¥è¯¢è¯­è¨€â€ï¼ˆSQLï¼‰ï¼Œä¸€ç§æµè¡Œçš„æ•°æ®åº“ APIã€‚\n33. åŠ å¯†æŠŠæ˜æ–‡è½¬æˆå¯†æ–‡å«â€œåŠ å¯†â€ï¼ŒæŠŠå¯†æ–‡æ¢å¤å›æ˜æ–‡å«â€œè§£å¯†â€ã€‚\nå¯†é’¥äº¤æ¢ï¼Œæ˜¯ä¸€ç§ä¸å‘é€å¯†é’¥ï¼Œä½†ä¾ç„¶è®©ä¸¤å°è®¡ç®—æœºåœ¨å¯†é’¥ä¸Šè¾¾æˆå…±è¯†çš„ç®—æ³•ã€‚â€œè¿ªè²-èµ«å°”æ›¼å¯†é’¥äº¤æ¢â€ï¼ˆDiffie-Hellmanï¼‰ï¼Œæœ‰å…¬å¼€çš„åŸºæ•°å’Œæ¨¡æ•°ï¼ŒåŒæ–¹åˆ†åˆ«é€‰ä¸€ä¸ªæŒ‡æ•° ï¼Œåˆ†åˆ«å°†  å’Œ  å‘ç»™å¯¹æ–¹ï¼Œå…±äº«å¯†é’¥ä¸º ã€‚åŒæ–¹ç”¨ä¸€æ ·çš„å¯†é’¥åŠ å¯†å’Œè§£å¯†æ¶ˆæ¯ï¼Œè¿™å«â€œå¯¹ç§°åŠ å¯†â€œã€‚\néå¯¹ç§°åŠ å¯†ï¼Œæœ‰ä¸¤ä¸ªä¸åŒçš„å¯†é’¥ï¼Œäººä»¬ç”¨å…¬é’¥åŠ å¯†æ¶ˆæ¯ï¼Œåªæœ‰æœ‰ç§é’¥çš„äººèƒ½è§£å¯†ã€‚çŸ¥é“å…¬é’¥åªèƒ½åŠ å¯†ï¼Œä½†ä¸èƒ½è§£å¯†ï¼Œè¿™æ˜¯â€ä¸å¯¹ç§°â€œçš„ã€‚ç›®å‰æœ€æµè¡Œçš„â€éå¯¹ç§°åŠ å¯†â€œæŠ€æœ¯æ˜¯ RSAã€‚\n34. æœºå™¨å­¦ä¹ &amp;äººå·¥æ™ºèƒ½æœºå™¨å­¦ä¹ ç®—æ³•è®©è®¡ç®—æœºå¯ä»¥ä»æ•°æ®ä¸­å­¦ä¹ ï¼Œç„¶åè‡ªè¡Œåšå‡ºé¢„æµ‹å’Œå†³å®šã€‚\nåˆ†ç±»ï¼ŒåŒºåˆ†ä¸¤ä¸ªäº‹ç‰©ï¼Œåšåˆ†ç±»çš„ç®—æ³•å«â€œåˆ†ç±»å™¨â€ã€‚å¾ˆå¤šç®—æ³•ä¼šå‡å°‘å¤æ‚æ€§ï¼ŒæŠŠæ•°æ®ç®€åŒ–æˆâ€œç‰¹å¾â€ï¼Œâ€œç‰¹å¾â€æ˜¯ç”¨æ¥å¸®åŠ©â€œåˆ†ç±»â€çš„å€¼ã€‚ä¸ºäº†è®­ç»ƒâ€œåˆ†ç±»å™¨â€åšå‡ºå¥½çš„é¢„æµ‹ï¼Œæˆ‘ä»¬éœ€è¦â€œè®­ç»ƒæ•°æ®â€ã€‚\næŠŠå†³ç­–ç©ºé—´åˆ‡æˆå‡ ä¸ªç›’å­çš„ç®€å•æ–¹æ³•ï¼Œå¯ä»¥ç”¨â€œå†³ç­–æ ‘â€æ¥è¡¨ç¤ºã€‚\näººå·¥ç¥ç»ç½‘ç»œï¼Œäººé€ ç¥ç»å…ƒå¯ä»¥æ¥å—å¤šä¸ªè¾“å…¥ï¼Œç„¶åæ•´åˆå¹¶å‘å‡ºä¸€ä¸ªä¿¡å·ï¼Œè¢«æ”¾æˆä¸€å±‚å±‚ï¼Œå½¢æˆç¥ç»å…ƒç½‘ç»œï¼Œå› æ­¤å¾—åç¥ç»ç½‘ç»œã€‚ä¸€ä¸ªè¾“å…¥å±‚ï¼Œä¸€ä¸ªè¾“å‡ºå±‚å’Œå¤šä¸ªéšè—å±‚ï¼Œå› æ­¤å¾—åâ€œæ·±åº¦å­¦ä¹ â€ã€‚\nâ€œå¼± AIâ€æˆ–â€œçª„ AIâ€ï¼Œåªèƒ½åšç‰¹å®šä»»åŠ¡ã€‚çœŸæ­£é€šç”¨çš„ï¼Œåƒäººä¸€æ ·èªæ˜çš„ AIï¼Œå«â€œå¼º AIâ€ã€‚\nå­¦ä¹ ä»€ä¹ˆç®¡ç”¨ï¼Œä»€ä¹ˆä¸ç®¡ç”¨ï¼Œè‡ªå·±å‘ç°æˆåŠŸçš„ç­–ç•¥ï¼Œè¿™å«â€œå¼ºåŒ–å­¦ä¹ â€ã€‚\n35. è®¡ç®—æœºè§†è§‰ å·ç§¯ç¥ç»ç½‘ç»œï¼Œç”¨ä¸€å †ç¥ç»å…ƒå¤„ç†å›¾åƒæ•°æ®ï¼Œæ¯ä¸ªéƒ½ä¼šè¾“å‡ºä¸€ä¸ªæ–°å›¾åƒ ã€‚\n36. è‡ªç„¶è¯­è¨€å¤„ç†äººç±»è¯­è¨€å«â€œè‡ªç„¶è¯­è¨€â€ã€‚è‡ªç„¶è¯­è¨€å¤„ç†ï¼Œç®€ç§° NLPã€‚\nåˆ†ææ ‘ï¼Œç”¨è§„åˆ™æ¥è®²å¥å­åˆ’åˆ†ä¸ºå—ï¼ŒåŒæ—¶æ ‡æ˜äº†å¥å­çš„ç»“æ„ã€‚\nè¯­éŸ³è¯†åˆ«ï¼Œå¦‚ä»Šå‡†ç¡®åº¦æœ€é«˜çš„è¯­éŸ³è¯†åˆ«ç³»ç»Ÿï¼Œç”¨æ·±åº¦ç¥ç»ç½‘ç»œã€‚\næ³¢å½¢è½¬æ¢ä¸ºè°±å›¾ï¼Œç”¨å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFFTï¼‰å®ç°æ³¢å½¢åˆ°é¢‘ç‡çš„è½¬æ¢ã€‚æ„æˆå•è¯çš„å£°éŸ³ç‰‡æ®µå«â€œéŸ³ç´ â€ã€‚\nè¯­éŸ³åˆæˆï¼Œè®©è®¡ç®—æœºè¾“å‡ºè¯­éŸ³ã€‚æŠŠä¸€æ®µæ–‡å­—ï¼Œåˆ†è§£æˆå¤šä¸ªå£°éŸ³ï¼Œç„¶åæ’­æ”¾è¿™äº›å£°éŸ³ã€‚\n37. æœºå™¨äººæœºå™¨äººæ˜¯ç”±è®¡ç®—æœºæ§åˆ¶ï¼Œå¯ä»¥è‡ªåŠ¨æ‰§è¡Œä¸€ç³»åˆ—åŠ¨ä½œçš„æœºå™¨ã€‚\næ¯”ä¾‹-ç§¯åˆ†-å¾®åˆ†æ§åˆ¶å™¨ï¼Œç®€ç§° PID æ§åˆ¶å™¨ã€‚æ¯”ä¾‹å€¼ï¼Œå®é™…å€¼å’Œç†æƒ³å€¼å·®å¤šå°‘ã€‚ç§¯åˆ†å€¼ï¼Œä¸€æ®µæ—¶é—´å†…è¯¯å·®çš„æ€»å’Œã€‚å¯¼æ•°å€¼ï¼ŒæœŸæœ›å€¼ä¸å®é™…å€¼ä¹‹é—´çš„å˜åŒ–ç‡ã€‚ä¸‰ä¸ªå€¼æœ‰ä¸åŒæƒé‡ï¼Œç„¶åç”¨æ¥æ§åˆ¶ç³»ç»Ÿã€‚\n","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®¡ç®—æœºåŸºç¡€çŸ¥è¯†"]},{"title":"ML for CO","url":"/2023/04/18/ML%20for%20CO/","content":"ML for CO ç»¼è¿°Yoshua Bengio, Andrea Lodi, and Antoine Prouvost. â€œMachine learning for combinatorial optimization: A methodological tour dâ€™horizonâ€, European Journal of Operational Research 290.2 (2021): 405-421.\nä¸å¤±ä¸€èˆ¬æ€§çš„ï¼ŒCO é—®é¢˜å¯ä»¥è¢«å…¬å¼åŒ–ä¸ºä¸€ä¸ªå—çº¦æŸçš„æœ€å°ä¼˜åŒ–é—®é¢˜ã€‚å¦‚æœç›®æ ‡å’Œçº¦æŸæ˜¯çº¿æ€§çš„ï¼Œåˆ™è¯¥é—®é¢˜ç§°ä¸ºçº¿æ€§è§„åˆ’ï¼ˆLPï¼‰é—®é¢˜ã€‚å¦‚æœä¸€äº›å˜é‡ä¹Ÿè¢«é™åˆ¶ä¸ºåªèƒ½ä¸ºæ•´æ•°å€¼ï¼Œåˆ™é—®é¢˜è¢«ç§°ä¸ºæ··åˆæ•´æ•°çº¿æ€§è§„åˆ’ï¼ˆMILPï¼‰é—®é¢˜ã€‚å¯ç”¨å•çº¯å½¢ç®—æ³•å¤šé¡¹å¼å¤æ‚åº¦æ±‚è§£ LP é—®é¢˜ã€‚\nåˆ†æ”¯é™ç•Œï¼ˆbranch and boundï¼‰ï¼Œåˆ†æ”¯æ˜¯ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆç­–ç•¥ï¼Œä¾æ¬¡ç”Ÿæˆæ‰©å±•ç»“ç‚¹çš„æ‰€æœ‰åˆ†æ”¯ï¼Œé™ç•Œæ˜¯åœ¨ç»“ç‚¹æ‰©å±•è¿‡ç¨‹ä¸­ï¼Œè®¡ç®—ç»“ç‚¹çš„ä¸Šç•Œï¼Œæœç´¢çš„åŒæ—¶å‰ªæ‰æŸäº›åˆ†æ”¯ã€‚åˆ†æ”¯é™ç•Œæ³•å°±æ˜¯æŠŠé—®é¢˜çš„å¯è¡Œè§£å±•å¼€ï¼Œå†ç”±å„ä¸ªåˆ†æ”¯å¯»æ‰¾æœ€ä½³è§£ã€‚\nå¯¹äº MILP é—®é¢˜ï¼Œåˆ†æ”¯é™ç•Œç®—æ³•ä¸ºå°†é—®é¢˜æ¾å¼›ä¸ºå®æ•°å˜é‡ååˆ†è§£ä¸ºå°é—®é¢˜ã€‚\nEnd to end learningé€šè¿‡ MLï¼Œç”± Problem defifinition ç›´æ¥å¾—åˆ° Solutionã€‚ML é€‚åˆåœ¨è¾ƒçŸ­çš„è®¡ç®—æ—¶é—´å†…è·å¾—å‡†ç¡®çš„è§£å†³æ–¹æ¡ˆï¼Œå› ä¸ºä¸€äº›å¤æ‚æ€§æ˜¯åœ¨å­¦ä¹ é˜¶æ®µç¦»çº¿è§£å†³çš„ã€‚\nLearning meaningful properties of optimization problemsé€šè¿‡ MLï¼Œä¸ºä¼ ç»Ÿçš„è¿ç­¹ä¼˜åŒ–æ–¹æ³•æä¾›ä¿¡æ¯ã€‚\nMachine learning alongside optimization algorithmsæ„å»º CO ç®—æ³•ï¼Œåœ¨æ•´ä¸ªæ‰§è¡Œè¿‡ç¨‹ä¸­åå¤è°ƒç”¨ ML æ¨¡å‹ã€‚ä¸»ç®—æ³•æ§åˆ¶é«˜çº§ç»“æ„ï¼ŒåŒæ—¶ç»å¸¸è°ƒç”¨MLæ¨¡å‹ä»¥ååŠ©è¾ƒä½çº§åˆ«å†³ç­–ã€‚\næœ€å¤§å…¬å…±å­å›¾ï¼ˆMCSï¼‰Ciaran McCreesh, Patrick Prosser, and James Trimble. â€œA Partitioning Algorithm for Maximum Common Subgraph Problems.â€, International Joint Conference on Artificial Intelligence (2017): 712-719.\nYanli Liu, Chumin Li, Hua Jiang, and Kun He. â€œA Learning Based Branch And Bound For Maximum Common Subgraph Related Problemsâ€, AAAI Conference on Artificial Intelligence 34. (2020): 2392-2399.\nJianrong Zhou, Kun He, Jiongzhi Zheng, Chu-Min Li, and Yanli Liu. â€œA Strengthened Branch and Bound Algorithm for the Maximum Common (Connected) Subgraph Problemâ€, European Conference on Artificial Intelligence (2022): 1908-1914.\nThe McSplit Algorithmæœç´¢è¿‡ç¨‹ä¸­çš„å½“å‰çŠ¶æ€ä¸ºç‚¹å¯¹çš„æ˜ å°„ ï¼ŒåŒæ—¶å°†è¿˜æœªè€ƒè™‘çš„ç‚¹æ‰“ä¸Šä¸€ä¸ªä¸å·²è€ƒè™‘çš„ç‚¹é›†è¿é€šæ€§çš„ ï¼Œ ç›¸åŒçš„ç‚¹å¯¹æ‰å¯åŠ å…¥æ˜ å°„ï¼Œå³é€‰æ‹©å¤„äºåŒä¸€æ ‡ç­¾ç±»çš„ç‚¹å¯¹ã€‚\nå½“å‰çŠ¶æ€å¯¹åº”çš„ç­”æ¡ˆä¸Šç•Œä¸ºï¼š\n\n|M|+\\sum_{l \\in L}\\min( |\\{v \\in \\text{V}(\\mathcal{G}):\\text{label}(v)=l\\}|,|\\{v \\in \\text{V}(\\mathcal{H}):\\text{label}(v)=l\\}| )å¯å‘å¼ï¼šé€‰æ‹©æ ‡ç­¾ç±»æ—¶ï¼Œé€‰æ‹©  æœ€å°çš„æ ‡ç­¾ç±»ï¼Œä»  ä¸­é€‰ç‚¹æ—¶ï¼Œé€‰åº¦æ•°æœ€å¤§çš„ç‚¹ã€‚\nMcSplit+RL\nå› ä¸ºé¢„è®¡çš„ä¸Šç•Œè¶Šå°ï¼Œè¶Šå¯èƒ½å‰ªæï¼Œå› æ­¤è€ƒè™‘å°†ä¸Šç•Œçš„å‡å°‘é‡ä½œä¸ºå¥–åŠ±ã€‚\n\nåŒæ—¶ï¼Œè‹¥è€ƒè™‘ä¸Šç•Œçš„å‡å°‘ç‡ï¼Œåˆ™åˆå¾—åˆ°ä¸€ç§å˜ä½“æ–¹æ³•ã€‚\n\nè€ƒè™‘ç‚¹å¯¹çš„åŒ¹é…ä½œä¸ºå¥–åŠ±ã€‚\n\n\nMcSplit+LL AlgorithmLong-Short Memory (LSM)\néšç€æœç´¢çš„æ·±å…¥ï¼Œå½“å‰çŠ¶æ€ä¼šæœ‰å¾ˆå¤§çš„å˜åŒ–ï¼Œå‡åŒ€åœ°ç´¯ç§¯åˆ†æ•°ä¼šå¯¼è‡´ç”±å¤§éƒ¨åˆ†å†å²è¯„ä¼°å€¼å¼•èµ·çš„åå·®ã€‚å› æ­¤ï¼Œéœ€è¦ä¸€ç§èƒ½å¤Ÿæ¶ˆé™¤å†å²è¯„ä¼°çš„å½±å“çš„æœºåˆ¶ã€‚\nè€ƒè™‘çŸ­æœŸé˜ˆå€¼  ï¼ˆé»˜è®¤ä¸º ï¼‰å’Œé•¿æœŸé˜ˆå€¼  ï¼ˆé»˜è®¤ä¸º ï¼‰ã€‚è‹¥  å¤§äº ï¼Œåˆ™æ‰€æœ‰  è¡°å‡åˆ°ä¸€åŠã€‚è‹¥  å¤§äº ï¼Œåˆ™æ‰€æœ‰  è¡°å‡åˆ°ä¸€åŠã€‚\nLeaf vertex Union Match (LUM)\nå¶èŠ‚ç‚¹å®šä¹‰ä¸ºåªè·Ÿä¸€ä¸ªç‚¹ç›¸é‚»çš„èŠ‚ç‚¹ã€‚ä¸€ä¸ªç‚¹çš„å¶å­å®šä¹‰ä¸ºä¸è¯¥ç‚¹ç›¸é‚»çš„å¶èŠ‚ç‚¹ã€‚\nå®šç†ï¼šåœ¨è¿›è¡Œ  æ—¶ï¼Œå½“ä¸€å¯¹ç‚¹  åŒ¹é…æ—¶ï¼Œå¯ä»¥ä»  çš„ä¸åŒ¹é…çš„å¶å­ä¸­åŒ¹é…å°½å¯èƒ½å¤šçš„ç‚¹å¯¹ï¼Œè€Œä¸å½±å“è§£çš„æœ€ä¼˜æ€§ã€‚\næ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰LKHæ±‚è§£ TSP çš„å¯å‘å¼ç®—æ³•å¯åˆ†ä¸ºä¸‰ç±»ï¼šå›è·¯æ„é€ ç®—æ³•ã€å›è·¯æ”¹è¿›ç®—æ³•å’Œå¤åˆç®—æ³•ã€‚å¤åˆç®—æ³•é€šå¸¸ä½¿ç”¨å›è·¯æ”¹è¿›ç®—æ³•å¯¹å›è·¯æ„é€ ç®—æ³•å¾—åˆ°çš„åˆå§‹è§£è¿›è¡Œæ”¹è¿›ã€‚LKH ç®—æ³•æ˜¯ä¸€ç§åˆ©ç”¨ k-opt æ¥æ”¹è¿›å¯å‘å¼æ„é€ çš„åˆå§‹è¡Œç¨‹çš„å¤åˆç®—æ³•ã€‚\nk-optï¼šæ›¿æ¢å½“å‰è§£çš„  æ¡è¾¹ï¼Œå¾—åˆ°ä¸€ä¸ªæ›´ä¼˜çš„æ–°è§£ã€‚    \n\n1-tree ä¸‹ç•Œï¼šä»  ä¸­é€‰å‡ºä¸€ä¸ªç‚¹ ï¼Œæ±‚å‡ºå‰©ä¸‹ç‚¹  çš„æœ€å°ç”Ÿæˆæ ‘ï¼Œæœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼å†åŠ ä¸Š  å‘æœ€å°ç”Ÿæˆæ ‘çš„ä¸åŒä¸¤ä¸ªç‚¹è¿å‡ºçš„æœ€å°æƒå€¼çš„è¾¹çš„æƒå€¼ï¼ˆä¸€æ¡è¾¹ä¸ºè¿›å…¥æœ€å°ç”Ÿæˆæ ‘ï¼Œä¸€æ¡è¾¹ä¸ºç¦»å¼€æœ€å°ç”Ÿæˆæ ‘ï¼‰ï¼Œå³ä¸º 1-tree ä¸‹ç•Œã€‚1-tree ä¸‹ç•Œä¸ä¸€å®šæ˜¯å¯è¡Œè§£ã€‚å½“ 1-tree ä¸­æ¯ä¸ªç‚¹åº¦æ•°éƒ½ä¸º  æ—¶ä¸ºå¯è¡Œè§£ï¼Œä¸”ä¸ºæœ€ä¼˜è§£ã€‚\nå®šä¹‰ ï¼Œå…¶ä¸­  ä¸º 1-tree çš„æƒå€¼ï¼Œ ä¸ºå¿…é¡»åŒ…å«è¾¹  çš„ 1-tree çš„æƒå€¼ã€‚ä¸€æ¡è¾¹çš„  å€¼å¯ä»¥çœ‹åšå¿…é¡»åŒ…å«è¯¥è¾¹çš„æœ€å° 1-tree çš„é¢å¤–æƒå€¼ã€‚åœ¨ LKH ç®—æ³•ä¸­ï¼Œæœ‰æ›´å°çš„  å€¼çš„è¾¹åœ¨æœç´¢ä¸­æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ã€‚\nHeld-Karp ä¸‹ç•Œï¼šLKH ç®—æ³•é€šè¿‡æ·»åŠ æƒ©ç½š  æ¥æœ€å¤§åŒ–æœ€ä¼˜ TSP è§£çš„ä¸‹ç•Œï¼Œè¾¹æƒå˜ä¸ºï¼šã€‚è¿™ä¸ªå˜åŒ–ä¸æ”¹å˜ TSP çš„æœ€ä¼˜è§£ï¼Œä½†æ”¹å˜äº†æœ€å°çš„ 1-treeã€‚æœ€å¤§åŒ– ï¼Œå³ä¸º Held-Karp ä¸‹ç•Œã€‚è¿­ä»£ä¸º ï¼Œå…¶ä¸­  ä¸ºç‚¹  åœ¨æœ€å° 1-tree ä¸­çš„åº¦æ•°ï¼Œ ä¸ºè¿­ä»£çš„å‚æ•°ï¼Œ ä¸ºè¿­ä»£çš„è½®æ•°ã€‚è¿­ä»£å³ä¸ºè®©æœ€å° 1-tree ä¸­çš„ç‚¹çš„åº¦æ•°éƒ½å˜ä¸º ã€‚\nVSR-LKHJiongzhi Zheng, Kun He, Jianrong Zhou, Yan Jin, and Chu-min Li. â€œCombining Reinforcement Learning With Lin-Kernighan-Helsgaun Algorithm For The Traveling Salesman Problemâ€, AAAI Conference on Artificial Intelligence 35 (2021): 12445-12452.\nVSR-LKH ä¸­ï¼Œk-opt è¿‡ç¨‹ä¸å†æ˜¯éå†å€™é€‰è¾¹é›†ï¼Œè€Œæ˜¯é€šè¿‡å¼ºåŒ–å­¦ä¹ æ¥ä»å€™é€‰è¾¹é›†é€‰æ‹©æ·»åŠ çš„è¾¹ã€‚å¯¹äºè¯¥å¼ºåŒ–å­¦ä¹ ï¼ŒçŠ¶æ€ä¸ºå½“å‰éœ€è¦åŠ è¾¹çš„ç‚¹ï¼ŒåŠ¨ä½œä¸ºåŠ è¾¹ï¼ŒåŠ è¾¹åçŠ¶æ€è½¬ç§»ä¸ºæ‰€åŠ è¾¹çš„å¦ä¸€ä¸ªç«¯ç‚¹ï¼Œå¥–åŠ±ä¸ºï¼š\n\nr_t(s_t,a_t)=\n\\begin{cases}\nC(a_{t-1},s_t)-C(s_t,a_t) & t > 0 \\\\\nC(p_1,s_0) - C(s_0,a_0)  & t=0 \\\\\n\\end{cases}å®šä¹‰  çš„åˆå§‹  ä¸ºï¼š\n\nQ(i,j)=\\frac{w(\\pi)}{\\alpha(i, j)+d(i,j)} å½±å“é€‰æ‹©è¾¹çš„ä¼˜å…ˆçº§ã€‚\nNeuroLKHLiang Xin, Wen Song, Zhiguang Cao, and Jie Zhang. â€œNeuroLKH: Combining Deep Learning Model with Lin-Kernighan-Helsgaun Heuristic for Solving the Traveling Salesman Problem.â€, Conference on Neural Information Processing Systems (2021): 7472-7483.\nLKH ä¸­è¿­ä»£  åèƒ½æå‡å€™é€‰è¾¹é›†çš„è´¨é‡ï¼Œä½†ä»æœ‰å±€é™æ€§ï¼Œå› æ­¤æå‡ºäº† NeuroLKH æ¥æ„å»ºå€™é€‰è¾¹é›†ã€‚\né¦–å…ˆå°†åŸå›¾è½¬åŒ–ä¸ºç¨€ç–æœ‰å‘å›¾ $G^=(V,E^)ï¼Œæ¯ä¸ªç‚¹æ‰€è¿çš„è¾¹åªä¿ç•™æœ€çŸ­çš„\\gammaæ¡ï¼Œè¿™\\gammaæ¡çœ‹ä½œæ˜¯è¯¥ç‚¹è¿å‡ºçš„æœ‰å‘è¾¹ã€‚å®éªŒä¸­å–äº†\\gamma=20$ã€‚\nç”¨ç¨€ç–å›¾ç½‘ç»œæ¥é¢„æµ‹è¾¹çš„æƒå€¼  å’Œç‚¹çš„æƒ©ç½š ã€‚ ä¸æ˜¯è¾¹æƒï¼Œå…¶æƒå€¼è¶Šå¤§ï¼Œæœç´¢ä¸­è¶Šä¼˜å…ˆé€‰æ‹©è¿™æ¡è¾¹ï¼Œ å³ä¸ºä¸Šé¢æ”¹å˜è¾¹æƒçš„æƒ©ç½šã€‚\n\nå…ˆå°†è¾¹å’Œç‚¹çš„ä¿¡æ¯è½¬åŒ–ä¸ºç‰¹å¾å‘é‡ï¼Œç»´åº¦ä¸º ï¼Œç”¨  å±‚ç¨€ç–å›¾å·ç§¯å±‚æ¥é¢„æµ‹ï¼Œå®éªŒä¸­å–  å’Œ ï¼Œå·ç§¯å±‚å®šä¹‰ä¸ºï¼š\n\n\\begin{aligned}\nattn^l_{i,j}&=\\exp(W_a^le_{i,j}^{l-1})\\oslash \\sum_{(i,m)\\in E^*}\\exp(W_a^le_{i,m}^{l-1}) \\\\\nv^l_i&=v^{l-1}_i+ReLU(BN(W_s^lv_i^{l-1}+\\sum_{(i,j)\\in E^*}attn^l_{i,j}\\odot W_n^l v_j^{l-1})) \\\\\nr^l_{i.j}&=\n\\begin{cases}\nW_r^le_{j,i}^{l-1}, & \\text{if}\\ (j,i)\\in E^* \\\\\nW_r^lp^l,&\\text{otherwise}\n\\end{cases} \\\\\ne^l_{i,j}&=e^{l-1}_{i,j}+ReLU(BN(W_f^lv_i^{l-1}+W_t^lv_j^{l-1}+W_o^le^{l-1}_{i,j}+r^l_{i,j}))\n\\end{aligned} å’Œ  åˆ†åˆ«æ˜¯æŒ‰å…ƒç´ ä¹˜æ³•å’ŒæŒ‰å…ƒç´ é™¤æ³•ï¼Œ æ˜¯å±‚æ•°ï¼Œ å’Œ  éƒ½æ˜¯è®­ç»ƒçš„å‚æ•°ã€‚\n ç»è¿‡ä¸¤å±‚çº¿æ€§å±‚åå†ç”±  æ¿€æ´»å¾—åˆ° ã€‚åŒæ ·çš„ï¼Œ ç»è¿‡ä¸¤å±‚çº¿æ€§å±‚åå†ç”±  æ¿€æ´»å¾—åˆ° ã€‚ç„¶åå†è®¡ç®—  å’Œ ï¼š\n\n\\begin{aligned}\n\\beta_{i,j}&=\\frac{\\exp(W_\\beta e^f_{i,j})}{\\sum_{(i,m)\\in E^*}\\exp(W_{\\beta}e^f_{i,m})}\\\\\n\\pi_i&=C\\tanh(W_\\pi v^f_i)\n\\end{aligned} æ˜¯è®­ç»ƒçš„å‚æ•°ï¼Œï¼Œä½¿å¾—  èŒƒå›´ä¸º ã€‚\nè¾¹çš„æƒå€¼  é€šè¿‡ç›‘ç£å­¦ä¹ è®­ç»ƒï¼Œç‚¹çš„æƒ©ç½š  é€šè¿‡æ— ç›‘ç£å­¦ä¹ è®­ç»ƒã€‚æŸå¤±å‡½æ•°åˆ†åˆ«ä¸ºï¼š\n\n\\begin{aligned}\n\\mathcal{L}_\\beta&=-\\frac{1}{\\gamma|V|} \\sum_{(i,j)\\in E^*} (\\mathbb{1}\\{(i,j)\\in E_o^* \\}\\log \\beta_{i,j}+\\mathbb{1}\\{(i,j)\\not \\in E_o^* \\}\\log (1-\\beta_{i,j})) \\\\\n\\mathcal{L}_\\pi&=-\\frac{1}{|V|}\\sum_{i \\in V}(d_i(\\pi)-2)\\pi_i\\\\\n\\mathcal{L}&=\\mathcal{L}_\\beta+\\eta_\\pi\\mathcal{L}_\\pi\n\\end{aligned}$E_o^=\\{ (i,j) \\in E^| (i,j)\\ \\text{in\\ the\\ optimal tour} \\}ï¼Œå³ä¸ºè‹¥ä¸€æ¡è¾¹åœ¨æœ€ä¼˜è§£ä¸­ï¼Œåˆ™å¢å¤§å…¶æƒå€¼\\beta_{i,j}$ã€‚\n ä¸ºç‚¹  åœ¨æœ€å° 1-tree ä¸­çš„åº¦æ•°ï¼Œ ä¸ºå¹³è¡¡ä¸¤ä¸ªæŸå¤±å‡½æ•°çš„ç³»æ•°ã€‚å®éªŒä¸­å– ã€‚\nå¯¹äºå¤§è§„æ¨¡çš„æ•°æ®ï¼Œè¾¹çš„æƒå€¼  å¯ä»¥å¾ˆå¥½åœ°æ³›åŒ–ï¼Œä½†ç‚¹çš„æƒ©ç½š  ä¸èƒ½ç›´æ¥æ³›åŒ–ã€‚å› ä¸º  æ˜¯é€šè¿‡æ— ç›‘ç£å­¦ä¹ è®­ç»ƒçš„ã€‚å› æ­¤ï¼Œå¯¹äº  è¿›è¡Œå¾®è°ƒï¼Œè¿›è¡Œ  æ¬¡è¿­ä»£ï¼Œæ‰¹å¤„ç†å¤§å°ä¸º ã€‚\nå›¾åŒ¹é…Junchi Yan, Shuang Yang, and Edwin R. Hancock. â€œLearning for Graph Matching and Related Combinatorial Optimization Problems.â€, International Joint Conference on Artificial Intelligence 5 (2020): 4988-4996.\n","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®ºæ–‡","ML4CO","äººå·¥æ™ºèƒ½"]},{"title":"å´æ©è¾¾æœºå™¨å­¦ä¹ ","url":"/2022/10/23/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"è¯¾ç¨‹ 1 Supervised Machine Learning: Regression and ClassificationWeek 1: Introduction to Machine Learningç›‘ç£å­¦ä¹ ç›‘ç£å­¦ä¹ æ˜¯è¾“å…¥  åˆ°è¾“å‡ºæ ‡ç­¾  æ˜ å°„çš„ç®—æ³•ã€‚ç®—æ³•ä»äº‹å…ˆç»™çš„â€œæ­£ç¡®ç­”æ¡ˆâ€ä¸­å­¦ä¹ ã€‚\nç¬¬ä¸€ç§ç›‘ç£å­¦ä¹ ç®—æ³•ï¼Œå›å½’ï¼Œä»æ— é™å¤šä¸ªå¯èƒ½çš„æ•°ä¸­é¢„æµ‹å‡ºä¸€ä¸ªæ•°ã€‚å¦‚é¢„æµ‹æˆ¿ä»·ã€‚\nç¬¬äºŒç§ç›‘ç£å­¦ä¹ ç®—æ³•ï¼Œåˆ†ç±»ï¼Œé¢„æµ‹ç±»åˆ«åœ¨ä¸€ä¸ªå°çš„ã€æœ‰é™çš„è¾“å‡ºç±»åˆ«é›†åˆã€‚å¦‚åˆ¤æ–­çŒ«ç‹—ã€‚\næ— ç›‘ç£å­¦ä¹  åœ¨æ•°æ®é›†ä¸­æ‰¾åˆ°ä¸€äº›ç»“æ„æˆ–è€…æ¨¡å¼ã€‚ä¸äº‹å…ˆç»™â€œæ­£ç¡®ç­”æ¡ˆâ€ã€‚\nèšç±»ç®—æ³•ï¼Œä¸€ç§æ— ç›‘ç£å­¦ä¹ ç®—æ³•ï¼Œå°†æœªæ ‡è®°çš„æ•°æ®æ”¾åœ¨ä¸åŒçš„ç°‡ä¸­ã€‚\nå…¶ä»–çš„æ— ç›‘ç£å­¦ä¹ ç®—æ³•ï¼šå¼‚å¸¸æ£€æµ‹ï¼Œé™ç»´ã€‚\nçº¿æ€§å›å½’æ–¹å·®ä»£ä»·å‡½æ•°ï¼š\n\n\\begin{aligned}\nJ(w,b)&=\\frac{1}{2m}\\sum_{i=1}^m(\\hat y^{(i)}-y^{(i)})^2 \\\\\n\\hat y^{(i)}&=f_{w,b}(x^{(i)})=wx^{(i)}+b\n\\end{aligned}æ¢¯åº¦ä¸‹é™\n\\begin{aligned}\nw&=w-\\alpha \\frac{\\partial}{\\partial w}J(w,b) \\\\\nb&=b-\\alpha \\frac{\\partial}{\\partial b}J(w,b)\n\\end{aligned}è¿™é‡Œçš„  æ˜¯èµ‹å€¼ã€‚ ä¸ºå­¦ä¹ ç‡ï¼Œå–å€¼åº”é€‚å½“ï¼Œä¸èƒ½å¤ªå°å¤ªå¤§ã€‚å› ä¸ºåœ¨æ¢¯åº¦ä¸‹é™çš„è¿‡ç¨‹ä¸­ï¼Œå¯¼æ•°ä¼šè‡ªåŠ¨å˜å°ï¼Œæ‰€ä»¥æ›´æ–°çš„æ­¥å¹…ä¹Ÿä¼šè‡ªåŠ¨å˜å°ã€‚\n\n\\begin{aligned}\n\\frac{\\partial}{\\partial w}J(w,b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{w,b}(x^{(i)})-y^{(i)})x^{(i)} \\\\\n\\frac{\\partial}{\\partial b}J(w,b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{w,b}(x^{(i)})-y^{(i)})\n\\end{aligned} æ‰¹é‡æ¢¯åº¦ä¸‹é™æŒ‡çš„æ˜¯æ¯ä¸€æ­¥æ¢¯åº¦ä¸‹é™ï¼Œéƒ½ä¼šè€ƒè™‘åˆ°æ‰€æœ‰çš„è®­ç»ƒæ ·æœ¬ã€‚\nWeek 2: Regression with multiple input variableså¤šå…ƒçº¿æ€§å›å½’\n\\begin{aligned}\n\\overset{\\rightarrow}{w}&=\\begin{bmatrix} w_1&w_2&w_3&\\cdots& w_n\\end{bmatrix}\\\\\n\\overset{\\rightarrow}{x}&=\\begin{bmatrix} x_1&x_2&x_3&\\cdots& x_n\\end{bmatrix}\\\\\nf_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x})&=w_1x_1+w_2x_2+ \\cdots + w_nx_n+b \\\\\n&=\\overset{\\rightarrow}{w}\\cdot\\overset{\\rightarrow}{x}+b \\\\\nw_j&=w_j-\\alpha \\frac{\\partial}{\\partial w_j}J(\\overset{\\rightarrow}{w},b) \\\\\nb&=b-\\alpha \\frac{\\partial}{\\partial b}J(\\overset{\\rightarrow}{w},b)\n\\end{aligned}ç‰¹å¾ç¼©æ”¾ä¸ºäº†è®©ç‰¹å¾  çš„å–å€¼èŒƒå›´æ¥è¿‘ ã€‚\nWeek 3: Classificationé€»è¾‘å›å½’ä¸€ç§åˆ†ç±»æ¨¡å‹ã€‚\n sigmoid functionï¼š\n\ng(z)=\\frac{1}{1+e^{-z}}é€»è¾‘å›å½’æ¨¡å‹ï¼š\n\nf_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x})=g(\\overset{\\rightarrow}{w}\\cdot\\overset{\\rightarrow}{x}+b)=\\frac{1}{1+e^{-(\\overset{\\rightarrow}{w}\\cdot\\overset{\\rightarrow}{x}+b)}}å†³ç­–è¾¹ç•Œï¼š\n\nz=\\overset{\\rightarrow}{w}\\cdot\\overset{\\rightarrow}{x}+b=0æŸå¤±å‡½æ•°ï¼š\n\n\\begin{aligned}\nL(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}),y^{(i)})&=\\begin{cases}\n-\\log (f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))&y^{(i)}=1\\\\\n-\\log (1-f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))&y^{(i)}=0\n\\end{cases} \\\\\n&=-y^{(i)}\\log (f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))-(1-y^{(i)})\\log (1-f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))\n\\end{aligned}ä»£ä»·å‡½æ•°ï¼š\n\n\\begin{aligned}\nJ(\\overset{\\rightarrow}{w},b)&=\\frac{1}{m}\\sum_{i=1}^mL(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}),y^{(i)}) \\\\\n&=-\\frac{1}{m}\\sum_{i=1}^my^{(i)}\\log (f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))+(1-y^{(i)})\\log (1-f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})) \\\\\n\\frac{\\partial}{\\partial w_j}J(\\overset{\\rightarrow}{w},b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})x^{(i)}_j \\\\\n\\frac{\\partial}{\\partial b}J(\\overset{\\rightarrow}{w},b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})\n\\end{aligned}è¿‡æ‹Ÿåˆé«˜åå·®çš„æ¨¡å‹ï¼Œæ¬ æ‹Ÿåˆã€‚é«˜æ–¹å·®çš„æ¨¡å‹ï¼Œè¿‡æ‹Ÿåˆã€‚\nè§£å†³è¿‡æ‹Ÿåˆçš„æ–¹æ³•ï¼š1.æ”¶é›†æ›´å¤šçš„æ•°æ®ã€‚2.é€‰æ‹©å¹¶ä½¿ç”¨ç‰¹å¾å­é›†ã€‚3.åˆ©ç”¨æ­£åˆ™åŒ–å‡å°å‚æ•°çš„å¤§å°ã€‚\næ­£åˆ™åŒ–çº¿æ€§å›å½’çš„æ­£åˆ™åŒ–ï¼š\n\n\\begin{aligned}\nJ(\\overset{\\rightarrow}{w},b)&=\\frac{1}{2m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})^2 +\\frac{\\lambda}{2m}\\sum_{j=1}^n w_j^2 \\\\\n\\frac{\\partial}{\\partial w_j}J(\\overset{\\rightarrow}{w},b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})x^{(i)}_j +\\frac{\\lambda}{m}w_j\\\\\n\\frac{\\partial}{\\partial b}J(\\overset{\\rightarrow}{w},b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})\n\\end{aligned}é€»è¾‘å›å½’çš„æ­£åˆ™åŒ–ï¼š\n\n\\begin{aligned}\nJ(\\overset{\\rightarrow}{w},b)&=-\\frac{1}{m}\\sum_{i=1}^my^{(i)}\\log (f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)}))+(1-y^{(i)})\\log (1-f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})) +\\frac{\\lambda}{2m}\\sum_{j=1}^n w_j^2 \\\\\n\\frac{\\partial}{\\partial w_j}J(\\overset{\\rightarrow}{w},b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})x^{(i)}_j +\\frac{\\lambda}{m}w_j\\\\\n\\frac{\\partial}{\\partial b}J(\\overset{\\rightarrow}{w},b)&=\\frac{1}{m}\\sum_{i=1}^m(f_{\\overset{\\rightarrow}{w},b}(\\overset{\\rightarrow}{x}^{(i)})-y^{(i)})\n\\end{aligned}è¯¾ç¨‹ 2 Advanced Learning AlgorithmsWeek 1: Neural Networksç¥ç»ç½‘ç»œè¾“å…¥å±‚ï¼Œè¾“å‡ºå±‚ï¼Œéšè—å±‚ã€‚ç¥ç»ç½‘ç»œç»“æ„çš„é—®é¢˜å°±æ˜¯ï¼Œè¦æœ‰å¤šå°‘ä¸ªéšè—å±‚ï¼Œæ¯ä¸ªéšè—å±‚è¦æœ‰å¤šå°‘ä¸ªç¥ç»å…ƒã€‚\nå¯¹äºç¥ç»ç½‘ç»œçš„ç¬¬  å±‚çš„ç¬¬  ä¸ªç¥ç»å…ƒï¼š\n\na_j^{[l]}=g(\\overset{\\rightarrow}{w}_j^{[l]} \\cdot \\overset{\\rightarrow}{a}^{[l-1]}+b_j^{[l]})å…¶ä¸­  ä¸ºæ¿€æ´»å‡½æ•°ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºå‰å‘ä¼ æ’­ã€‚\nWeek 2: Neural network trainingæ¿€æ´»å‡½æ•°Linear activation functionï¼š\nSigmoidï¼š\nReLUï¼š\nå¯¹äºè¾“å‡ºå±‚ï¼š\näºŒåˆ†ç±»é—®é¢˜ï¼Œä½¿ç”¨ Sigmoidã€‚\n å¯æ­£å¯è´Ÿï¼Œä½¿ç”¨ Linear activation functionã€‚\n éè´Ÿï¼Œä½¿ç”¨ ReLUã€‚\nå¯¹äºéšè—å±‚ï¼Œä½¿ç”¨ ReLUã€‚\nå¤šåˆ†ç±»å¤šåˆ†ç±»é—®é¢˜ï¼Œå¦‚æ•°å­—è¯†åˆ«ï¼Œç»“æœä¸º  åˆ° ã€‚\nSoftmax å›å½’ç®—æ³•æ˜¯é€»è¾‘å›å½’çš„æ¨å¹¿ï¼Œç”¨æ¥è§£å†³å¤šåˆ†ç±»é—®é¢˜ã€‚\n å¯ä»¥å–  ä¸ªå€¼ï¼š\n\n\\begin{aligned}\nz_j&=\\overset{\\rightarrow}{w}_j \\cdot \\overset{\\rightarrow}{x}+b_j&j=1,\\dots,n \\\\\na_j&=\\frac{e^{z_j}}{\\sum_{k=1}^n e^{z_k}}=P(y=j | \\overset{\\rightarrow}{x})\n\\end{aligned} æ—¶å³ä¸ºé€»è¾‘å›å½’ã€‚\næŸå¤±å‡½æ•°ï¼š\n\nloss(a_1,\\dots,a_n,y)=\\begin{cases}\n-\\log a_1 & y=1 \\\\\n-\\log a_2 & y=2 \\\\\n&\\vdots \\\\\n-\\log a_n & y=n \\\\\n\\end{cases}å¤šæ ‡ç­¾åˆ†ç±»å¤šæ ‡ç­¾åˆ†ç±»ï¼Œå¦‚åˆ¤æ–­å›¾ç‰‡ä¸Šæœ‰æ— æ±½è½¦ï¼Œå…¬äº¤è½¦ï¼Œè¡Œäººã€‚\nAdam ç®—æ³•è‡ªåŠ¨è°ƒæ•´å­¦ä¹ ç‡ï¼Œè¿‡å°æ—¶å¢å¤§ï¼Œè¿‡å¤§æ—¶å‡å°ã€‚\nWeek 3: Advice for applying machine learningæ¨¡å‹è¯„ä¼°è§£å†³æ–¹æ¡ˆï¼š\né«˜åå·®ï¼šå¢åŠ ç‰¹å¾ï¼Œå¢åŠ å¤šé¡¹å¼ç‰¹å¾ï¼ˆå¦‚ ï¼‰ï¼Œå‡å° ã€‚\né«˜æ–¹å·®ï¼šæ›´å¤šè®­ç»ƒæ ·æœ¬ï¼Œå‡å°‘ç‰¹å¾ï¼Œå¢å¤§ ã€‚\nWeek 4: Decision treeså†³ç­–æ ‘ç†µï¼Œå¯¹ä¸€ç»„æ•°æ®ä¸çº¯åº¦çš„è¡¡é‡ã€‚\n\n\\begin{aligned}\nH(p_1)&=-p_1\\log_2(p_1)-p_0\\log_2(p_0) \\\\\n&=-p_1\\log_2(p_1)-(1-p_1)\\log_2(1-p_1)\n\\end{aligned}ä¿¡æ¯å¢ç›Šï¼š\n\nH(p_1^{root})-( w^{left}H(p_1^{left})+w^{right}H(p_1^{right}) )å…¶ä¸­ï¼Œ ä¸ºå·¦å­æ ‘ä¸­å¸¦æœ‰æ­£æ ‡ç­¾çš„æ ·æœ¬çš„æ¯”ä¾‹ï¼Œ ä¸ºæ ¹èŠ‚ç‚¹åˆ°å·¦è¾¹å­åˆ†æ”¯çš„æ ·æœ¬çš„æ¯”ä¾‹ã€‚\nåœæ­¢æ¡ä»¶ï¼š\nä¸€ä¸ªèŠ‚ç‚¹æ‰€æœ‰æ•°æ®æ ‡ç­¾ç›¸åŒã€‚\næ ‘çš„æ·±åº¦å¤§äºæŸä¸€é˜ˆå€¼ã€‚\næœ€å¤§ä¿¡æ¯å¢ç›Šå°äºæŸä¸€é˜ˆå€¼ã€‚\nä¸€ä¸ªèŠ‚ç‚¹æ•°æ®æ•°å°äºæŸä¸€é˜ˆå€¼ã€‚\nOne-hot ç¼–ç \nå¯¹å¤šåˆ†ç±»é—®é¢˜çš„å†³ç­–æ ‘åº”ç”¨ One-hot ç¼–ç ï¼Œå³å¯è½¬åŒ–ä¸ºäºŒåˆ†ç±»é—®é¢˜ã€‚å¦‚è€³æœµä¸ºæ¤­åœ†ï¼Œå°–è§’ï¼Œè€·æ‹‰è½¬åŒ–ä¸ºè€³æœµæ˜¯å¦æ¤­åœ†ç­‰ã€‚\nè¿ç»­å€¼\nè‹¥ç‰¹å¾ä¸ºè¿ç»­å€¼ï¼Œåˆ™å–é˜ˆå€¼ ï¼Œé˜ˆå€¼é€šå¸¸ä¸º ï¼Œè¿™é‡Œ  æœ‰åºã€‚å°†ç‰¹å¾è½¬åŒ–ä¸º ï¼Œå˜ä¸º ã€‚\nå›å½’æ ‘\nå’Œå†³ç­–æ ‘ç±»ä¼¼ï¼Œä¸å†é¢„æµ‹åˆ†ç±»ï¼Œè€Œæ˜¯è¾“å‡ºä¸€ä¸ª ã€‚\nä¿¡æ¯å¢ç›Šï¼š\n\nD(p_1^{root})-( w^{left}D(p_1^{left})+w^{right}D(p_1^{right}) ) ä¸ºæ–¹å·®å‡½æ•°ã€‚\né›†æˆæ ‘\nä½¿ç”¨é›†æˆæ ‘åï¼Œä¸ç”¨æ‹…å¿ƒæ•´ä½“ç®—æ³•ä¼šå¯¹ä»»ä½•ä¸€æ£µæ ‘çš„é¢„æµ‹è¿‡äºæ•æ„Ÿã€‚\né€šè¿‡æœ‰æ”¾å›æŠ½æ ·ï¼Œå¾—åˆ°å’ŒåŸæ•°æ®é›†å¤§å°ç›¸ç­‰çš„æ–°æ•°æ®é›†ï¼Œç”¨æ–°æ•°æ®é›†æ¥æ„å»ºé›†æˆæ ‘ã€‚\néšæœºæ£®æ—ç®—æ³•\nå¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œå½“è¦é€‰ç‰¹å¾æ¥åˆ†è£‚æ—¶ï¼Œè‹¥æœ‰  ä¸ªç‰¹å¾å¯é€‰ï¼Œåˆ™éšæœºé€‰  ä¸ªç‰¹å¾æ¥è€ƒè™‘ã€‚é€šå¸¸å– ã€‚\nboosting æŒ‡å†æ„å»ºä¸€æ£µæ–°æ ‘æ—¶ï¼Œä¼˜å…ˆé€‰å–åœ¨å½“å‰å†³ç­–æ ‘æ£®æ—ä¸­è¢«é”™è¯¯åˆ†ç±»çš„æ ·æœ¬ã€‚\nè¯¾ç¨‹ 2 Unsupervised Learning, Recommenders, Reinforcement LearningWeek 1: Unsupervised learningèšç±»K-means\nç¬¬ä¸€æ­¥æ˜¯å°†ç‚¹åˆ†é…ç»™ç°‡è´¨å¿ƒï¼ˆç°‡çš„ä¸­å¿ƒï¼‰ï¼Œç¬¬äºŒæ­¥æ˜¯ç§»åŠ¨ç°‡è´¨å¿ƒã€‚\nä»£ä»·å‡½æ•°ï¼ˆdistortion å‡½æ•°ï¼‰ï¼š\n\n\\large J(c^{(1)},\\dots,c^{(m)},\\mu_1,\\dots,\\mu_k)=\\frac{1}{m}\\sum_{i=1}^{m}|x^{(i)}-\\mu_{c^{(i)}}|^2 ä¸ºç¬¬  ä¸ªç°‡è´¨å¿ƒï¼Œ è¡¨ç¤ºç¬¬  ä¸ªç‚¹  å½“å‰å¯¹åº”çš„ç°‡ï¼ˆæœ€è¿‘çš„ç°‡è´¨å¿ƒï¼‰ã€‚\nç¬¬ä¸€æ­¥æ˜¯å›ºå®š ï¼Œé€šè¿‡è°ƒæ•´  æ¥è®©  æœ€å°ï¼Œç¬¬ä¸€æ­¥æ˜¯å›ºå®š ï¼Œé€šè¿‡è°ƒæ•´  æ¥è®©  æœ€å°ã€‚åœ¨æ¯ä¸€æ¬¡è¿­ä»£ä¸­ï¼Œä»£ä»·å‡½æ•°ä¸‹é™æˆ–ä¸å˜ã€‚\nä¸€å¼€å§‹éšæœºé€‰æ ·æœ¬ç‚¹æ¥ä½œä¸ºç°‡è´¨å¿ƒã€‚\nå¼‚å¸¸æ£€æµ‹é€šè¿‡è§‚å¯Ÿæ­£å¸¸äº‹ä»¶çš„æœªæ ‡è®°æ•°æ®é›†ï¼Œä»è€Œå­¦ä¼šæ£€æµ‹å¼‚å¸¸æˆ–åœ¨å¼‚å¸¸äº‹ä»¶å‘ç”Ÿæ—¶å‘å‡ºå±é™©ä¿¡å·ã€‚\nå¯†åº¦ä¼°è®¡\nå¯¹äº  ä¸ªæ ·æœ¬ï¼Œæ¯ä¸ªæ ·æœ¬æœ‰  ä¸ªç‰¹å¾ï¼š\n\n\\begin{aligned}\n\\mu_j&=\\frac{1}{m}\\sum_{i=1}^mx_j^{(i)} \\\\\n\\sigma^2_j&=\\frac{1}{m}\\sum_{i=1}^m(x_j^{(i)}-\\mu_j)^2 \\\\\np(x)&=\\prod_{i=1}^n \np(x_i;\\mu_i,\\sigma_i^2)\\\\\n&=\\prod_{i=1}^n\\frac{1}{\\sqrt{2\\pi}\\sigma_i}\\exp(-\\frac{(x_i-\\mu_i)^2}{2\\sigma_i^2})\n\\end{aligned}ç­‰å¼å³è¾¹çš„  ä¸ºé«˜æ–¯ï¼ˆæ­£æ€ï¼‰åˆ†å¸ƒã€‚è‹¥ ï¼Œåˆ™è®¤ä¸ºå¼‚å¸¸ã€‚\nWeek 2: Recommender systemsååŒè¿‡æ»¤ä»£ä»·å‡½æ•°ï¼š\n\n\\begin{aligned}\n&\\min_{w^{(j)}b^{(j)}}J(w^{(j)},b^{(j)})\\\\\n=&\\frac{1}\n{2m^{(j)}}\\sum_{i:r(i,j)=1}(w^{(j)}\\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\\frac{\\lambda}\n{2m^{(j)}}\\sum_{k=1}^n(w_k^{(j)})^2\n\\end{aligned} è¡¨ç¤ºç”¨æˆ·  æœ‰ç»™å•†å“  è¯„åˆ†ï¼Œ ä¸ºå¯¹åº”çš„è¯„åˆ†ï¼Œ ä¸ºç”¨æˆ·  è¯„åˆ†å•†å“çš„æ•°é‡ï¼Œ ä¸ºæœ‰  ä¸ªç‰¹å¾çš„å‘é‡ã€‚\n æ˜¯å¸¸é‡ï¼Œå¯ä»¥å»æ‰ï¼š\n\n\\frac{1}\n{2}\\sum_{j=1}^{n_u}\\sum_{i:r(i,j)=1}(w^{(j)}\\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\\frac{\\lambda}\n{2}\\sum_{j=1}^{n_u}\\sum_{k=1}^n(w_k^{(j)})^2ç”¨æ¥å­¦ä¹   çš„ä»£ä»·å‡½æ•°ï¼š\n\n\\frac{1}\n{2}\\sum_{j=1}^{n_u}\\sum_{i:r(i,j)=1}(w^{(j)}\\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\\frac{\\lambda}\n{2}\\sum_{j=1}^{n_u}\\sum_{k=1}^n(w_k^{(j)})^2ç”¨æ¥å­¦ä¹   çš„ä»£ä»·å‡½æ•°ï¼š\n\n\\frac{1}\n{2}\\sum_{i=1}^{n_m}\\sum_{j:r(i,j)=1}(w^{(j)}\\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\\frac{\\lambda}\n{2}\\sum_{i=1}^{n_m}\\sum_{k=1}^n(x_k^{(i)})^2åˆå¹¶åˆ°ä¸€èµ·ï¼š\n\n\\frac{1}\n{2}\\sum_{(i,j):r(i,j)=1}(w^{(j)}\\cdot x^{(i)}+b^{(j)}-y^{(i,j)})^2+\\frac{\\lambda}\n{2}\\sum_{j=1}^{n_u}\\sum_{k=1}^n(w_k^{(j)})^2+\\frac{\\lambda}\n{2}\\sum_{i=1}^{n_m}\\sum_{k=1}^n(x_k^{(i)})^2ç”¨æ¢¯åº¦ä¸‹é™æ¥è¿­ä»£ã€‚\nå¯¹äºäºŒå…ƒåˆ†ç±»ï¼Œç±»ä¼¼é€»è¾‘å›å½’å¤„ç†å³å¯ã€‚\nåŸºäºå†…å®¹è¿‡æ»¤ç”¨æ·±åº¦å­¦ä¹ å®ç°ã€‚\nä»£ä»·å‡½æ•°ï¼š\n\n\\sum_{(i,j):r(i,j)=1}(v_u^{(j)}\\cdot v_m^{(i)}-y^{(i,j)})^2Week 3: Reinforcement learningå¼ºåŒ–å­¦ä¹ æœ‰è‹¥å¹²æ¦‚å¿µï¼ŒçŠ¶æ€ï¼Œè¡ŒåŠ¨ï¼Œå¥–åŠ±ï¼ŒæŠ˜æ‰£å› å­ï¼Œå›æŠ¥ï¼Œç­–ç•¥ï¼Œé©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹ã€‚\nçŠ¶æ€åŠ¨ä½œä»·å€¼å‡½æ•°ï¼Œ è¡¨ç¤ºåœ¨çŠ¶æ€  æ—¶ï¼Œé‡‡å–è¡ŒåŠ¨  åè¡ŒåŠ¨æœ€ä¼˜æ‰€å¾—åˆ°çš„å›æŠ¥ã€‚\nè´å°”æ›¼æ–¹ç¨‹ï¼š\n\nQ(s,a)=R(s)+\\gamma \\max_{a'} Q(s',a')å…¶ä¸­  è¡¨ç¤ºçŠ¶æ€  çš„å¥–åŠ±ï¼Œ æ˜¯çŠ¶æ€  é‡‡å–è¡ŒåŠ¨  åè½¬ç§»åˆ°çš„çŠ¶æ€ã€‚æ„Ÿè§‰å°±æ˜¯åŠ¨æ€è§„åˆ’è½¬ç§»æ–¹ç¨‹ã€‚\nå®é™…æƒ…å†µä¸­ï¼ŒçŠ¶æ€ä¸ä¸€å®šèƒ½é¡ºåˆ©è½¬ç§»ï¼Œå› æ­¤è€ƒè™‘çš„å›æŠ¥æ˜¯æœŸæœ›å›æŠ¥ï¼š\n\nQ(s,a)=R(s)+\\gamma E[\\max_{a'} Q(s',a')]","categories":["å­¦ä¹ ç¬”è®°"],"tags":["äººå·¥æ™ºèƒ½","æœºå™¨å­¦ä¹ "]},{"title":"å¼ºåŒ–å­¦ä¹ ","url":"/2023/04/28/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"åŸºæœ¬æ¦‚å¿µ\nPolicy function: \nPolicy function æ˜¯ä¸€ä¸ªæ¦‚ç‡å¯†åº¦å‡½æ•°ã€‚\n\nenvironment çš„éšæœºæ€§ï¼š\n Two Sources of Randomness:\naction: \nstate: \nReturn: \nDiscounted return: \ndiscount factor:  ï¼ˆè¶…å‚æ•°ï¼‰\n\nä»·å€¼å­¦ä¹ Action-value function: \nOptimal action-value function: \nbest action: $a^=\\mathop{\\text{argmax}}\\limits_a\\ Q^(s,a)$\nç”¨ç¥ç»ç½‘ç»œæ¥è¿‘ä¼¼ ã€‚\nTemporal Difference (TD) Learning\n\nç”¨  æ¥è¿‘ä¼¼ ã€‚ æ˜¯ç¥ç»ç½‘ç»œçš„å‚æ•°ã€‚\n\nTD target: \nLoss: \nGradient descent: \nç­–ç•¥å­¦ä¹ State-value function:\n ï¼ˆç¦»æ•£ï¼‰\n ï¼ˆè¿ç»­ï¼‰\nç”¨  æ¥è¯„ä¼° policy ã€‚\nç”¨ç­–ç•¥ç½‘ç»œ  æ¥è¿‘ä¼¼ ï¼Œ ä¸ºéœ€è¦è®­ç»ƒçš„å‚æ•°ã€‚åŒæ—¶ï¼Œã€‚\nå­¦ä¹   æ¥æœ€å¤§åŒ– ã€‚\næ›´æ–°ç­–ç•¥ï¼š\nç­–ç•¥æ¢¯åº¦ï¼š\nå½¢å¼ä¸€ï¼š\nå½¢å¼äºŒï¼š\nè®¾ ï¼Œå¾— ã€‚è¿™é‡Œç”¨è’™ç‰¹å¡æ´›è¿‘ä¼¼æ¥è®¡ç®—æœŸæœ›ï¼šéšæœºæŠ½æ ·  æ¥è®¡ç®— ï¼Œä»è€Œè¿›è¡Œæ›´æ–°ï¼Œã€‚\nActor-Critic Methods\nPolicy network (actor): \nValue network (critic): \n\næ›´æ–°  æ¥å¢å¤§ ï¼Œç›‘ç£åŸºäº value network (critic)ã€‚\næ›´æ–°  æ¥æ›´å¥½çš„ä¼°è®¡å›æŠ¥ returnã€‚\nè’™ç‰¹å¡æ´›éšæœºæŠ½æ ·ï¼Œå¯ä»¥ç”¨æ¥æ±‚ ï¼Œæ±‚å®šç§¯åˆ†ï¼Œæ±‚æœŸæœ›ã€‚\nSarsa ç®—æ³•\n\\begin{aligned}\nU_t&=R_t+\\gamma U_{t+1} \\\\\nQ_\\pi(s_t,a_t)&=\\mathbb{E}[U_t|s_t,a_t]\\\\\n&=\\mathbb{E}[R_t+\\gamma Q_\\pi(S_{t+1},A_{t+1})]\n\\end{aligned}ç›´æ¥æ±‚ä¸äº†æœŸæœ›ï¼Œæ‰€ä»¥ç”¨è’™ç‰¹å¡æ´›è¿‘ä¼¼ï¼Œç”¨è§‚æµ‹å€¼  æ¥è¿‘ä¼¼ï¼Œè¿‘ä¼¼å€¼  å³ä¸º TD target ã€‚\nç”¨ä»·å€¼ç¥ç»ç½‘ç»œ  æ¥è¿‘ä¼¼ ï¼š\nTD target: \nTD error: \nLoss: \nGradient: \nGradient descent: \nQ-Learning ç®—æ³•Q-learing ç”¨æ¥è®­ç»ƒæœ€ä¼˜åŠ¨ä½œä»·å€¼å‡½æ•° ã€‚\n\n\\begin{aligned}\nQ^*(s_t,a_t)&=\\mathbb{E}[R_t+\\gamma Q^*(S_{t+1},A_{t+1})]\\\\\n&=\\mathbb{E}[R_t+\\gamma \\max\\limits_a Q^*(S_{t+1},a)]\n\\end{aligned}ç„¶åç”¨è’™ç‰¹å¡æ´›è¿‘ä¼¼ï¼š\nTD target: \né€šè¿‡ DQN  æ¥è¿‘ä¼¼ ï¼š\nTD target: \nTD error: \nUpdate: \nMulti-Step TD Targetè€ƒè™‘å¤šä¸ªå¥–åŠ±ï¼š\n\nU_t=\\sum_{i=0}^{m-1}\\gamma^iR_{t+i}+\\gamma^mU_{t+m}å¯¹äº Sarsaï¼š\n\ny_t=\\sum_{i=0}^{m-1}\\gamma^ir_{t+i}+\\gamma^mQ_\\pi(s_{t+m},a_{t+m})å¯¹äº Q-learningï¼š\n\ny_t=\\sum_{i=0}^{m-1}\\gamma^ir_{t+i}+\\gamma^m\\max\\limits_a Q^*(s_{t+m},a)Policy Gradient with Baselineå¦‚æœ  å’Œ  ç‹¬ç«‹ï¼Œåˆ™æœ‰ï¼š\n\n\\begin{aligned}\n&\\mathbb{E}_{A \\sim \\pi}\\left[b \\cdot\\frac{\\partial \\ln\\pi(A|s;\\theta)}{\\partial \\theta}\\right] \\\\\n=&b \\cdot \\sum_a \\pi(a|s;\\theta) \\cdot \\left[\\frac{1}{\\pi(a|s;\\theta)}\\cdot\\frac{\\partial \\pi(a|s;\\theta)}{\\partial \\theta}\\right] \\\\\n=&b \\cdot \\frac{\\partial\\sum_a \\pi(a|s;\\theta)}{\\partial \\theta} \\\\\n=&b \\cdot \\frac{\\partial1}{\\partial \\theta} \\\\\n=&0\n\\end{aligned}policy gradient å¯æ”¹å†™ ä¸ºï¼š\n\n\\begin{aligned}\n\\frac{\\partial V_\\pi(s)}{\\partial \\theta}&=\\mathbb{E}_{A \\sim \\pi}\\left[\\frac{\\partial \\ln\\pi(A|s;\\theta)}{\\partial \\theta}Q_\\pi(s,A)\\right] \\\\\n&=\\mathbb{E}_{A \\sim \\pi}\\left[\\frac{\\partial \\ln\\pi(A|s;\\theta)}{\\partial \\theta}(Q_\\pi(s,A)-b)\\right] \\\\\n\\end{aligned}","categories":["å­¦ä¹ ç¬”è®°"],"tags":["äººå·¥æ™ºèƒ½","å¼ºåŒ–å­¦ä¹ "]},{"title":"å›¾ç¥ç»ç½‘ç»œ","url":"/2023/08/12/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"Thomas N. Kipf, and Max Welling. â€œSemi-Supervised Classification with Graph Convolutional Networks.â€, International Conference on Learning Representations abs/1609.02907. (2017)\n\nH^{(l+1)}=\\sigma\\left( \\tilde D^{-\\frac{1}{2}}\\tilde A \\tilde D^{-\\frac{1}{2}} H^{(l)}W^{(l)} \\right)å…¶ä¸­  ä¸ºåŠ ä¸Šè‡ªç¯çš„é‚»æ¥çŸ©é˜µï¼Œ ä¸ºå…¶å¯¹åº”çš„åº¦çŸ©é˜µï¼Œ ä¸ºæ¿€æ´»å‡½æ•°ã€‚è¿™é‡Œåˆ†åˆ«å·¦ä¹˜å’Œå³ä¹˜ä¸Š\n\nZ=f(X,A)=\\text{softmax}\\left ( \\hat A \\text{ReLU}\\left( \\hat A X W^{(0)}  \\right)W^{(1)} \\right )å…¶ä¸­ ã€‚\nSpatial-based ConvolutionNN4Gï¼ˆNeural Networks for Graphï¼‰\n\\begin{aligned}\nh_i^0&= \\overline w_0 \\cdot x_i \\\\\nh^{l+1}_i&= \\hat w _{l+1,l}\\sum_{(i,j)\\in E} h^l_j + \\overline w_1 \\cdot x_i \\\\\nX_l&=MEAN(h^l) \\\\\ny&=\\sum_{l=1}^L w_l \\cdot X_l\n\\end{aligned}DCNNï¼ˆDiffusion-Convolution Neural Networkï¼‰\n\\begin{aligned}\nh^l_i&=w^l_i MEAN(d(i,\\cdot)=l+1) \\\\ \n\n\\begin{bmatrix} h_i^k\\\\\\vdots \\\\h_i^1\\\\h_i^0\\end{bmatrix} &\\times \\text W = y_i\n\\end{aligned}å…¶ä¸­  è¡¨ç¤ºæ‰€æœ‰å’Œ  è·ç¦»ä¸º  çš„ç‚¹ã€‚\nDGCï¼ˆDiffusion Graph Convolutionï¼‰è·Ÿä¸Šä¸€ä¸ªä¸€æ ·ï¼Œåªæ˜¯æœ€åä¸æ˜¯ ï¼Œè€Œæ˜¯å…¨éƒ¨ç›¸åŠ ï¼š\n\ny_i = \\sum_{l=0}^k h_i^lMoNETï¼ˆMixture Model Networksï¼‰\n\\begin{aligned}\nu(x,y)&=\\left ( \\frac{1}{\\sqrt{\\text{deg}(x)}},\\frac{1}{\\sqrt{\\text{deg}(y)}} \\right )^\\top \\\\\nh^{l+1}_i&=\\sum_{y \\in \\mathcal N(x)}w(\\hat u_{x,y}) \\cdot h^l_y \\\\\nD_j(x)f_l&=\\sum_{y \\in \\mathcal N(x)}e^{-\\frac{1}{2}(\\tilde{\\text {u}}(x,y)-\\mu_j)^\\top\\sum_j^{-1}(\\tilde{\\text {u}}(x,y)-\\mu_j)}f_l(y)\n\\end{aligned}GraphSAGEaggregation: mean, max-pooling, or LSTM\nGATï¼ˆGraph Attention Networksï¼‰\n\\alpha_{ij}=\\frac{\\exp\\left( \\text{LeakyReLU}\\left( \\vec a ^\\top[W \\vec h_i ||W \\vec h_j ]\\right)\\right)}{\\sum_{k\\in \\mathcal N_i}\\exp\\left( \\text{LeakyReLU}\\left( \\vec a ^\\top[W \\vec h_i ||W \\vec h_k ]\\right)\\right)}GINï¼ˆGraph Isomorphism Networkï¼‰\nh^{(k)}_v=\\text{MLP}^{(k)}\\left( \\left( 1+\\epsilon^{(k)} \\right) \\cdot h^{(k-1)}_v +\\sum_{u\\in \\mathcal N(v)}h^{(k-1)}_u \\right)Spectral-based ConvolutionChebNet","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®ºæ–‡","äººå·¥æ™ºèƒ½","å›¾ç¥ç»ç½‘ç»œ"]},{"title":"æŒ‡é’ˆç½‘ç»œ","url":"/2023/09/03/%E6%8C%87%E9%92%88%E7%BD%91%E7%BB%9C/","content":"Pointer NetworksOriol Vinyals, Meire Fortunato, and Navdeep Jaitly. â€œPointer Networks.â€, Conference on Neural Information Processing Systems abs/1506.03134. (2015): 2692-2700.\n çš„è¾“å‡ºç±»åˆ«æ˜¯å›ºå®šçš„ï¼Œæ¯”å¦‚å¯¹äº  é—®é¢˜ï¼Œæ¯æ¬¡çš„è¾“å‡ºæ˜¯ä»å›ºå®šå¤§çš„è¯æ±‡è¡¨ä¸­è¾“å‡ºä¸€ä¸ªå•è¯ã€‚ä½†å¯¹äºç»„åˆä¼˜åŒ–é—®é¢˜ï¼Œæ¯”å¦‚ ï¼Œå¯¹äºä¸åŒè§„æ¨¡å¤§å°çš„é—®é¢˜ï¼Œå…¶ç‚¹æ•°  ä¸åŒï¼Œè¾“å‡ºä¸æ˜¯å›ºå®šçš„ã€‚ å°±æ˜¯ä¸ºäº†è§£å†³è¿™ç§è¾“å‡ºä¸å›ºå®šçš„é—®é¢˜ã€‚\nSequence-to-Sequence Modelé—®é¢˜æè¿°ï¼šæ¯”å¦‚å¯¹äº ï¼š\n\n\\begin{aligned}\n\\text{Input}\\ \\mathcal P&=\\{ P_1,\\dots,P_n\\} \\\\\n\\text{Output}\\ \\mathcal {C^P}&=\\{ p_1,\\dots,p_n\\} \\\\\n\\end{aligned}è¾“å…¥æ˜¯  ä¸ªç‚¹ï¼Œè¾“å‡ºæ˜¯ä¸€ä¸ªé•¿ä¸º  çš„æ’åˆ—ã€‚\n æ¨¡å‹å¯¹äºè®­ç»ƒæ•°æ® ï¼Œæ‹Ÿåˆæ¡ä»¶æ¦‚ç‡ï¼š\n\n\\begin{aligned}\np\\left(\\mathcal{C}^{\\mathcal{P}} | \\mathcal{P} ;\n\\theta\\right)&=\\prod_{i=1}^{m(\\mathcal{P})} p\\left(C_{i} | C_{1}, \\ldots,\nC_{i-1}, \\mathcal{P} ; \\theta\\right) \\\\\n\\theta^{*}&=\\underset{\\theta}{\\arg \\max } \\sum_{\\mathcal{P},\n\\mathcal{C}^{\\mathcal{P}}} \\log p\\left(\\mathcal{C}^{\\mathcal{P}} |\n\\mathcal{P} ; \\theta\\right)\n\\end{aligned}å…¶ä¸­  ä¸ºå‚æ•°ã€‚\nContent Based Input Attention å’Œ  éƒ½æ˜¯ ã€‚ å’Œ  çš„éšè—çŠ¶æ€åˆ†åˆ«å®šä¹‰ä¸º  å’Œ ã€‚ æ¨¡å‹ç¬¬  æ¬¡è¾“å‡ºä¸º ï¼Œæ³¨æ„åŠ›æœºåˆ¶é¢å¤–æ±‚å‡ºæ³¨æ„åŠ›å‘é‡ ï¼Œå°†äºŒè€…è¿æ¥åï¼Œ ä½œä¸ºéšè—çŠ¶æ€æ¥å®ç°é¢„æµ‹ã€‚ è¡¨ç¤º  å’Œ  çš„è·ç¦»ã€‚\n\n\\begin{aligned}\nu_{j}^{i} &= v^{T} \\tanh \\left(W_{1} e_{j}+W_{2}\nd_i\\right) &j \\in(1, \\ldots, n) \\\\\na_{j}^{i} &= \\operatorname{softmax}\\left(u_{j}^{i} \\right)\n&j \\in(1, \\ldots, n) \\\\\nd^\\prime_i &=\\sum_{j=1}^na^i_je_j\n\\end{aligned}Ptr-Net\n\n\\begin{aligned}\nu_{j}^{i} =& v^{T} \\tanh \\left(W_{1} e_{j}+W_{2} d_{i}\\right)\n\\quad j \\in(1, \\ldots, n) \\\\\np\\left(C_{i} | C_{1}, \\ldots, C_{i-1}, \\mathcal{P}\\right) =&\n\\operatorname{softmax}\\left(u^{i}\\right)\n\\end{aligned}ç”¨  ä½œä¸ºæŒ‡å‘è¾“å…¥å…ƒç´ çš„æŒ‡é’ˆã€‚å°†è¾“å…¥ä½œä¸ºæŸ¥æ‰¾çš„è¯å…¸ï¼Œè€Œä¸æ˜¯ç”¨äº‹å…ˆå›ºå®šçš„è¯å…¸ã€‚\nCombinatorial Optimization by Graph Pointer Networks and Hierarchical Reinforcement LearningMa Qiang, Ge Suwen, He Danyang, Thaker Darshan, and Drori Iddo. â€œCombinatorial Optimization by Graph Pointer Networks and Hierarchical  Reinforcement Learningâ€, arXiv preprint arXiv 1911.04936 (2019)\n å³ä¸ºæ‰¾åˆ°ä¸€ä¸ªæœ€ä½³æ’åˆ— ï¼Œä½¿å¾—è·¯å¾„é•¿åº¦æœ€å°ï¼š\n\n\\begin{aligned}\nL(\\sigma,X)&=\\sum_{i=1}^N||x_{\\sigma(i)}-x_{\\sigma(i+1)}||_2 \\\\\nX&=[x_1^\\top,\\dots,x_N^\\top]^\\top \\in \\mathbb R^{N\\times 2}\n\\end{aligned}Reinforcement Learning for TSPå¥–åŠ±çš„æœŸæœ›ä¸ºï¼š\n\n\\begin{aligned}\n&\\mathbb E_{(s_t,a_t) \\sim \\pi_\\theta (s_t,a_t)} \\left[ \\sum_{i=1}^N r(s_t,a_t) \\right] \\\\\n=&\\mathbb E_{\\sigma \\sim p_\\theta (\\Gamma),X \\sim \\mathcal X} \\left[ \\sum_{i=1}^N-||x_{\\sigma(i)}-x_{\\sigma(i+1)}||_2 \\right]\\\\\n=&-\\mathbb E_{\\sigma \\sim p_\\theta (\\Gamma),X \\sim \\mathcal X} \\left[ L(\\sigma,X) \\right]\n\\end{aligned} æ˜¯åŸå¸‚é›†åˆçš„ç©ºé—´ï¼Œ æ˜¯  ä¸Šæ‰€æœ‰å¯èƒ½æ’åˆ—  çš„ç©ºé—´ã€‚ æ˜¯  ä¸Šçš„åˆ†å¸ƒï¼Œç”±ç¥ç»ç½‘ç»œé¢„æµ‹ã€‚ç”¨ç­–ç•¥æ¢¯åº¦ç®—æ³•æœ€å¤§åŒ–å¥–åŠ±å‡½æ•°æ¥è®­ç»ƒã€‚\nHierarchical RL for TSPç¬¬  å±‚ä¸­ï¼ŒåŠ¨ä½œ  ç”±ç­–ç•¥  é‡‡æ ·å¾—åˆ°ã€‚ æ˜¯å‰ä¸€å±‚æä¾›çš„æ½œåœ¨å˜é‡ï¼Œè¯¥å±‚ä¸ºä¸‹ä¸€å±‚æä¾›æ½œåœ¨å˜é‡ ï¼Œå³ä¸º ã€‚\n\nHierarchical Policy Gradientç¬¬  å±‚çš„ç›®æ ‡å‡½æ•°ä¸º ã€‚ç”±  ç®—æ³•å¾—ï¼Œå…¶ç­–ç•¥æ¢¯åº¦ä¸ºï¼š\n\n\\begin{aligned}\n\\nabla_{\\theta_k}J(\\theta_k)&=\\frac{1}{B}\\sum_{i=1}^B\\left[ \\left( \\sum_{t=1}^N r_k(s_{i,t}^{(k)},a_{i,t}^{(k)})-b_{i,k} \\right) \\left( \\sum_{t=1}^N \\nabla_{\\theta_k}\\log \\pi_{\\theta_k}(a_{i,t}^{(k)}|s_{i,t}^{(k)},h_{i,t}^{(k)}) \\right) \\right] \\\\\nb_{i,k}&=\\sum_{t=1}^N\\left( r_k(\\tilde s_{i,t}^{(k)},\\tilde a_{i,t}^{(k)}) \\right)+\\left[  \\frac{1}{B}\\sum_{t=1}^N \\sum_{j=1}^B r_k(s_{j,t}^{(k)},a_{j,t}^{(k)})-r_k(\\tilde s_{j,t}^{(k)},\\tilde a_{j,t}^{(k)})  \\right]\n\\end{aligned}å…¶ä¸­  ä¸ºæ‰¹é‡å¤§å°ï¼Œ ä¸ºç¬¬  å±‚çš„ ã€‚ç”¨æ¢¯åº¦ä¸‹é™æ¥æ›´æ–°å‚æ•° ã€‚åŠ¨ä½œ  æ˜¯ç”¨è´ªå¿ƒé‡‡æ ·å¾—åˆ°ã€‚\nå¯¹äºè¿™ä¸ª  å±‚çš„åˆ†å±‚ç­–ç•¥ ï¼Œæ¯ä¸ªç­–ç•¥ç”¨ä¸€ä¸ª  è¡¨ç¤ºã€‚\nGPN ArchitectureEncoder\nåŒ…å«ä¸¤éƒ¨åˆ†ï¼Œ å’Œ ã€‚\n å°†èŠ‚ç‚¹  æ˜ å°„åˆ°  ç»´å‘é‡ ï¼Œå¹¶ä¸”æ‰€æœ‰èŠ‚ç‚¹å…±äº«æ˜ å°„å˜æ¢çš„å‚æ•°ï¼Œç„¶åé€šè¿‡  è¿›ä¸€æ­¥ç¼–ç å¾—åˆ°éšè—å˜é‡ ï¼Œ ä¼šä¼ é€’ç»™  å’Œä¸‹ä¸€æ—¶åˆ»çš„ ã€‚\n å¯¹  è¿›è¡Œç¼–ç åè¾“å…¥åˆ°  é‡Œã€‚\n\nGraph Embedding Layer\n çš„æ¯ä¸€å±‚ä¸ºï¼š\n\nx_i^l=\\gamma x_i^{l-1}\\Theta +(1-\\gamma)\\phi_\\theta\\left( \\frac{1}{|\\mathcal N(i)|} \\left\\{ x_j^{l-1} \\right\\}_{j\\in \\mathcal N(i) \\cup \\{ i \\}} \\right) æ˜¯ä¸€ä¸ªå¯è®­ç»ƒçš„å‚æ•°ï¼Œç”¨æ¥æ­£åˆ™åŒ–æƒé‡çŸ©é˜µçš„ç‰¹å¾å€¼ï¼Œ æ˜¯å¯è®­ç»ƒçš„æƒé‡çŸ©é˜µï¼Œ æ˜¯èšåˆå‡½æ•°ï¼Œç”¨ç¥ç»ç½‘ç»œæ¥æ‹Ÿåˆã€‚\n è€ƒè™‘çš„æ˜¯å®Œå…¨å›¾ï¼Œå°†æ¯ä¸€å±‚å†™æˆçŸ©é˜µçš„å½¢å¼ä¸ºï¼š\n\nX^l=\\gamma X^{l-1}\\Theta+(1-\\gamma)\\Phi_\\theta \\left( X^{l-1}/|\\mathcal N(i)| \\right)å…·ä½“å®éªŒä¸­ä½¿ç”¨çš„èšåˆå‡½æ•°æ˜¯å•å±‚çš„å…¨è¿æ¥ç¥ç»ç½‘ç»œï¼Œå›¾åµŒå…¥å±‚å³ä¸ºï¼š\n\nX^l=\\gamma X^{l-1}\\Theta+(1-\\gamma)\\text{ReLU} \\left( X^{l-1}/|\\mathcal N(i)| +b \\right)Vector Context\nä¸€èˆ¬çš„  éƒ½æ˜¯ç”¨åŸå¸‚çš„äºŒç»´åæ ‡ï¼Œå³ ï¼Œä½†è¿™ç¯‡æ–‡ç« ç”¨çš„æ˜¯ä¸€ä¸ªåŸå¸‚æŒ‡å‘å…¶ä»–åŸå¸‚çš„å‘é‡ï¼Œç§°ä¸º ã€‚\nè®¾ ï¼Œ ä¸º ã€‚å›¾åµŒå…¥å±‚å°±æ”¹ä¸ºï¼š\n\n\\bar X^l=\\gamma \\bar X^{l-1}\\Theta+(1-\\gamma)\\Phi_\\theta \\left( \\bar X^{l-1}/|\\mathcal N(i)| \\right)Decoder\n ç”ŸæˆæŒ‡é’ˆå‘é‡ ï¼Œå®šä¹‰ä¸ºï¼š\n\n\\begin{aligned}\nu_i^{(j)}&=\n\\begin{cases}\nv^\\top \\cdot \\tanh(W_r r_j + W_q q) &\\text{if}\\ j \\not = \\sigma(k),\\forall k","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®ºæ–‡","ML4CO","äººå·¥æ™ºèƒ½"]},{"title":"æ—¥è®° 2023.5","url":"/2023/05/05/%E6%97%A5%E8%AE%B0%202023.5/","content":"5.1å¥èº«ï¼Œåƒç§€ç‰ã€‚\nçœ‹é©¬é‡Œå¥¥å¤§ç”µå½±ï¼Œç¢§å§¬å…¬ä¸»å¾ˆå¸…ï¼ï¼è“é¾Ÿå£³ï¼Œé©¬é‡Œå¥¥èµ›è½¦ï¼Œâ€œçŒ«å¯¹æŠ—å¼ºâ€ï¼Œâ€œäººæ‹¿åˆ°æ— æ•Œæ˜Ÿå°±ä¼šæœ¬èƒ½çš„å†²â€ï¼Œè¦ç´ æŒºå¤šã€‚æƒ³èµ·è‡ªå·±é«˜äºŒé«˜ä¸‰å¤©å¤©çœ‹è¶…çº§å°æ¡€çš„é©¬é€ è§†é¢‘ï¼Œæ„Ÿè§‰è‡ªå·±è¿˜æ˜¯æ‡‚ç‚¹é©¬é‡Œå¥¥çš„ã€‚\n5.2å¥èº«ï¼Œå’Œ wyk åƒä¹è½®ï¼Œä½“éªŒæŒºå¥½ã€‚\n5.4ç¬¬ä¸€æ¬¡åšä¹‰å·¥ï¼Œç›Šè·¯åä¸­å¤§ï¼ŒæŠŠéæœºåŠ¨è½¦èµ¶åˆ°éæœºåŠ¨è½¦é“ä¸Šã€‚å¥½å‡ ä¸ªåŒå­¦ä¸€å¼€å§‹æ²¡æ˜ç™½æˆ‘å‘éæœºåŠ¨è½¦é“æŒ¥æ——å­çš„æ„æ€ï¼Œéª‘è¿‡å»åæ‰æ˜ç™½ï¼Œç„¶åå“ˆå“ˆç¬‘ï¼Œæ„Ÿè§‰æŒºæœ‰æ„æ€ã€‚åŒå­¦ä»¬ä¹Ÿéƒ½å¾ˆé…åˆï¼Œâ€œOKâ€ï¼Œå¾®ç¬‘ï¼Œç«–å¤§æ‹‡æŒ‡ã€‚\nyz æŠŠç…§ç‰‡ç›’å‡ºæ¥äº†ï¼ŒğŸ¦ã€‚\n5.5ğŸ˜¥ è¿™æ®µæ—¶é—´æˆ‘å¥½æ‘†å•Šï¼Œæ•ˆç‡å¥½ä½ï¼Œå¾—å¤šæ³¨æ„äº†ã€‚\n5.6ğŸ˜° ä¾æ—§æ‘†ï¼Œæ—©ä¸Šä¹ç‚¹å››åèµ·ï¼Œç›´æ¥ç¡è¿‡å¾®ç§¯åˆ†ï¼Œä¸‹åˆåˆç¡ä¸€ä¸‹åˆï¼Œæ™šä¸Šå¤šå­¦ä¼šå„¿å§ã€‚\n5.7ä¸­åˆç­çº§ä¸œæ¹–çƒ§çƒ¤å›¢å»ºï¼Œæ„Ÿè§‰åŠçš„æŒºæˆåŠŸçš„ã€‚çƒ§çƒ¤åƒçš„æŒºå¼€å¿ƒï¼Œæ¡Œæ¸¸ä¹Ÿæœ‰ä¸¤ä¸‰æ¡Œï¼Œå¸Œæœ›å¤§å®¶åƒçš„çƒ¤ä¸²éƒ½æ˜¯ç†Ÿçš„ ğŸ™ï¼Œä¹Ÿåˆ«å¤ªç†Ÿæˆé»‘ç‚­ã€‚\nè›‹ç™½ç²‰åˆ°äº†ï¼Œæˆ‘è¦å¤§æˆ‘è¦å¤§æˆ‘è¦å¤§ ğŸ¤¤ã€‚å–èµ·æ¥æ²¡å•¥å‘³å„¿ï¼Œé¥±è…¹æ„ŸæŒºå¼ºã€‚\næ™šä¸Šå»çœ‹é“¶æ²³æŠ¤å«é˜Ÿ 3ï¼Œå¥½çœ‹ï¼æ¯ä¸ªè§’è‰²æœ€åéƒ½æœ‰è‡ªå·±çš„å½’é€”ã€‚ç«ç®­çš„æ•…äº‹å¾ˆé¥±æ»¡ï¼Œè‡³é«˜è¿›åŒ–å’Œä»–åˆ›é€ çš„ååœ°çƒçš„è®¾å®šéƒ½æŒºæœ‰æ„æ€ã€‚ååœ°çƒâ€”â€”ç¦ç‘æ§å¤©å ‚ã€‚\n5.8ä¸‹åˆå®Œæˆäº†å…¬é€‰è¯¾ä½œä¸šï¼Œé‡‡è®¿äº†å¤§èåœã€‚èåœæ¯”æˆ‘ä»¬é¢„æœŸçš„èƒ½è¯´ï¼Œé—®ä¸€ä¸ªé—®é¢˜ï¼Œç›´æ¥æŠŠæˆ‘ä»¬æ¥ä¸‹æ¥è¦é—®çš„é—®é¢˜ä¹Ÿç»™å›ç­”äº†ã€‚æœ€ååˆä»–è°ˆåˆ°äº†å·ï¼Œâ€œä¸æ˜¯é€¼ç€ä½ ä»¬å·ï¼Œä½†å¤§ä¸€è¿˜æ˜¯è¦åŠªåŠªåŠ›ï¼Œä¸è¦ä¸¢äº†é‚£è‚¡åŠ²å„¿ï¼Œä¸ç„¶ä»¥åæ‰¾éƒ½æ‰¾ä¸å›æ¥â€ã€‚\n5.9ä¸Šåˆæ‰¾ hk é¢è°ˆï¼Œçº¦äº†å¥½å‡ æ¬¡ï¼Œç»ˆäºçº¦ä¸Šäº†ã€‚ç»™å¥¹è®²äº†è®²æˆ‘è¿™æ®µæ—¶é—´çœ‹çš„è®ºæ–‡ï¼Œè¯´äº†å››ååˆ†é’Ÿã€‚æˆ‘ä¸€ç›´ä»¥ä¸ºä¹‹åæ˜¯æ‰¾ä¸ªå­¦é•¿å¸¦æˆ‘ï¼Œä½†ä»Šå¤©äº¤æµå®Œï¼Œæˆ‘æ‰çŸ¥é“è€å¸ˆå¯¹æˆ‘çš„æœŸæœ›æ˜¯ä¸»è¦æˆ‘è‡ªå·±æ¥åšï¼Œè€å¸ˆå’Œå­¦é•¿æä¾›å¸®åŠ©ã€‚è¿™ä¸‹ç›´æ¥å¹»æƒ³æ—¶é—´äº† ğŸ¤¤ï¼Œä¸è¿‡å·¥ä½œé‡ä¹ŸæŒºå¤šï¼Œæœ¬æ¥ä»¥ä¸ºè¿™æ¬¡è°ˆå®Œåï¼Œåˆ°æš‘å‡å‰è¿™è¾¹å°±æ²¡å•¥äº‹äº†ï¼Œè¿™ä¸‹ç›´æ¥äº‹å„¿æ›´å¤šäº† ğŸ˜¨ã€‚\n5.11å»â€œæ¢¦ç³»çº¢æ¥¼â€éŸ³ä¹ä¼šå½“å¿—æ„¿è€…ï¼Œé‚£å¥â€œå¤©å°½å¤´ï¼Œä½•å¤„æœ‰é¦™ä¸˜â€å¾ˆéœ‡æ’¼ï¼Œæœ€åæˆ‘ä»¬å¿—æ„¿è€…è¿˜è·Ÿå´ç¢§éœè€å¸ˆä¸€èµ·åˆç…§äº†ã€‚\n5.12è¿™æ¬¡æ—¶æœºæ¯”è¾ƒå·§ã€‚\n5.15å¬äº†å®‰å…¨æ•™è‚²æŠ¥å‘Šï¼Œæ„Ÿè§‰å›½å†…ç®¡ç† AIGC ç¡®å®å¾ˆéš¾ï¼Œå¸Œæœ›é€æ­¥å®Œå–„å§ã€‚\n5.18ç›–äºšè¿‡ç”Ÿæ—¥ï¼Œåƒäº†ä¸œåŒ—ä¹±ç‚–ï¼Œå¥½åƒ ğŸ˜‹ã€‚\né€¼å®«å¤§æˆåŠŸã€‚\nğŸ˜­ ä½†æˆ‘å¤§å¤±è´¥ã€‚\n5.19å»çœ‹å®¤å‹å”±æ­Œï¼Œé›†æˆåå¤§æ­Œæ‰‹ã€‚å† å†›å”±çš„æå¥çš„æ­Œï¼Œå·¨ç‰›ã€‚\nğŸ˜¥ ç„¶ååˆå¤±è´¥ã€‚\n5.22äº‹å„¿å¥½å¤šï¼Œhk é‚£è¾¹ä¹Ÿå¼€å§‹å‚¬ç»„ä¼šäº†ã€‚æ˜¯çœŸæ²¡ idea å•Šï¼Œå„ç§æ„ä¹‰ä¸Šã€‚\næ„Ÿè§‰å¤ªå†…è€—äº†ï¼Œè¿˜æ˜¯å¼ƒäº†å§ ğŸ˜ã€‚\n5.23è¯­æ–‡ç»“è¯¾äº†ï¼Œå†™å°ä½œæ–‡ï¼Œâ€œæˆ‘çš„é˜…è¯»å°å²â€ï¼Œä¸Šå­¦æœŸè¿˜æ˜¯è¯»äº†æŒºå¤šå°è¯´çš„ï¼Œæœ‰ä¸œè¥¿å†™ã€‚\n5.24è€ƒè‹±è¯­å£è¯­ï¼Œæˆ‘ä»¬ç»„æœ€åä¸€ä¸ªï¼Œå…¨ç­éƒ½èµ°äº†æˆ‘ä»¬æ‰ä¸Š ğŸ˜­ã€‚\n5.25è€ƒç¦»æ•£ï¼Œæ„Ÿè§‰å¤ä¹ æ—¶é—´å¤šäº†ï¼Œæ²¡å¿…è¦æˆ˜çº¿æ‹‰è¿™ä¹ˆé•¿ï¼Œè€ƒçš„è¿˜æ˜¯åç®€å•çš„ï¼Œè™½ç„¶åˆ†åº”è¯¥ä¸æ€ä¹ˆé«˜å§ ğŸ˜•ã€‚\n5.26æ ¹å„¿è¿‡ç”Ÿæ—¥ã€‚ç„¶åæ™šä¸Šç»™é«˜ä¸­ä»–ä»¬è®²è¯¾ï¼Œä¸ƒç‚¹åˆ°åç‚¹åŠï¼Œè®²äº†ä¸‰ä¸ªåŠå°æ—¶ã€‚æ²¡æƒ³åˆ°è®²è¿™ä¹ˆé•¿æ—¶é—´ï¼Œå¹¶ä¸”è¿˜æ˜¯çº¿ä¸Šï¼Œä½†åŒå­¦ä»¬è¿˜æ˜¯æŒºç§¯æçš„ã€‚\n5.28å»åƒèµ¤ç‰§ï¼Œä½“éªŒæŒºå¥½ã€‚ç¬¬ä¸€æ¬¡åè½®æ¸¡ï¼Œå¹é£æŒºèˆ’æœï¼Œç„¶åå»æ±Ÿæ»©ï¼Œç»§ç»­å¹é£ã€‚\nğŸ¤¤ğŸ¤¤\n5.30è®¤è¯†äº† ğŸŒ‹ï¼Œæ—©ä¸Šç®€å•èŠäº†èŠï¼Œä¸‹åˆä¸€èµ·è‡ªä¹ ï¼Œå¥¹æŒºæœ‰æ„æ€çš„ï¼Œä¹Ÿå¾ˆæœ‰è‡ªå·±çš„æƒ³æ³•ï¼Œå¹¶ä¸”ç¤¾äº¤å±æ€§å¾ˆå¼ºã€‚å¥¹åŠ å…¥äº†å†°å²©ï¼ŒçŒ›çŒ›å­¦å‰ç«¯ï¼Œæƒ³æ HCIï¼Œæ¯”å£å£å¤§éƒ¨åˆ†åªæ‡‚å·åŠ æƒçš„äººå¼ºã€‚BBHust é‡Œå…¨æ˜¯å¥¹çš„å¸–å­ï¼Œä»€ä¹ˆä¸ªäººåšå®¢ã€‚\n","categories":["ç”Ÿæ´»"],"tags":["æ—¥è®°"]},{"title":"æ—¥è®° 2023.6","url":"/2023/06/02/%E6%97%A5%E8%AE%B0%202023.6/","content":"6.1å›¾ä¹¦é¦†æ¥¼ä¸‹æœ‰å…­ä¸€æ´»åŠ¨ï¼Œç»™å°æœ‹å‹å†™å›ä¿¡ï¼Œå°å­¦ç”Ÿçš„æƒ³æ³•å¾ˆæœ‰è¶£ï¼Œå¾ˆç«¥çœŸã€‚\nğŸ˜° å›¾ä¹¦é¦†ç”µæ¢¯é‡Œç¢°è§äº† __ï¼Œè¿˜å¥½äººå®¶æ²¡è®¤å‡ºæ¥æˆ‘ï¼Œä¸ç„¶æœ‰ç‚¹å°´å°¬ã€‚\næ–°é¦†å››æ¥¼çœ‹è§æœ¬ä¹¦ï¼Œã€Šæ²¡æœ‰ç”·æœ‹å‹åˆæ€æ ·ã€‹â€”â€”å±±å†…éº»é‡Œå­ï¼Œæ„Ÿè§‰æŒºæœ‰æ„æ€ã€‚\n6.2ç½‘æ ¼å‘˜åˆ¶åº¦æœ‰ç‚¹é€†å¤©ã€‚\n6.3çœ‹å¤©ç©ºä¹‹åŸï¼Œç„¶åâ€¦â€¦\nğŸ¥º å‘œå‘œå‘œï¼Œæˆ‘æ²¡äº†ã€‚\nğŸ˜° ä¸€ç‚¹åŠåˆ°å¿«å››ç‚¹ã€‚\né—®æ˜¯ ________ï¼Œè¿˜æ˜¯ ___ï¼Œå¾—åˆ°çš„ç­”æ¡ˆæ˜¯â€œä¸çŸ¥é“â€ï¼Œä½†æˆ‘ä¹Ÿä¸çŸ¥é“å•Šã€‚\n6.4æˆ‘ä»¥ä¸ºå¾ˆç¨³çš„ã€‚\n6.5æˆ‘è¶…ï¼ŒğŸ•· èœ˜è››ä¾ çœŸå¥½çœ‹ï¼Œæœªå®Œå¾…ç»­çœŸ **ï¼Œå¯¼è‡´äº†ä¸€äº›é¬¼å«ã€‚\n6.6å»è®²äº†æ•°æ®ç»“æ„ï¼Œæ„Ÿè§‰æŒºæˆåŠŸï¼Œä½†æ¥çš„äººæ¯”æˆ‘é¢„æœŸçš„å°‘ã€‚ç„¶åå’Œå¤§ä¼™å»åƒå·èœï¼Œå¾ˆæ­£å®—ï¼Œè€æ¿éƒ½æ˜¯å››å·äººï¼Œä½†ç¡®å®è¾£ ğŸ¥µã€‚\nåœ¨ä¸€èµ·äº†ã€‚\n6.7ç²‰è£™å­æœ‰ç‚¹åƒå°ç¾½æ¯›çƒï¼Œæœ‰ç‚¹å˜‰ç„¶å­•å¦‡è£…çš„æ„Ÿè§‰ã€‚\n6.9é€†å¤© lhwï¼Œâ€œå“ˆå–½å«‚å­ğŸ˜â€ã€‚\n6.10æ™šä¸Šå‘Šè¯‰ yz ä»–ä»¬äº†ï¼Œè¯´å»åƒå¤œå®µï¼Œé€›äº†åŠå¤©ï¼Œå‘ç°æµ·åº•æäººå·¨å¤šï¼Œæœ€åä¸€äººä¸€ç¬¼å°ç¬¼åŒ…ã€‚\n6.11è€ƒå®Œè¿‘ä»£å²äº†ï¼Œå¥¹ä¹Ÿè€ƒå®Œç»†ç”Ÿäº†ï¼Œå‡ºå»ç©ï¼Œå®˜å®£äº†ã€‚\n6.14ç¢°è§äº† dcn æ‹”è‰ã€‚å¸® xjr ä¸Šè¯¾ï¼Œå¥¹ç¡å¤§è§‰ã€‚å¥¹ç¡ä¸€ä¸‹åˆï¼Œå®Œå…¨å¤±è”ï¼Œâ€œğŸ˜­ xjr åˆ«ä¼¼å•Šâ€ã€‚\næˆ‘ä»¬ä¿©ç¢°è§äº† zhyï¼Œå¥¹ç›´æ¥â€œå«‚å­å¥½ï¼â€ã€‚\n6.16é€†å¤©å•Šï¼Œä¿ç ”ç¾¤èŠäº†ä¸€ä¸‹åˆæˆ‘ï¼ŒçœŸå­—é¢æ„æ€ã€‚ä¸€å¸®äººåŒ¿åè®¨è®ºâ€œåˆ˜é˜Ÿâ€ã€‚\n6.17èåœè¯´äº†è¯´ä¸‹ä¸€å±Šçš„å›¾è®ºç­ï¼Œè¿˜è¯´åŠ æƒæ²¡æœ‰ ï¼… çš„åŒå­¦ä¸è®©è¿›èåœç­ ğŸ˜¨ã€‚\n6.18ğŸ˜‹ xjr æ€’éª‚ yzï¼Œæ¥ç‚¹æ”»å‡»æ€§éœ‡æ’¼ã€‚\nå·¨å¤§é›¨ï¼Œæˆ‘åœ¨ç´«è˜æ¸¡æ±Ÿï¼Œæ°´æ²¡åˆ°è†ç›– ğŸ˜°ã€‚è€³æœºç›’ä¸è§äº† ğŸ˜¢ã€‚\n6.19è€ƒå¾®ç§¯åˆ†ï¼Œæ„Ÿè§‰è¿˜å¥½ã€‚è€³æœºç›’æ‰¾åˆ°äº† ğŸ˜‹ã€‚\n6.21å¤§ç‰©è€ƒçš„è¡€å´©ï¼Œå¸Œæœ›æˆç»©ä¸è¦  å¼€å¤´ ğŸ˜­ã€‚\n6.22å»è¹­å…‰ç”µè¯·æå¼€ä¸è€å¸ˆè®²çš„æ¦‚ç‡è®ºï¼Œä»–è®²çš„ç¡®å®å¥½ ğŸ‘ã€‚\n6.24ğŸ˜­ æˆ‘æ™šä¸Šå¤‡è€ƒç¬¬äºŒå¤©çš„æ¦‚ç‡è®ºï¼Œå¥¹æ™šä¸Šå» club çœ‹è¡¨æ¼”ã€‚\n6.25æ•™ xjr éª‘ ğŸš²ï¼Œå­¦æŒºå¥½ï¼\n6.26æ¬å¯å®¤ç¬¬ä¸€æ³¢ï¼Œåœ¨éŸµè‹‘å„ä¸ªå¯å®¤æ¥å›è·‘ï¼Œé€›äº†ä¸ªéã€‚\nå‡ºå»ç©ï¼Œçœ‹äº†æ¶ˆå¤±çš„å¥¹ï¼Œæˆ‘ä»¬ä¿©ä¸€è‡´è®¤ä¸ºååŠæ®µå¾ˆæ€ªï¼Œå¥¹ä¸¥å‰æ‰¹è¯„äº†å½©è›‹ã€‚\n6.27åƒä¸€ç»ªï¼Œçˆ½å–æ—ºä»”ç‰›å¥¶ï¼\n6.28æ¬å¯å®¤ç¬¬äºŒæ³¢ï¼Œå›æ¥å§ç´«è˜åæ ‹ ğŸ˜­ã€‚\n6.29å»äº†çŒ«å’– ğŸ±ï¼ŒçŒ«çŒ«å¯çˆ±æã€‚\n6.30æ”¶åˆ°äº†å¦‚å¦‚çš„æŸ“å¡å’Œæ‰‹å†™ä¿¡ ğŸ¥°ã€‚\n","categories":["ç”Ÿæ´»"],"tags":["æ—¥è®°"]},{"title":"æ—¥è®° 2023.7","url":"/2023/07/12/%E6%97%A5%E8%AE%B0%202023.7/","content":"7.1å»é€›äº†æ¹–åŒ—çœç¾æœ¯é¦†ï¼Œæ„Ÿå—äº†è‰ºæœ¯ï¼Œä½†å°å­©å„¿å¥½å¤šå•Šï¼Œæˆ‘ä»¬ä¿©é€›çš„éƒ½æŒºç´¯ã€‚\n7.4ç»™å¦‚å¦‚é€äº†ç¢å†°è“ ğŸŒ¹ã€‚\n7.5é€å¥¹å»ç«è½¦ç«™ã€‚æ•´ç†äº†ä¸€ä¸‹å¥¹ç»™æˆ‘çš„é›¶é£Ÿï¼Œå‘ç°æœ‰å¥½å¤šå•Šã€‚\nç»“æœåæ¥å‘ç°é›¶é£Ÿè¦ä¹ˆæ˜¯ä¸´æœŸçš„ï¼Œè¦ä¹ˆæ˜¯è¿‡æœŸçš„ï¼Œæˆ‘è¿˜åƒäº†ä¸€äº›è¿‡æœŸçš„é›¶é£Ÿ ğŸ˜°ã€‚\n7.11å’Œ jdk å»æ‰“èˆèŒç¢°è§äº† lgã€‚\nçˆ½è·‘ä¸‰å…¬é‡Œã€‚\n7.13çˆ½è·‘äº”å…¬é‡Œã€‚\n","categories":["ç”Ÿæ´»"],"tags":["æ—¥è®°"]},{"title":"ç«¯åˆ°ç«¯ç»„åˆä¼˜åŒ–","url":"/2023/09/03/%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/","content":"Memory-efficient Transformer-based network model for TravelingSalesman ProblemHua Yang, Minghao Zhao, Lei Yuan, Yang Yu, Zhenhua Li, and Ming Gu. â€œMemory-efficient Transformer-based network model for Traveling Salesman Problem.â€, Neural Networks 161 (2023): 589-597.\n æ¨¡å‹åœ¨è§£å†³  ä¸­å­˜åœ¨å±€é™æ€§ï¼š\nè®¡ç®—å¤æ‚åº¦æ˜¯äºŒæ¬¡çš„ï¼Œ ä¸­çš„æ“ä½œå¯¼è‡´æ—¶é—´å’Œç©ºé—´çš„å¤æ‚åº¦ä¸º ã€‚ï¼ˆ æ˜¯è¾“å…¥åºåˆ—çš„é•¿åº¦ï¼‰\nå†…å­˜éœ€æ±‚è¿‡é«˜ï¼Œå¯¼è‡´å†…å­˜ä¸è¶³ã€‚\nå¼ºåŒ–å­¦ä¹ ä¸­é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹çš„å˜é‡ä¸ºï¼šçŠ¶æ€ï¼Œ ä¸ºå½“å‰å·²è®¿é—®çš„èŠ‚ç‚¹çš„æœ‰åºåºåˆ—ã€‚åŠ¨ä½œï¼Œ ä¸ºä¸‹ä¸€ä¸ªè®¿é—®çš„èŠ‚ç‚¹ã€‚å¥–åŠ±ï¼Œã€‚è½¬ç§»ï¼Œä»å½“å‰ä¸ºè®¿é—®è¿‡çš„èŠ‚ç‚¹é›†åˆä¸­é€‰æ‹©ä¸€ä¸ªç‚¹ï¼ŒåŠ å…¥åˆ°å·²è®¿é—®çš„èŠ‚ç‚¹é›†åˆä¸­ã€‚ç­–ç•¥ï¼Œ ä¸ºä¸€ä¸ªç¥ç»ç½‘ç»œï¼Œ æ˜¯ç½‘ç»œçš„å¯è®­ç»ƒæƒå€¼ã€‚\n\np_\\theta (\\pi | s)=\\prod_{i=1}^n p_\\theta (\\pi_i|\\pi_{1 \\dots i-1}, s)Tspformer architecture\n ä¸­çš„  è¢«å®šä¹‰ä¸ºï¼š\n\n\\begin{aligned}\n&MultiHeadAttention(Q,K,V) \\\\\n=&Concat(Head_1,Head_2,\\dots,Head_h)W^o\n\\end{aligned}ï¼Œ æ˜¯åºåˆ—é•¿åº¦ï¼Œ æ˜¯å¤´çš„ä¸ªæ•°ï¼Œ æ˜¯åµŒå…¥ç»´åº¦ã€‚ï¼ˆå®éªŒä¸­ ï¼‰\nå…¶ä¸­ä¸»è¦çš„æ³¨æ„åŠ›æ¥è‡ªäºç‚¹ç§¯å€¼ï¼Œå¯ä»¥å¯¹æŸ¥è¯¢æ•°æ®è¿›è¡Œé‡‡æ ·ï¼Œä»è€Œä½¿å¾—çŸ©é˜µä¹˜æ³•è¿ç®—çš„æ•°æ®å‡å°‘ã€‚\né‡‡æ ·  çš„ä¸ªæ•°ä¸º ï¼Œ æ˜¯ä¸€ä¸ªå¾®è°ƒå‚æ•°ï¼Œã€‚é‡‡æ ·  è¡¨ç¤ºä¸º ã€‚\nç”¨çŸ©é˜µä¹˜æ³•æ¥æ±‚  å’Œ  çš„å…¼å®¹æ€§ï¼š\n\nQ\\_E=MatMul(W^QQ,W^{K_{sample}}K_{sample}) å–æ¦‚ç‡æœ€é«˜çš„å‰  ä¸ªå€¼ä¸º ï¼Œå³ä¸ºå€¼æœ€å¤§çš„å‰  ä¸ªå€¼ã€‚ç„¶åæ ¹æ®  å¯¹æ•°æ®æŸ¥è¯¢è¿›è¡Œé‡‡æ ·ï¼Œå¾—åˆ° ã€‚\nå†æ¬¡è®¡ç®—  å’Œ  çš„å…¼å®¹æ€§ï¼š\n\nQ\\_Reduce=MatMul(W^{Q_{red}}Q_{red},W^{K}K)å±è”½è®¿é—®è¿‡çš„èŠ‚ç‚¹åï¼Œè®¡ç®—æ³¨æ„åŠ›å€¼ï¼š\n\n\\begin{aligned}\nHead_i&=AttSampled(Q_{red}W_i^{Q_{red}},KW^K_i,VW^V_i) \\\\\n&=softmax\\left( \\frac{Q_{red}W_i^{Q_{red}}(KW_i^K)^T}{\\sqrt{d_k}} \\right)VW_i^V\n\\end{aligned}è¿™é‡Œ  éƒ½æ˜¯å¯å­¦ä¹ çš„çŸ©é˜µã€‚è¿™é‡Œå‡å®šçº¿æ€§æŠ•å½±çš„éšè—ç»´åº¦éƒ½ä¸€æ ·å¤§ï¼Œã€‚ï¼ˆå®éªŒä¸­ ï¼‰\n\nEncoder  çš„  å’Œ  çš„  çš„åŒºåˆ«åªæœ‰å°†  æ¢ä¸ºäº† ã€‚\nDecoder  çš„  å»æ‰äº†  çš„  ä¸­çš„ç¬¬ä¸€ä¸ªç»„ä»¶ï¼Œå³ ã€‚ç”¨è‡ªå›å½’æ¥æ¯ä¸€æ¬¡é¢„æµ‹èŠ‚ç‚¹ï¼Œç”¨è´ªå©ªæœç´¢å’ŒæŸæœç´¢æ¥æ”¹å–„è§£ç©ºé—´ã€‚\nModel training with reinforcement learningæŸå¤±å‡½æ•°ï¼š\n\nC(\\theta|s)=\\mathbb E_{p_\\theta (\\pi | s)}L(\\pi|s)ç”¨éšæœºæ¢¯åº¦ä¸‹é™å’Œç­–ç•¥æ¢¯åº¦æ–¹æ³•æ¥ä¼˜åŒ–å‚æ•°ï¼Œç”¨  ç®—æ³•æ¥è®¡ç®—æ¢¯åº¦çš„æ›´æ–°ï¼š\n\n\\nabla_\\theta C(\\theta|s)=\\mathbb E_{p_\\theta (\\pi| s)}[(L(\\pi|s)-b(s))\\nabla_\\theta \\log p_\\theta (\\pi|s )]ç”¨è´ªå©ªç®—æ³•æ¥ä½œä¸º ã€‚\nä¸ºäº†æ„é€   å’Œå•æ¬¡é‡‡æ ·ï¼Œç”¨è’™ç‰¹å¡æ´›æŠ½æ ·æ¥é‡‡æ · ï¼š\n\n\\nabla_\\theta C(\\theta)=\\frac{1}{B}\\sum_{i=1}^B(L(\\pi_i|s_i)-b(s_i))\\nabla_\\theta \\log p_\\theta (\\pi_i|s_i )Learning to Iteratively Solve Routing Problems with Dual-Aspect Collaborative TransformerYining Ma, Jingwen Li, Zhiguang Cao, Wen Song, Le Zhang, Zhenghua Chen, and Jing Tang. â€œLearning to Iteratively Solve Routing Problems with Dual-Aspect Collaborative Transformer.â€, Conference on Neural Information Processing Systems abs/2110.02544 (2021): 11096-11107.\n","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®ºæ–‡","ML4CO","äººå·¥æ™ºèƒ½"]},{"title":"ç¬¬ 29 æ¬¡ CCF è®¡ç®—æœºè½¯ä»¶èƒ½åŠ›è®¤è¯","url":"/2023/03/30/%E7%AC%AC%2029%20%E6%AC%A1%20CCF%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E8%83%BD%E5%8A%9B%E8%AE%A4%E8%AF%81/","content":"T1 100:\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,x,y,ans;int main(){    read(n),read(x),read(y);    for(int i=1;i&lt;=n;++i)    {        ll a,b,c,d;        read(a),read(b),read(c),read(d);        a=max(a,(ll)0);        b=max(b,(ll)0);        c=max(c,(ll)0);        d=max(d,(ll)0);        a=min(a,x);        c=min(c,x);        b=min(b,y);        d=min(d,y);        ans+=(c-a)*(d-b);    }    cout&lt;&lt;ans;    return 0;}\nT2 100:\n#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,k,ans,l,r;ll t[maxn],c[maxn];bool check(ll x){\tll res=m;    for(int i=1;i&lt;=n;++i)    {        ll v=t[i]-x;        if(v&lt;=0) continue;        res-=v*c[i];        if(res&lt;0) return false;    }    return true;}int main(){    read(n),read(m),read(k),l=k;    for(int i=1;i&lt;=n;++i) read(t[i]),read(c[i]),r=max(r,t[i]);    while(l&lt;=r)    {        ll mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,r=mid-1;        else l=mid+1;    }    cout&lt;&lt;ans;    return 0;}\nT3 100:\n#include&lt;bits/stdc++.h&gt;#define maxn 2510using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,q;int dn[maxn];char s[maxn];unordered_map&lt;int,int&gt; mp[maxn];bitset&lt;maxn&gt; f(int l,int r){    if(s[l]=='&amp;'||s[l]=='|')    {        int l1,r1,l2,r2;        l1=l+1,r1=l1;        int num=0;        while(r1&lt;=r)        {            if(s[r1]=='(') num++;            if(s[r1]==')') num--;            if(num==0) break;            r1++;        }        l2=r1+1,r2=r;        if(s[l]=='&amp;') return f(l1+1,r1-1)&amp;f(l2+1,r2-1);        else return f(l1+1,r1-1)|f(l2+1,r2-1);    }    else    {        int pos;        for(int i=l;i&lt;=r;++i)            if(!isdigit(s[i]))                pos=i;        int x=0,y=0;        for(int i=l;i&lt;=pos-1;++i) x=s[i]-'0'+x*10;        for(int i=pos+1;i&lt;=r;++i) y=s[i]-'0'+y*10;        bitset&lt;maxn&gt; b;        if(s[pos]==':')        {            for(int i=1;i&lt;=n;++i)            {                if(!mp[i].count(x)) b[i]=0;                else                {                    if(mp[i][x]==y) b[i]=1;                    else b[i]=0;                }            }        }        else        {            for(int i=1;i&lt;=n;++i)            {                if(!mp[i].count(x)) b[i]=0;                else                {                    if(mp[i][x]!=y) b[i]=1;                    else b[i]=0;                }            }        }        return b;    }}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        read(dn[i]);        int num;        read(num);        while(num--)        {            int x,y;            read(x),read(y);            mp[i][x]=y;        }    }    read(q);    while(q--)    {        scanf(\"%s\",s+1);        int len=strlen(s+1);        bitset&lt;maxn&gt; ans=f(1,len);        vector&lt;int&gt; v;        for(int i=1;i&lt;=n;++i)            if(ans[i])                v.push_back(dn[i]);        sort(v.begin(),v.end());        for(int i=0;i&lt;v.size();++i) printf(\"%d \",v[i]);        puts(\"\");    }    return 0;}\nT4 60:\n#include&lt;bits/stdc++.h&gt;#define maxn using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,q;struct node{    int id;    vector&lt;int&gt; l,r;};set&lt;node&gt; s;bool operator &lt; (const node &amp;a,const node &amp;b){    int siz=a.r.size();    for(int i=0;i&lt;m;++i)        if(a.r[i]!=b.r[i])            return a.r[i]&lt;b.r[i];    return false;}bool operator == (const node &amp;a,const node &amp;b){    return a.id==b.id&amp;&amp;a.l==b.l&amp;&amp;a.r==b.r;}vector&lt;int&gt; operator - (const vector&lt;int&gt; &amp;a,const int &amp;b){    vector&lt;int&gt; c=a;    for(int i=m-1;i&gt;=0;--i)    {        if(c[i])        {            c[i]-=b;            return c;        }        else        {            c[i]+=16;            c[i]-=b;        }    }    return c;}vector&lt;int&gt; get(string str){    vector&lt;int&gt; v;    int len=str.size();    for(int i=0;i&lt;len;i+=5)    {        int val=0;        for(int j=i;j&lt;i+4;++j)        {            int x;            if(isdigit(str[j])) x=str[j]-'0';            else            {                if(str[j]=='a') x=10;                if(str[j]=='b') x=11;                if(str[j]=='c') x=12;                if(str[j]=='d') x=13;                if(str[j]=='e') x=14;                if(str[j]=='f') x=15;            }            val=val*16+x;        }        v.push_back(val);    }    return v;}vector&lt;int&gt; R(){    string str;    cin&gt;&gt;str;    return get(str);}set&lt;node&gt;::iterator find(vector&lt;int&gt; &amp;x){    return s.lower_bound((node){0,x,x});}void work1(){    int x;    vector&lt;int&gt; l,r;    set&lt;node&gt;::iterator t1,t2,it;    read(x),l=R(),r=R();    t1=find(l),t2=find(r);    if(t1==s.end()&amp;&amp;t2==s.end())    {        puts(\"YES\");        s.insert((node){x,l,r});        return;    }    if(r&lt;(*t1).l)    {        puts(\"YES\");        s.insert((node){x,l,r});        return;    }    if((*t1)==(*t2)&amp;&amp;!(l&lt;(*t1).l))    {        puts(\"NO\");        return;    }    vector&lt;node&gt; v;    for(set&lt;node&gt;::iterator it=t1;it!=s.end();++it)    {        if(it==s.end()) break;        if(x!=(*it).id)        {            puts(\"NO\");            return;        }        v.push_back(*it);        if(it==t2) break;    }    for(int i=0;i&lt;v.size();++i) s.erase(v[i]);    if(v[0].l&lt;l) l=v[0].l;    if(r&lt;v[v.size()-1].r) r=v[v.size()-1].r;    puts(\"YES\");    node tmp=(node){x,l,r},ttmp;    s.insert(tmp);    it=find(r);    if(it!=s.begin())    {        t1=it,t1--;        if((*t1).r==tmp.l-1&amp;&amp;(*t1).id==x)        {            ttmp=(node){x,(*t1).l,tmp.r};            s.erase(t1),s.erase(tmp);            tmp=ttmp;            s.insert(tmp);        }    }    it=find(r);    t1=it,t1++;    if(t1!=s.end())    {        if(tmp.r==(*t1).l-1&amp;&amp;(*t1).id==x)        {            ttmp=(node){x,tmp.l,(*t1).r};            s.erase(t1),s.erase(tmp);            tmp=ttmp;            s.insert(tmp);        }    }}void work2(){    vector&lt;int&gt; x;    x=R();    set&lt;node&gt;::iterator it;    it=find(x);    if(it==s.end())    {        puts(\"0\");        return;    }    if(x&lt;(*it).l)    {        puts(\"0\");        return;    }    printf(\"%d\\n\",(*it).id);}void work3(){    vector&lt;int&gt; l,r;    set&lt;node&gt;::iterator t1,t2;    l=R(),r=R();    t1=find(l),t2=find(r);    if(t1==s.end()||t2==s.end())    {        puts(\"0\");        return;    }    if(t1!=t2)    {        puts(\"0\");        return;    }    if(l&lt;(*t1).l)    {        puts(\"0\");        return;    }    printf(\"%d\\n\",(*t1).id);}int main(){    read(n),read(q),m=n/16;    while(q--)    {        int opt;        read(opt);        if(opt==1) work1();        if(opt==2) work2();        if(opt==3) work3();    }    return 0;}\nT5 60:\n#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;ll ans;int l[maxn],r[maxn],id[maxn];set&lt;pair&lt;int,int&gt; &gt; s;map&lt;pair&lt;int,int&gt;,bool&gt; mp;bool vis[maxn],V[maxn],vis2[maxn];ll calc(int R){    if(V[R]) return 0;    V[R]=true;    ll val=0;    for(int i=1;i&lt;=m;++i) vis[i]=false;    for(int i=1;i&lt;=n;++i) vis2[i]=false;    int pos=0,id=0,mx=0;    for(int i=1;i&lt;=m;++i)    {        if(l[i]&gt;pos&amp;&amp;r[i]==R)        {            pos=l[i];            id=i;        }    }    vis[id]=true;    vis2[pos]=true;    val++;    priority_queue&lt;pair&lt;int,int&gt; &gt; q;    for(int i=1;i&lt;=m;++i)    {        if(vis[i]) continue;        if(r[i]&lt;=R)        {            q.push(make_pair(l[i],r[i]));        }    }    while(!q.empty())    {        int l=q.top().first,r=q.top().second;        q.pop();        if(r&gt;=pos-1&amp;&amp;l&lt;pos)        {            pos=l;            if(!vis2[pos])            {                vis2[pos]=true;                val++;            }        }    }    return val;}int main(){    read(n),read(m);    for(int i=1;i&lt;=m;++i) read(l[i]),read(r[i]);    for(int i=1;i&lt;=m;++i) ans+=calc(r[i]);    cout&lt;&lt;ans;    return 0;}\n","categories":["é¢˜è§£"],"tags":["CSP"]},{"title":"æå®æ¯…æœºå™¨å­¦ä¹ ","url":"/2023/07/14/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"Self-Attention\nMulti-head Self-attention\nTransformerEncoder\nDecoder\n\nEncoder-Decoder\nLSTM\n\n","categories":["å­¦ä¹ ç¬”è®°"],"tags":["äººå·¥æ™ºèƒ½","æœºå™¨å­¦ä¹ "]},{"title":"è”é‚¦å­¦ä¹ ","url":"/2023/11/15/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/","content":"è”é‚¦æœºå™¨å­¦ä¹ æ˜¯ä¸€ä¸ªæœºå™¨å­¦ä¹ æ¡†æ¶ï¼Œèƒ½æœ‰æ•ˆå¸®åŠ©å¤šä¸ªæœºæ„åœ¨æ»¡è¶³ç”¨æˆ·éšç§ä¿æŠ¤ã€æ•°æ®å®‰å…¨å’Œæ”¿åºœæ³•è§„çš„è¦æ±‚ä¸‹ï¼Œè¿›è¡Œæ•°æ®ä½¿ç”¨å’Œæœºå™¨å­¦ä¹ å»ºæ¨¡ã€‚\nè”é‚¦å­¦ä¹ ç™½çš®ä¹¦ï¼š\nè”é‚¦å­¦ä¹ ï¼šåœ¨è¿›è¡Œæœºå™¨å­¦ä¹ çš„è¿‡ç¨‹ä¸­ï¼Œå„å‚ä¸æ–¹å¯å€ŸåŠ©å…¶ä»–æ–¹æ•°æ®è¿›è¡Œè”åˆå»ºæ¨¡ã€‚å„æ–¹æ— éœ€å…±äº«æ•°æ®èµ„æºï¼Œå³æ•°æ®ä¸å‡ºæœ¬åœ°çš„æƒ…å†µä¸‹ï¼Œè¿›è¡Œæ•°æ®è”åˆè®­ç»ƒï¼Œå»ºç«‹å…±äº«çš„æœºå™¨å­¦ä¹ æ¨¡å‹ã€‚\næ¨ªå‘è”é‚¦å­¦ä¹ ï¼š\nä¸¤ä¸ªæ•°æ®é›†çš„ç”¨æˆ·ç‰¹å¾  é‡å éƒ¨åˆ†è¾ƒå¤§,è€Œç”¨æˆ·  é‡å éƒ¨åˆ†è¾ƒå°ã€‚\nåœ¨ä¸¤ä¸ªæ•°æ®é›†çš„ç”¨æˆ·ç‰¹å¾é‡å è¾ƒå¤šè€Œç”¨æˆ·é‡å è¾ƒå°‘çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æŠŠæ•°æ®é›†æŒ‰ç…§æ¨ªå‘ï¼ˆå³ç”¨æˆ·ç»´åº¦ï¼‰åˆ‡åˆ†å¹¶å–å‡ºåŒæ–¹ç”¨æˆ·ç‰¹å¾ç›¸åŒè€Œç”¨æˆ·ä¸å®Œå…¨ç›¸åŒçš„é‚£éƒ¨åˆ†æ•°æ®è¿›è¡Œè®­ç»ƒã€‚\nçºµå‘è”é‚¦å­¦ä¹ ï¼š\nä¸¤ä¸ªæ•°æ®é›†çš„ç”¨æˆ·  é‡å éƒ¨åˆ†è¾ƒå¤§,è€Œç”¨æˆ·ç‰¹å¾  é‡å éƒ¨åˆ†è¾ƒå°ã€‚\nåœ¨ä¸¤ä¸ªæ•°æ®é›†çš„ç”¨æˆ·é‡å è¾ƒå¤šè€Œç”¨æˆ·ç‰¹å¾é‡å è¾ƒå°‘çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æŠŠæ•°æ®é›†æŒ‰ç…§çºµå‘ï¼ˆå³ç‰¹å¾ç»´åº¦ï¼‰åˆ‡åˆ†å¹¶å–å‡ºåŒæ–¹ç”¨æˆ·ç›¸åŒè€Œç”¨æˆ·ç‰¹å¾ä¸å®Œå…¨ç›¸åŒçš„é‚£éƒ¨åˆ†æ•°æ®è¿›è¡Œè®­ç»ƒã€‚\nè”é‚¦è¿ç§»å­¦ä¹ ï¼š\nä¸¤ä¸ªæ•°æ®é›†çš„ç”¨æˆ·  ä¸ç”¨æˆ·ç‰¹å¾é‡å   éƒ¨åˆ†éƒ½æ¯”è¾ƒå°ã€‚\nåœ¨ä¸¤ä¸ªæ•°æ®é›†çš„ç”¨æˆ·ä¸ç”¨æˆ·ç‰¹å¾é‡å éƒ½è¾ƒå°‘çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸å¯¹æ•°æ®è¿›è¡Œåˆ‡åˆ†ï¼Œè€Œå¯ä»¥åˆ©ç”¨è¿ç§»å­¦ä¹ å…‹æœæ•°æ®æˆ–æ ‡ç­¾ä¸è¶³çš„æƒ…å†µã€‚\n\nJMLR 2017 Communication-Efficient Learning Of Deep Networks From Decentralized Dataä¸ºäº†ä¿è¯æ¨¡å‹èšåˆçš„å‡†ç¡®æ€§ï¼ŒFedAvg ç®—æ³•é‡‡ç”¨åŠ æƒå¹³å‡çš„æ–¹å¼è¿›è¡Œæ¨¡å‹èšåˆã€‚è®¾å¤‡ä¸Šä¼ çš„æ¨¡å‹å‚æ•°çš„æƒé‡æ˜¯æ ¹æ®è®¾å¤‡ä¸Šçš„æœ¬åœ°æ•°æ®é‡å¤§å°è¿›è¡Œèµ‹å€¼çš„ï¼Œæ•°æ®é‡è¶Šå¤šçš„è®¾å¤‡æƒé‡è¶Šå¤§ã€‚ä½†å…¶ä¹Ÿå­˜åœ¨æ•°æ®ä¸å¹³è¡¡çš„é—®é¢˜ï¼Œå³æ•°æ®é‡å°çš„æœ¬åœ°è®¾å¤‡è´¡çŒ®å°ã€‚\nç›®æ ‡ä¸ºï¼š\n\n\\begin{aligned}\n\\min_{w \\in R^d} f(w)& \\\\\nf(w)&=\\frac{1}{n}\\sum_{i=1}^n f_i(w) \\\\\nf_i(w)&=l(x_i,y_i;w)\n\\end{aligned}è€ƒè™‘è”é‚¦å­¦ä¹ çš„æƒ…å†µï¼Œå‡è®¾æœ‰  ä¸ªå®¢æˆ·ç«¯ï¼Œ æ˜¯ç¬¬  ä¸ªå®¢æˆ·ç«¯çš„ç´¢å¼•é›†ï¼Œï¼Œç›®æ ‡åˆ™å¯æ”¹å†™ä¸ºï¼š\n\n\\begin{aligned}\nf(w)&=\\sum_{k=1}^K \\frac{n_k}{n}F_k(w) \\\\\nF_k(w)&=\\frac{1}{n_k}\\sum_{i \\in P_k} f_i(w)\n\\end{aligned}FedSGD\n æ§åˆ¶ç€å…¨å±€æ‰¹æ¬¡å¤§å°ï¼Œ å¯¹åº”å…¨æ‰¹æ¬¡æ¢¯åº¦ä¸‹é™ã€‚ å’Œå›ºå®šå­¦ä¹ ç‡  çš„ FedSGD å®ç°ï¼š\n\n\\begin{aligned}\nw_{t+1} &\\leftarrow w_t - \\eta\\sum_{k=1}^K\\frac{n_k}{n} \\nabla F_k(w_t) \\\\\n\\sum_{k=1}^K\\frac{n_k}{n} \\nabla F_k(w_t)&=\\nabla f(w_t)\n\\end{aligned}ä¹Ÿç­‰ä»·äºï¼š\n\n\\begin{aligned}\n\\forall k, w_{t+1}^k &\\leftarrow w_t -  \\eta\\nabla F_k(w_t) \\\\\nw_{t+1}&\\leftarrow\\sum_{k=1}^K\\frac{n_k}{n}w_{t+1}^k\n\\end{aligned}ä¹Ÿå°±æ˜¯ï¼Œæ¯ä¸ªå®¢æˆ·ç«¯åœ¨å…¶æœ¬åœ°æ•°æ®ä¸Šä½¿ç”¨å½“å‰æ¨¡å‹è¿›è¡Œä¸€æ­¥å…¨æ‰¹é‡æ¢¯åº¦ä¸‹é™ï¼Œç„¶åæœåŠ¡å™¨å¯¹ç»“æœæ¨¡å‹è¿›è¡ŒåŠ æƒå¹³å‡ã€‚\nFedAvg\nè¿›è¡Œå¤šæ¬¡è¿­ä»£æœ¬åœ°æ›´æ–°ï¼š\n\nw^k \\leftarrow w^k -  \\eta\\nabla F_k(w_t)å…¶ä¸­å‚æ•°ä¸ºï¼šï¼Œæ¯è½®è®¡ç®—çš„å®¢æˆ·ç«¯çš„æ¯”ä¾‹ã€‚ï¼Œæ¯ä¸ªå®¢æˆ·ç«¯åœ¨æ¯è½®ä¸­å¯¹å…¶æœ¬åœ°æ•°æ®é›†è¿›è¡Œçš„è®­ç»ƒæ¬¡æ•°ï¼ˆï¼‰ã€‚ï¼Œå®¢æˆ·ç«¯æ›´æ–°çš„æœ¬åœ°æ‰¹é‡å¤§å°ã€‚\nå½“ ï¼ˆæ•´ä¸ªæœ¬åœ°æ•°æ®é›†è§†ä¸ºä¸€ä¸ªæ‰¹æ¬¡ï¼‰å’Œ  æ—¶ï¼Œå°±å¯¹åº”äº† FedSGDã€‚\n\nNeurIPS 2020 Personalized Federated Learning: A Meta-Learning ApproachPer-FedAvgï¼Œå…¶ç›®æ ‡æ˜¯è®­ç»ƒä¸€ä¸ªå…¨å±€æ¨¡å‹ï¼Œè¯¥æ¨¡å‹æ›´å®¹æ˜“è¿›è¡Œå¾®è°ƒä»¥é€‚åº”ç‰¹å®šè®¾å¤‡çš„æ•°æ®ã€‚\nè‹¥æœ‰  ä¸ªå®¢æˆ·ç«¯ï¼Œåˆ™è”é‚¦å­¦ä¹ çš„ç›®æ ‡ä¸ºï¼š\n\n\\begin{aligned}\n\\min_{w \\in \\mathbb R^d}\nf(w) &\\coloneqq \\frac{1}{n}\\sum_{i=1}^n f_i(w) \\\\\nf_i(w) &\\coloneqq \\mathbb E_{(x,y) \\sim p_i}[l(w;x,y)]\n\\end{aligned}å…¶å±€é™æ€§ä¸ºï¼šåœ¨ç”¨æˆ·æ•°æ®åˆ†å¸ƒä¸åŒçš„å¼‚è´¨æƒ…å†µæ—¶ï¼Œè¿™æ ·å¾—åˆ°çš„å…¨å±€æ¨¡å‹åº”ç”¨åˆ°æœ¬åœ°æ—¶ï¼Œè¡¨ç°ä¸å¥½ã€‚å› æ­¤éœ€è¦è€ƒè™‘åˆ°æ¯ä¸ªç”¨æˆ·çš„ç‰¹å®šæƒ…å†µï¼Œè€Œä¸èƒ½ä»…ä»…ä¾èµ–å…¨å±€æ¨¡å‹ã€‚\nPer-FedAvg ä¸­åˆ™æ˜¯æ‰€æœ‰ç”¨æˆ·å¾—åˆ°åˆå§‹æ¨¡å‹åï¼Œç„¶ååœ¨æœ¬åœ°æ•°æ®ä¸Šæ¢¯åº¦ä¸‹é™ä¸€æ¬¡æ¥å¾—åˆ°è‡ªå·±çš„æ¨¡å‹ï¼š\n\n\\begin{aligned}\n\\min_{w \\in \\mathbb R^d}\nF(w) &\\coloneqq \\frac{1}{n}\\sum_{i=1}^n f_i(w-\\alpha\\nabla f_i(w) ) \\\\\nF_i(w) &\\coloneqq f_i(w-\\alpha\\nabla f_i(w) )\n\\end{aligned}å›é¡¾ FedAvg çš„åšæ³•ï¼š\n\n\\begin{aligned}\n\\forall k, w_{t+1}^k &\\leftarrow w_t -  \\eta\\nabla F_k(w_t) \\\\\nw_{t+1}&\\leftarrow\\sum_{k=1}^K\\frac{n_k}{n}w_{t+1}^k\n\\end{aligned}æˆ‘ä»¬éœ€è¦è®¡ç®—æœ¬åœ°å‡½æ•°çš„æ¢¯åº¦ï¼š\n\n\\nabla F_i(w) =(I-\\alpha\\nabla^2 f_i(w))\\nabla f_i(w-\\alpha\\nabla f_i(w) )å®ç°æ—¶ï¼Œç”¨æ— åä¼°è®¡ä»£æ›¿åŸå§‹å‚æ•°æ±‚å¯¼æ¥å‡å°‘å¼€é”€ã€‚\n\nMLSys 2020 Federated Optimization in Heterogeneous NetworksFedProxï¼Œå…¶ç›®æ ‡æ˜¯è§£å†³åœ¨æœ¬åœ°è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œä¸ªæ€§åŒ–æ¨¡å‹åç¦»å…¨å±€æ¨¡å‹è¿‡è¿œçš„é—®é¢˜ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç›®æ ‡ï¼ŒFedProx åœ¨æœ¬åœ°è®­ç»ƒçš„ç›®æ ‡å‡½æ•°ä¸­å¼•å…¥äº†ä¸€ä¸ªåŠ¨æ€æ­£åˆ™åŒ–é¡¹ã€‚è¿™ä¸ªæ­£åˆ™åŒ–é¡¹å¯ä»¥é™åˆ¶æ¨¡å‹çš„æ›´æ–°æ­¥éª¤ï¼Œé˜²æ­¢æ¨¡å‹åç¦»å…¨å±€æ¨¡å‹å¤ªè¿œã€‚\nè®¾å¤‡  åœ¨æœ¬åœ°è®­ç»ƒæ—¶ï¼Œæœ€å°åŒ–ï¼š\n\n\\min_w h_k(w;w^t)=F_k(w)+\\frac{\\mu}{2}||w-w^t||^2 åŠ¨æ€å˜åŒ–æ—¶ï¼Œæ•ˆæœæœ€å¥½ã€‚å®éªŒä¸­ï¼Œå½“æŸå¤±è¿ç»­  è½®å¢åŠ æ—¶ï¼Œæˆ‘ä»¬å°†  å¢åŠ  ï¼›å½“æŸå¤±è¿ç»­  è½®å‡å°‘æ—¶ï¼Œæˆ‘ä»¬å°†  å‡å°‘ ã€‚\nNeurIPS 2023 PRIOR: Personalized Prior for Reactivating the Information Overlooked in Federated LearningIntroductionè”é‚¦å­¦ä¹ çš„åŸºæœ¬ç‰¹æ€§æ˜¯æ•°æ®å¼‚è´¨æ€§ï¼Œå¯¼è‡´äº†è¯¸å¦‚è®­ç»ƒå’Œæµ‹è¯•æ•°æ®ä¸ä¸€è‡´ï¼ˆæ•°æ®æ¼‚ç§»ï¼‰ç­‰æŒ‘æˆ˜ã€‚\næ•°æ®å¼‚è´¨æ€§ï¼šä¸åŒçš„å‚ä¸è€…å¯èƒ½æ‹¥æœ‰ä¸åŒç±»å‹æˆ–åˆ†å¸ƒçš„æ•°æ®ã€‚è¿™ç§æ•°æ®çš„å·®å¼‚æ€§å¯èƒ½å¯¼è‡´æ¨¡å‹åœ¨ä¸åŒçš„å‚ä¸è€…ä¹‹é—´è¡¨ç°ä¸ä¸€è‡´ã€‚\næ•°æ®æ¼‚ç§»ï¼šæ¨¡å‹åœ¨è®­ç»ƒå’Œæµ‹è¯•æ•°æ®ä¸Šçš„è¡¨ç°ä¸ä¸€è‡´ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæ¨¡å‹åœ¨æŸä¸€ç±»å‹çš„æ•°æ®ä¸Šè¿›è¡Œè®­ç»ƒï¼Œä½†åœ¨å¦ä¸€ç±»å‹çš„æ•°æ®ä¸Šè¿›è¡Œæµ‹è¯•ï¼Œé‚£ä¹ˆæ¨¡å‹çš„è¡¨ç°å¯èƒ½ä¼šä¸‹é™ã€‚è¿™æ˜¯å› ä¸ºæ¨¡å‹å¯èƒ½æœªèƒ½æ•æ‰åˆ°æµ‹è¯•æ•°æ®ä¸­çš„æŸäº›é‡è¦ç‰¹å¾ã€‚\nä¸ªæ€§åŒ– FLï¼ˆPFLï¼‰è¢«æå‡ºæ¥å‡è½»å¼‚æ„æ•°æ®å¯¼è‡´çš„è´Ÿé¢å½±å“ã€‚é€šè¿‡ä¸ªæ€§åŒ–å­¦ä¹ ï¼Œæ¯ä¸ªè®¾å¤‡å¯ä»¥æ ¹æ®å…¶è‡ªèº«çš„æ•°æ®ç‰¹æ€§è®­ç»ƒæ¨¡å‹ï¼Œä»è€Œæé«˜æ¨¡å‹åœ¨è¯¥è®¾å¤‡ä¸Šçš„æ€§èƒ½ã€‚\nç°æœ‰çš„ PFL å­˜åœ¨ä¸¤ä¸ªé—®é¢˜ï¼š\nç›¸åŒçš„å…¨å±€æ¨¡å‹ä¸ºæœ¬åœ°è®­ç»ƒæä¾›å…ˆéªŒçŸ¥è¯†ï¼Œå¯¼è‡´å¿½è§†å®¢æˆ·ç«¯çš„é‡‡æ ·ä¿¡æ¯ã€‚\nåšä¸åˆ°æ˜¾å¼æå–å…ˆéªŒçŸ¥è¯†ã€‚\næœ¬æ–‡æå‡ºäº† pFedBreD æ¡†æ¶ï¼Œå°†ä¸ªæ€§åŒ–å…ˆéªŒçŸ¥è¯†æ³¨å…¥åˆ°å…¨å±€æ¨¡å‹æä¾›çš„çŸ¥è¯†ä¸­ï¼Œæ¥è§£å†³ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚å¼•å…¥å®½æ¾çš„é•œåƒä¸‹é™ RMD æ¥æ˜¾å¼æå–å…ˆéªŒä»¥æ¢ç´¢ä¸ªæ€§åŒ–ç­–ç•¥ï¼Œæ¥è§£å†³ç¬¬äºŒä¸ªé—®é¢˜ã€‚\nPreliminaryOverlooked Information in Prior Knowledge\nä¼ é€’ç»™å®¢æˆ·ç«¯çš„å…¨å±€çŸ¥è¯†ä¸å®¢æˆ·ç«¯é‡‡æ ·æ²¡æœ‰äº’ä¿¡æ¯ï¼ˆMutual Informationï¼ŒMIï¼Œåº¦é‡äº†ä¸¤ä¸ªå˜é‡ä¹‹é—´ç›¸äº’ä¾èµ–çš„ç¨‹åº¦ï¼‰ï¼Œå³\n\nw = \\text E_i w_i=\\text E_i w_i|i \\Rightarrow \\text{MI}\\ I(w;i)=0å…¶ä¸­  æ˜¯ç¬¬  ä¸ªå®¢æˆ·ç«¯ä¸Šçš„æœ¬åœ°æ¨¡å‹ï¼Œ æ˜¯å…¨å±€æ¨¡å‹ï¼Œ æ˜¯åœ¨ç»™å®šå®¢æˆ·ç«¯  çš„é‡‡æ ·çš„æ¡ä»¶ä¸‹çš„æœŸæœ›å€¼ã€‚\nBregman-Moreau Envelope\nå¸ƒé›·æ ¼æ›¼æ•£åº¦ï¼ˆBregman Divergenceï¼‰æ˜¯ä¸€ç§åœ¨ä¼˜åŒ–é—®é¢˜ä¸­å¸¸ç”¨çš„æ­£åˆ™é¡¹ï¼Œå®ƒæ»¡è¶³è®¡ç®—éœ€æ±‚å’Œå…ˆéªŒå‡è®¾ï¼š\n\n\\mathcal D_g(x,y) \\coloneqq g(x)-g(y)-\\left \\langle \\nabla g(y),x-y \\right \\rangle \\tag{1} æ˜¯ä¸€ä¸ªä¸¥æ ¼å‡¸ã€å¯å¾®çš„å‡½æ•°ã€‚\nå¦‚ä½•ç†è§£å¸ƒé›·æ ¼æ›¼æ•£åº¦ï¼š\n\n\\begin{aligned}\nd(x,y)&=\\sqrt{\\sum_{i=1}^n(x_i-y_i)^2} \\\\\nd^2(x,y)&=\\sum_{i=1}^n(x_i-y_i)^2 \\\\\n&=\\left \\langle x-y,x-y \\right \\rangle \\\\\n&=||x||^2-||y||^2-\\left \\langle 2y,x-y \\right \\rangle \\\\\n\\end{aligned}æ³¨æ„åˆ°  æ˜¯  çš„å¯¼æ•°ï¼Œå°†å®šä¹‰æ‰©å±•ï¼ŒæŠŠ  æ¢ä¸ºå‡¸å‡½æ•°  åä¾¿å¾—åˆ°äº†å¸ƒé›·æ ¼æ›¼æ•£åº¦ã€‚\nä¸ºäº†åˆ©ç”¨å¸ƒé›·æ ¼æ›¼æ•£åº¦çš„è®¡ç®—æ€§è´¨ï¼Œå¼•å…¥å¸ƒé›·æ ¼æ›¼è¿‘ç«¯æ˜ å°„ï¼ˆBregman proximal mappingï¼‰å’Œå¸ƒé›·æ ¼æ›¼-è«ç½—åŒ…ç»œï¼ˆBregman-Moreau envelopeï¼‰ï¼š\n\n\\begin{aligned}\n\\mathcal D\\text{prox}_{g,\\lambda^{-1}}f(x)&\\coloneqq \\arg \\min_\\theta\\{f(\\theta)+\\lambda\\mathcal D_g(\\theta,x)\\} \\\\\n\\mathcal D\\text{env}_{g,\\lambda^{-1}}f(x)&\\coloneqq \\min_\\theta\\{f(\\theta)+\\lambda\\mathcal D_g(\\theta,x)\\} \\\\\n\\nabla\\mathcal D\\text{env}_{g,\\lambda^{-1}}f(x)&=\\lambda\\nabla^2 g(x)\\left[x-\\mathcal D\\text{prox}_{g,\\lambda^{-1}}f(x)\\right]\n\\end{aligned}\\tag{2}å…¶ä¸­  è¡¨ç¤ºæ­£åˆ™åŒ–å¼ºåº¦å’Œå»ºæ¨¡ä¸­å…ˆéªŒçš„æ–¹å·®ã€‚\nExponential Family\næŒ‡æ•°æ—ï¼ˆExponential Familyï¼ŒX-familyï¼‰ï¼š\n\n\\begin{aligned}\n\\text{P}_{ef}(\\mathcal V;s,g)&=h(\\mathcal V)\\exp\\left\\{ \\left \\langle \\mathcal V,s \\right \\rangle-g(s)\\right\\} \\\\\n&=h(\\mathcal V)\\exp\\left\\{ -\\mathcal D_{g^*}(\\mathcal V,\\mu)+g^*(\\mathcal V)\\right\\}\n\\end{aligned}\\tag{3}å…¶ä¸­ï¼Œ æ˜¯å‡¸å‡½æ•°ï¼Œ æ˜¯å¸ƒé›·æ ¼æ›¼æ•£åº¦ï¼Œ æ˜¯  çš„ Fenchel å…±è½­ï¼Œ æ˜¯è‡ªç„¶å‚æ•°ï¼Œ æ˜¯åŠ¿å‡½æ•°ï¼Œ æ˜¯å¯¹æ•°å½’ä¸€åŒ–å› å­ï¼Œ æ˜¯å‡å€¼å‚æ•°ã€‚\nä¸ºäº†çªå‡ºæ–¹å·®ï¼Œå¼•å…¥äº†ç¼©æ”¾æŒ‡æ•°æ—ï¼ˆScaled Exponential Familyï¼ŒSX-familyï¼‰ï¼š\n\n\\begin{aligned}\n\\text{P}_{sef}(\\mathcal V;\\lambda,s,g)\n&=h_\\mathcal V(\\mathcal V)\\exp\\left\\{\\lambda[ \\left \\langle \\mathcal V,s \\right \\rangle-g(s)]\\right\\} \\\\\n&=h_\\lambda(\\mathcal V)\\exp\\left\\{ -\\lambda\\mathcal D_{g^*}(\\mathcal V,\\mu)+\\lambda g^*(\\mathcal V)\\right\\}\n\\end{aligned}\\tag{4}å…¶ä¸­  æ˜¯ç¼©æ”¾åŠ¿å‡½æ•°ï¼Œ æ˜¯ç¼©æ”¾å‚æ•°ï¼Œç”¨æ¥çªå‡ºæ–¹å·®ã€‚\n è¢«å‡è®¾ä¸ºæœ¬åœ°æ¨æ–­çš„å®Œå…¨ä¿¡æ¯çš„æœ€å°å……åˆ†ç»Ÿè®¡é‡ã€‚\nMethodologyåœ¨ç»å…¸è”é‚¦å­¦ä¹ çš„åŸºç¡€ä¸Šå¼•å…¥ç¼ºå¤±çš„å®¢æˆ·ç«¯é‡‡æ ·ä¿¡æ¯ï¼Œä½¿ç”¨ EM ç®—æ³•æ¥é™ä½å¼•å…¥ä¿¡æ¯çš„è®¡ç®—æˆæœ¬ï¼Œå¹¶åŸºäº EM ä¸­çš„ E-step æå‡ºäº†ä¸€ç±»å…ˆéªŒé€‰æ‹©ç­–ç•¥ï¼ŒRMDã€‚\né€šè¿‡å®¢æˆ·ç«¯é‡‡æ ·  å’Œæœ¬åœ°æ•°æ®é‡‡æ · ï¼Œå…·æœ‰ KL æ•£åº¦çš„ä¸€èˆ¬ FL åˆ†ç±»é—®é¢˜å¯è¢«è¡¨è¿°ä¸ºï¼š\n\n\\begin{aligned}\n&\\arg \\min_w \\text E_i \\text E_{d_i} \\text{KL}(\\text P (y_i | x_i)||\\hat {\\text P} (y_i | x_i,w)) \\\\\n=&\\arg \\max_w \\text E_i \\text E_{d_i} \\text E_{y_i | x_i} \\log\\hat{\\text P} (y_i | x_i,w),(x_i,y_i) \\in d_i\n\\end{aligned}\\tag{5}KL æ•£åº¦ç”¨æ¥åº¦é‡ä¸¤ä¸ªæ¦‚ç‡åˆ†å¸ƒä¹‹é—´çš„å·®å¼‚ç¨‹åº¦ï¼š\n\nD_{\\text{KL}}(P||Q)=\\sum_{i} P(i)\\log \\frac{P(i)}{Q(i)}è¿™é‡Œå°†åˆ¤åˆ«æ¨¡å‹é‡å†™ä¸ºäº†ä¸€ä¸ªå…³äº  çš„æœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼ˆMLEï¼‰é—®é¢˜ã€‚ æ˜¯  å‚æ•°åŒ–çš„æ¨ç†æ¨¡å‹ã€‚\nç›´æ¥é€šè¿‡å…¨å±€æ¨¡å‹ä¼ è¾“çš„å…ˆéªŒçŸ¥è¯†ä½œä¸ºæœ¬åœ°è®­ç»ƒçš„å…ˆéªŒçŸ¥è¯†ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡åˆå§‹ç‚¹ï¼ŒåŠ¨æ€æ­£åˆ™é¡¹ä¸­çš„æƒ©ç½šç‚¹ç­‰ï¼‰ä¸å®¢æˆ·ç«¯é‡‡æ ·æ²¡æœ‰äº’ä¿¡æ¯ã€‚ä¸ºäº†å‡å°‘å¿½è§†ä¿¡æ¯çš„æ½œåœ¨å½±å“ï¼Œå¼•å…¥äº†ç¬¬  ä¸ªå®¢æˆ·ç«¯çš„å®Œæ•´ä¿¡æ¯ ï¼š\n\n\\begin{aligned}\n&\\arg \\max_w \\text E_i \\text E_{d_i} \\text E_{y_i | x_i} \\log\\hat{\\text P} (y_i | x_i,w),(x_i,y_i) \\in d_i \\\\\n=&\\arg \\max_w \\text E \\log \\int_{\\Theta_i} \\hat{\\text P}(y_i|x_i,\\Theta_i,w)\\text P(\\Theta_i|x_i,w) d\\Theta_i \\\\\n\\end{aligned}\\tag{6}å…¶ä¸­ ï¼Œä½†ç›´æ¥è®¡ç®—çš„è¯ï¼Œè®¡ç®—æˆæœ¬é«˜æ˜‚ã€‚\nFramework: Leveraging Expectation Maximization for Prior Parameter Extraction\nå› æ­¤ç”¨ EM æ–¹æ³•æ¥è¿‘ä¼¼å«æœ‰æœªè§‚å¯Ÿå˜é‡çš„ä¼¼ç„¶å‡½æ•°ï¼Œå…¶ä¸­  æ˜¯ä»»æ„çš„æ¦‚ç‡æµ‹åº¦ï¼š\n\n\\sum_i \\log \\hat{\\text P}(y_i|x_i,w) \\geqslant \\sum_i \\text E_{\\text Q(\\Theta _i)}[\\log \\hat{\\text P}(y_i|x_i,\\Theta_i,w)+\\text E_{y_i | x_i,w}\\log \\text P(\\Theta_i|d_i,w)]\\tag{7}å¼•å…¥ä¸¤ä¸ªå‡è®¾ï¼š\n\n\\begin{aligned}\n&\\Theta_i | d_i,w \\sim \\hat{\\text P}_{sef}(\\Theta_i;\\lambda,s_i(w;d_i),g) \\\\\n&\\theta_i = \\Theta_i,\\text P(y_i | x_i,\\Theta_i,w)=\\text P(y_i|x_i,\\Theta_i)\n\\end{aligned}ç¬¬ä¸€ä¸ªæ˜¯å¯¹å…ˆéªŒçš„å‡è®¾ï¼Œç¬¬äºŒä¸ªæ˜¯å‡è®¾  åŒ…å«äº†æ‰€æœ‰çš„æœ¬åœ°æ¨æ–­ä¿¡æ¯ã€‚\nç¬¬  ä¸ªå®¢æˆ·ç«¯çš„æœ¬åœ°æŸå¤±å‡½æ•°ä¸º ï¼Œç»“åˆå‡è®¾ï¼Œå¾—åˆ° ã€‚æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªåŒå±‚ä¼˜åŒ–çš„é—®é¢˜ï¼š\n\n\\begin{aligned}\n&-\\max_{w,\\{ \\theta_i \\}} \\text E_i \\{ -f_i(\\theta_i)-\\lambda \\mathcal D_{g^*}(\\theta_i,\\mu_i(w)) \\} \\\\\n\\leqslant&\\min_w \\text E_i\\min_{\\{\\theta_i\\}} \\{ f_i(\\theta_i)+ \\lambda \\mathcal D_{g^*}(\\theta_i,\\mu_i(w)) \\}\n\\end{aligned}\\tag{8}å…¶ä¸­å‡å€¼å‚æ•° ã€‚\nStrategies: Relaxing Mirror Descent for Prior Selection\nä¸ºäº†åœ¨å°é—­å½¢å¼ä¸­å®ç° EM çš„  E-step å¹¶æå–å…ˆéªŒç­–ç•¥ï¼Œæå‡ºäº†ä¸€ç§ç§°ä¸ºæ¾å¼›é•œåƒä¸‹é™ï¼ˆRelaxed Mirror Descentï¼Œç®€ç§° RMDï¼‰çš„æ–¹æ³•ã€‚\né•œåƒä¸‹é™ï¼ˆMirror Descentï¼Œç®€ç§°MDï¼‰æ˜¯ X-family ä¸­çš„ EMï¼Œä¸ºï¼š\n\n\\hat w^+ \\leftarrow \\arg \\min_{\\hat\\theta}\\{ f(\\hat w)+ \\left \\langle \\mathcal \\nabla f(\\hat w),\\hat\\theta-\\hat w \\right \\rangle+\\hat \\lambda \\mathcal D_{\\hat g}(\\hat \\theta,\\hat w)\\}\\tag{9}æ ¹æ®æ‹‰æ ¼æœ—æ—¥å¯¹å¶æ€§ï¼Œå°†é—®é¢˜é‡å†™æˆæ›´ä¸€èˆ¬çš„å˜ä½“ï¼Œå…¶ä¸­æœ‰æ¾å¼›çš„é™åˆ¶å’Œå¤šä½™çš„å‚æ•°ï¼š\n\n\\arg \\min_{\\hat \\theta,\\hat \\mu}\\{ \\Psi(\\hat \\theta,\\hat w)+ \\left\\langle \\nabla \\Phi(\\hat w),\\hat \\mu - \\hat w \\right\\rangle+\\lambda \\mathcal D_{g^*}(\\hat\\theta,\\hat\\mu)+(2\\eta)^{-1}||\\hat\\mu-\\hat w||^2\\}\\tag{10}è®¾ç½®  æ»¡è¶³ ï¼Œå¹¶å®šä¹‰  ä½œä¸ºä¸€ä¸ªåŒ…å«  å’Œä¸€ä¸ªä½¿å¾—  å’Œ  å°½å¯èƒ½æ¥è¿‘çš„æƒ©ç½šé¡¹çš„å‡½æ•°ï¼Œä½¿å¾—å°†è¯¥å…¬å¼  è½¬æ¢å›å…¬å¼ ã€‚è¿™æä¾›äº†ä¸€ç§æå–  çš„æ–¹æ³•ï¼Œè¯¥å‡½æ•°ç”¨äºç”Ÿæˆå…ˆéªŒçš„å‡å€¼å‚æ•°ï¼Œå¦‚å…¬å¼  æ‰€ç¤ºï¼Œè¯¥å…¬å¼æ˜¯æœ€å°åŒ–å…¬å¼  é—®é¢˜çš„ä¸Šç•Œï¼š\n\n\\begin{aligned}\n\\mathcal D\\text{env}_{g^*,\\lambda^{-1}} \\Psi(\\cdot,w)(\\mu_\\Phi(w))&=\\min_\\theta\\{ \\Psi(\\theta,w)+\\lambda\\mathcal D_{g^*}(\\theta,\\mu_{\\Phi}(w)) \\} \\\\\n\\mu_\\Phi (w)&=\\arg\\min_\\mu\\{ \\left\\langle \\nabla \\Phi(w),\\mu-w \\right\\rangle+(2\\eta)^{-1}||\\mu-w||^2 \\}\n\\end{aligned}\\tag{11}æ ¹æ®æœ€ä¼˜æ€§æ¡ä»¶ï¼Œæœ‰ ï¼Œè¿™å¯ä»¥ç”±  æŒ‡å®šã€‚å‰©ä¸‹çš„éƒ¨åˆ†æ˜¯ä¸€ä¸ª Bregman-Moreau åŒ…ç»œã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ EM-MAP æ–¹æ³•ä¼˜åŒ–ä¸Šç•Œï¼Œäº¤æ›¿è®¡ç®—  å’Œ ã€‚\nFramework DesignProblem Formulation that Highlights Personalized Prior\nä¸ªæ€§åŒ–æ¨¡å‹  å’Œå¹³å‡å‚æ•°åˆ†åˆ«æ˜¯ç¬¬iä¸ªå®¢æˆ·ç«¯ä¸Šçš„  å’Œ  çš„è§£ï¼Œå…¶ä¸­  æ˜¯å…¨å±€æ¨¡å‹ã€‚æˆ‘ä»¬å‡è®¾ä¸ªæ€§åŒ–æ¨¡å‹åŒ…å«ç¬¬  ä¸ªå®¢æˆ·ç«¯ä¸Šæ¨ç†æ‰€éœ€çš„æ‰€æœ‰æœ¬åœ°ä¿¡æ¯ï¼Œå¹¶ä¸”æ»¡è¶³ ï¼Œå…¨å±€é—®é¢˜å¯ä»¥å†™æˆï¼š\n\n\\min_w \\text E_i\\{ F_i(w)\\coloneqq \\mathcal D{\\text{env}_{g^*,\\lambda^{-1}}}f_i(\\mu_i(w)) \\} \\tag{12} æ˜¯ä¸¥æ ¼å‡¸çš„ï¼Œï¼Œ æ˜¯å±€éƒ¨æŸå¤±å‡½æ•°ï¼Œ æ˜¯è‡ªç„¶å‚æ•°ï¼Œ æ˜¯å‡å€¼æ–¹ç¨‹ä¸­çš„å‚æ•°ã€‚\nFramework: pFedBreD\nä¸ºäº†è§£å†³æ–¹ç¨‹  ä¸­çš„ä¼˜åŒ–é—®é¢˜ï¼Œä½¿ç”¨åŸºäºæ¢¯åº¦çš„æ–¹æ³•æ¥åˆ©ç”¨  çš„æ¢¯åº¦æ¥è§£å†³å…¨å±€é—®é¢˜ï¼š\n\n\\nabla F_i(w) = \\lambda \\text D \\mu_i(w)\\nabla^2 g^*(\\mu_i(w))[\\mu_i(w)- \\mathcal D{\\text{prox}_{g^*,\\lambda^{-1}}}f_i(\\mu_i(w))] \\tag{13}å…¶ä¸­  æ˜¯å‘é‡å€¼å‡½æ•°çš„æ¢¯åº¦ç®—å­ï¼Œ æ˜¯ Hessian ç®—å­ã€‚å…¶ä¸­  æ˜¯å…¨å±€æ¨¡å‹èšåˆçš„å®¢æˆ·ç«¯é€‰æ‹©ç­–ç•¥ï¼Œå’Œ  æ˜¯ç¬¬  ä¸ªå®¢æˆ·ç«¯çš„åˆå§‹åŒ–ç­–ç•¥ï¼Œ ä¸ºä¸»é—®é¢˜æ­¥é•¿ï¼Œ åˆ†åˆ«æ˜¯æ€»è¿­ä»£æ¬¡æ•°ã€å±€éƒ¨è¿­ä»£æ¬¡æ•°å’Œå®¢æˆ·ç«¯æ•°ã€‚ ç”Ÿæˆæ¯ä¸ª  å’Œ  çš„åˆå§‹åŒ–ç‚¹çš„ç­–ç•¥æ˜¯  å’Œ  ã€‚\n\n","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®ºæ–‡","äººå·¥æ™ºèƒ½","è”é‚¦å­¦ä¹ "]},{"title":"ç®—æ³•ç«èµ›æ¨¡æ¿","url":"/2023/07/30/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%A8%A1%E6%9D%BF/","content":"æ•°æ®ç»“æ„çº¿æ®µæ ‘åˆå¹¶#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 20000010#define all 100000#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot;int ans[maxn],f[maxn][19],dep[maxn],rt[maxn],mx[maxm],id[maxm],ls[maxm],rs[maxm];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void dfs_pre(int x,int fa){    dep[x]=dep[f[x][0]=fa]+1;    for(int i=1;i&lt;=16;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_pre(y,x);    }}int lca(int x,int y){\tif(dep[x]&lt;dep[y]) swap(x,y);\tfor(int i=16;i&gt;=0;--i)\t\tif(f[x][i]&amp;&amp;dep[f[x][i]]&gt;=dep[y])\t\t\tx=f[x][i];\tif(x==y) return x;\tfor(int i=16;i&gt;=0;--i)\t\tif(f[x][i]&amp;&amp;f[x][i]!=f[y][i])\t\t\tx=f[x][i],y=f[y][i];\treturn f[x][0];}void pushup(int cur){\tif(mx[ls[cur]]&gt;=mx[rs[cur]]) mx[cur]=mx[ls[cur]],id[cur]=id[ls[cur]];\telse mx[cur]=mx[rs[cur]],id[cur]=id[rs[cur]];}void modify(int l,int r,int pos,int v,int &amp;cur){\tif(!cur) cur=++tot;\tif(l==r)\t{\t\tmx[cur]+=v,id[cur]=l;\t\treturn;\t}\tif(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);\telse modify(mid+1,r,pos,v,rs[cur]);\tpushup(cur);}int merge(int x,int y,int l,int r){\tif(!x||!y) return x+y;\tif(l==r)\t{\t\tmx[x]+=mx[y];\t\treturn x;\t}\tls[x]=merge(ls[x],ls[y],l,mid);\trs[x]=merge(rs[x],rs[y],mid+1,r);\tpushup(x);\treturn x;}void dfs_ans(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==f[x][0]) continue;\t\tdfs_ans(y),rt[x]=merge(rt[x],rt[y],1,all);\t}\tans[x]=mx[rt[x]]?id[rt[x]]:0;}int main(){    read(n),read(m);    for(int i=1;i&lt;n;++i)    {    \tint x,y;    \tread(x),read(y);    \tadd(x,y),add(y,x);    }    dfs_pre(1,0);    for(int i=1;i&lt;=m;++i)    {    \tint x,y,v,anc;    \tread(x),read(y),read(v),anc=lca(x,y);    \tmodify(1,all,v,1,rt[x]),modify(1,all,v,1,rt[y]);    \tmodify(1,all,v,-1,rt[anc]),modify(1,all,v,-1,rt[f[anc][0]]);    }    dfs_ans(1);    for(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]);    return 0;}\nçº¿æ®µæ ‘åˆ†è£‚ç»´æŠ¤è‹¥å¹²ä¸ªå¯é‡é›†ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 80000010#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot,num=1;int rt[maxn],ls[maxn],rs[maxn];ll cnt[maxn];void pushup(int cur){    cnt[cur]=cnt[ls[cur]]+cnt[rs[cur]];}void modify(int l,int r,int pos,ll v,int &amp;cur){    if(!cur) cur=++tot;    if(l==r)    {        cnt[cur]+=v;        return;    }    if(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);    else modify(mid+1,r,pos,v,rs[cur]);    pushup(cur);}ll query(int L,int R,int l,int r,int cur){    if(!cur) return 0;    if(L&lt;=l&amp;&amp;R&gt;=r) return cnt[cur];    ll v=0;    if(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);    if(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);    return v;}int kth(int l,int r,ll k,int cur){    if(l==r) return l;    if(cnt[ls[cur]]&gt;=k) return kth(l,mid,k,ls[cur]);    else return kth(mid+1,r,k-cnt[ls[cur]],rs[cur]);}int merge(int x,int y){    if(!x||!y) return x+y;    int p=++tot;    cnt[p]=cnt[x]+cnt[y];    ls[p]=merge(ls[x],ls[y]);    rs[p]=merge(rs[x],rs[y]);    return p;}void split(int L,int R,int l,int r,int &amp;x,int &amp;y){    if(!x) return;    if(L&lt;=l&amp;&amp;R&gt;=r)    {        y=x,x=0;        return;    }    y=++tot;    if(L&lt;=mid) split(L,R,l,mid,ls[x],ls[y]);    if(R&gt;mid) split(L,R,mid+1,r,rs[x],rs[y]);    pushup(x),pushup(y);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i)    {        ll x;        read(x),modify(1,n,i,x,rt[1]);    }    while(m--)    {        int opt,p;        ll x,y,k;        read(opt),read(p);        if(opt==1||opt==4) read(k);        else read(x),read(y);        if(opt==0) split(x,y,1,n,rt[p],rt[++num]);        if(opt==1) rt[p]=merge(rt[p],rt[k]);        if(opt==2) modify(1,n,y,x,rt[p]);        if(opt==3) printf(\"%lld\\n\",query(x,y,1,n,rt[p]));        if(opt==4)        {            if(cnt[rt[p]]&lt;k) puts(\"-1\");            else printf(\"%d\\n\",kth(1,n,k,rt[p]));        }    }    return 0;}\nå‰å¸æœºçº¿æ®µæ ‘åŒºé—´åŠ ï¼ŒåŒºé—´å– ï¼ŒåŒºé—´æ±‚å’Œï¼ŒåŒºé—´æœ€å¤§å€¼ï¼ŒåŒºé—´å†å²æœ€å¤§å€¼ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010#define inf 20000000000#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,root=1;ll a[maxn],ma[maxn],hma[maxn],se[maxn],cnt[maxn],sum[maxn];ll tag[maxn],htag[maxn],add[maxn],hadd[maxn];void pushup(int cur){    sum[cur]=sum[ls]+sum[rs],ma[cur]=max(ma[ls],ma[rs]),hma[cur]=max(hma[ls],hma[rs]);    if(ma[ls]==ma[rs]) se[cur]=max(se[ls],se[rs]),cnt[cur]=cnt[ls]+cnt[rs];    else if(ma[ls]&gt;ma[rs]) se[cur]=max(se[ls],ma[rs]),cnt[cur]=cnt[ls];    else se[cur]=max(ma[ls],se[rs]),cnt[cur]=cnt[rs];}void pushtag(int cur,int l,int r,ll v,ll hv,ll w,ll hw){    sum[cur]+=v*cnt[cur]+w*(r-l+1-cnt[cur]);    hma[cur]=max(hma[cur],ma[cur]+hv),ma[cur]+=v;    htag[cur]=max(htag[cur],tag[cur]+hv),tag[cur]+=v;    hadd[cur]=max(hadd[cur],add[cur]+hw),add[cur]+=w;    if(se[cur]!=-inf) se[cur]+=w;}void pushdown(int cur,int l,int r){    ll maxv=max(ma[ls],ma[rs]);    if(ma[ls]==maxv) pushtag(ls,l,mid,tag[cur],htag[cur],add[cur],hadd[cur]);    else pushtag(ls,l,mid,add[cur],hadd[cur],add[cur],hadd[cur]);    if(ma[rs]==maxv) pushtag(rs,mid+1,r,tag[cur],htag[cur],add[cur],hadd[cur]);    else pushtag(rs,mid+1,r,add[cur],hadd[cur],add[cur],hadd[cur]);    tag[cur]=htag[cur]=add[cur]=hadd[cur]=0;}void build(int l,int r,int cur){    if(l==r)    {        sum[cur]=ma[cur]=hma[cur]=a[l],se[cur]=-inf,cnt[cur]=1;        return;    }    build(l,mid,ls),build(mid+1,r,rs),pushup(cur);}void modify_add(int L,int R,int l,int r,ll v,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        pushtag(cur,l,r,v,v,v,v);        return;    }    pushdown(cur,l,r);    if(L&lt;=mid) modify_add(L,R,l,mid,v,ls);    if(R&gt;mid) modify_add(L,R,mid+1,r,v,rs);    pushup(cur);}void modify_min(int L,int R,int l,int r,ll v,int cur){    if(v&gt;=ma[cur]) return;    if(L&lt;=l&amp;&amp;R&gt;=r&amp;&amp;v&gt;se[cur])    {        pushtag(cur,l,r,v-ma[cur],v-ma[cur],0,0);        return;    }    pushdown(cur,l,r);    if(L&lt;=mid) modify_min(L,R,l,mid,v,ls);    if(R&gt;mid) modify_min(L,R,mid+1,r,v,rs);    pushup(cur);}ll query_sum(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];    pushdown(cur,l,r);    ll ans=0;    if(L&lt;=mid) ans+=query_sum(L,R,l,mid,ls);    if(R&gt;mid) ans+=query_sum(L,R,mid+1,r,rs);    return ans;}ll query_max(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return ma[cur];    pushdown(cur,l,r);    ll ans=-inf;    if(L&lt;=mid) ans=max(ans,query_max(L,R,l,mid,ls));    if(R&gt;mid) ans=max(ans,query_max(L,R,mid+1,r,rs));    return ans;}ll query_his(int L,int R,int l,int r,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r) return hma[cur];    pushdown(cur,l,r);    ll ans=-inf;    if(L&lt;=mid) ans=max(ans,query_his(L,R,l,mid,ls));    if(R&gt;mid) ans=max(ans,query_his(L,R,mid+1,r,rs));    return ans;}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    build(1,n,root);    while(m--)    {        int opt,l,r,v;        read(opt),read(l),read(r);        if(opt==1||opt==2) read(v);        if(opt==1) modify_add(l,r,1,n,v,root);        if(opt==2) modify_min(l,r,1,n,v,root);        if(opt==3) printf(\"%lld\\n\",query_sum(l,r,1,n,root));        if(opt==4) printf(\"%lld\\n\",query_max(l,r,1,n,root));        if(opt==5) printf(\"%lld\\n\",query_his(l,r,1,n,root));    }    return 0;}\nçº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾void build_in(int L,int R,int &amp;cur){    cur=++tree_cnt;    if(L==R)    {        in_num[L]=cur;        return;    }    int mid=(L+R)&gt;&gt;1;    build_in(L,mid,ls[cur]);    build_in(mid+1,R,rs[cur]);    add(ls[cur],cur,0),add(rs[cur],cur,0);}void build_out(int L,int R,int &amp;cur){    cur=++tree_cnt;    if(L==R)    {        out_num[L]=cur;        return;    }    int mid=(L+R)&gt;&gt;1;    build_out(L,mid,ls[cur]);    build_out(mid+1,R,rs[cur]);    add(cur,ls[cur],0),add(cur,rs[cur],0);}void modify_in(int L,int R,int l,int r,int pos,int val,int &amp;cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        add(cur,pos,val);        return;    }    int mid=(l+r)&gt;&gt;1;    if(L&lt;=mid) modify_in(L,R,l,mid,pos,val,ls[cur]);    if(R&gt;mid) modify_in(L,R,mid+1,r,pos,val,rs[cur]);}void modify_out(int L,int R,int l,int r,int pos,int val,int &amp;cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        add(pos,cur,val);        return;    }    int mid=(l+r)&gt;&gt;1;    if(L&lt;=mid) modify_out(L,R,l,mid,pos,val,ls[cur]);    if(R&gt;mid) modify_out(L,R,mid+1,r,pos,val,rs[cur]);}\nçº¿æ®µæ ‘åˆ†æ²»åˆ å»æ— å‘è¿é€šå›¾ä¸€äº›è¾¹åï¼Œè¯¢é—®åŸå›¾æ˜¯å¦è¿é€šã€‚å°†åˆ è¾¹è½¬åŒ–ä¸ºè¾¹å­˜åœ¨çš„åŒºé—´ï¼Œç”¨å¸¦æƒå¹¶æŸ¥é›†ç»´æŠ¤è¿é€šå—å¤§å°ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 400010#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,k,top;int fa[maxn],siz[maxn],pre[maxn];bool ans[maxn];vector&lt;int&gt; ve[maxm];struct node{    int x,y;    node(int a=0,int b=0)    {    \tx=a,y=b;    }}e[maxn],st[maxn];int find(int x){    return fa[x]==x?x:find(fa[x]);}void merge(int x,int y){    x=find(x),y=find(y);    if(x==y) return;    if(siz[x]&lt;siz[y]) swap(x,y);    st[++top]=node(x,y),fa[y]=x,siz[x]+=siz[y];}void insert(int L,int R,int l,int r,int id,int cur){    if(L&lt;=l&amp;&amp;R&gt;=r)    {        ve[cur].push_back(id);        return;    }    if(L&lt;=mid) insert(L,R,l,mid,id,ls);    if(R&gt;mid) insert(L,R,mid+1,r,id,rs);}void del(int id){    int x=st[id].x,y=st[id].y;    fa[y]=y,siz[x]-=siz[y];}void dfs(int l,int r,int cur){    int now=top;    for(int i=0;i&lt;ve[cur].size();++i)\t\tmerge(e[ve[cur][i]].x,e[ve[cur][i]].y);    if(l==r) ans[l]=siz[find(1)]==n;    else dfs(l,mid,ls),dfs(mid+1,r,rs);    while(top&gt;now) del(top--);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) siz[fa[i]=i]=1;    for(int i=1;i&lt;=m;++i) read(e[i].x),read(e[i].y),pre[i]=1;    read(k);    for(int i=1;i&lt;=k;++i)    {        int c;        read(c);        while(c--)        {            int id;            read(id);            if(pre[id]&lt;i) insert(pre[id],i-1,1,k,id,1);            pre[id]=i+1;        }    }    for(int i=1;i&lt;=m;++i)        if(pre[i]&lt;=k)            insert(pre[i],k,1,k,i,1);    dfs(1,k,1);    for(int i=1;i&lt;=k;++i) puts(ans[i]?\"Connected\":\"Disconnected\");\treturn 0;}\næè¶…çº¿æ®µæ ‘æ”¯æŒæ’å…¥ç›´çº¿ï¼ŒæŸ¥è¯¢å•ç‚¹æœ€å€¼ã€‚\nï¼Œæ–œç‡ä¼˜åŒ–ï¼Œç»´æŠ¤ä¸‹å‡¸å£³ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 4000010#define all 1000000#define inf 1000000000000#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot,root;int ls[maxm],rs[maxm],num[maxm];ll h[maxn],s[maxn],k[maxn],b[maxn],f[maxn];ll y(int id,ll x){    return k[id]*x+b[id];}void insert(int l,int r,int id,int &amp;cur){    if(!cur)\t{\t\tnum[cur=++tot]=id;\t\treturn;\t}\tif(y(id,mid)&lt;y(num[cur],mid)) swap(id,num[cur]);\tif(y(id,l)&gt;=y(num[cur],l)&amp;&amp;y(id,r)&gt;=y(num[cur],r)) return;\tif(y(id,l)&lt;y(num[cur],l)) insert(l,mid,id,ls[cur]);\telse insert(mid+1,r,id,rs[cur]);}ll query(int l,int r,int x,int cur){    if(!cur) return inf;    ll v=y(num[cur],x);    if(x&lt;=mid) v=min(v,query(l,mid,x,ls[cur]));    else v=min(v,query(mid+1,r,x,rs[cur]));    return v;}int main(){    read(n);    for(int i=1;i&lt;=n;++i) read(h[i]);    for(int i=1;i&lt;=n;++i) read(s[i]),s[i]+=s[i-1];    for(int i=1;i&lt;=n;++i)    {        if(i!=1) f[i]=query(0,all,h[i],root)+h[i]*h[i]+s[i-1];        k[i]=-2*h[i],b[i]=f[i]+h[i]*h[i]-s[i],insert(0,all,i,root);    }    printf(\"%lld\",f[n]);    return 0;}\né‡é“¾å‰–åˆ†#include&lt;bits/stdc++.h&gt;#define maxn 400010#define ls (cur&lt;&lt;1)#define rs (cur&lt;&lt;1|1)#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,rt,root=1,cnt;ll p;int siz[maxn],fa[maxn],dfn[maxn],top[maxn],son[maxn],dep[maxn],rev[maxn];ll a[maxn],sum[maxn],tag[maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void pushup(int cur){\tsum[cur]=(sum[ls]+sum[rs])%p;}void pushtag(int cur,int l,int r,ll v){\tsum[cur]=(sum[cur]+v*(r-l+1)%p)%p,tag[cur]=(tag[cur]+v)%p;}void pushdown(int cur,int l,int r){\tif(!tag[cur]) return;\tpushtag(ls,l,mid,tag[cur]),pushtag(rs,mid+1,r,tag[cur]),tag[cur]=0;}void build(int l,int r,int cur){\tif(l==r)\t{\t\tsum[cur]=a[rev[l]];\t\treturn;\t}\tbuild(l,mid,ls),build(mid+1,r,rs),pushup(cur);}void modify(int L,int R,int l,int r,int v,int cur){\tif(L&lt;=l&amp;&amp;R&gt;=r)\t{\t\tpushtag(cur,l,r,v);\t\treturn;\t}\tpushdown(cur,l,r);\tif(L&lt;=mid) modify(L,R,l,mid,v,ls);\tif(R&gt;mid) modify(L,R,mid+1,r,v,rs);\tpushup(cur);}ll query(int L,int R,int l,int r,int cur){\tif(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];\tll v=0;    pushdown(cur,l,r);\tif(L&lt;=mid) v=(v+query(L,R,l,mid,ls))%p;\tif(R&gt;mid) v=(v+query(L,R,mid+1,r,rs))%p;\treturn v;}void update(int x,int y,int v){\twhile(top[x]!=top[y])\t{\t\tif(dep[top[x]]&lt;dep[top[y]]) swap(x,y);\t\tmodify(dfn[top[x]],dfn[x],1,n,v,root),x=fa[top[x]];\t}\tif(dep[x]&gt;dep[y]) swap(x,y);\tmodify(dfn[x],dfn[y],1,n,v,root);}ll ask(int x,int y){\tll v=0;\twhile(top[x]!=top[y])\t{\t\tif(dep[top[x]]&lt;dep[top[y]]) swap(x,y);\t\tv=(v+query(dfn[top[x]],dfn[x],1,n,root))%p,x=fa[top[x]];\t}\tif(dep[x]&gt;dep[y]) swap(x,y);\treturn (v+query(dfn[x],dfn[y],1,n,root))%p;}void dfs_son(int x,int fath){\tfa[x]=fath,dep[x]=dep[fath]+1,siz[x]=1;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fath) continue;\t\tdfs_son(y,x),siz[x]+=siz[y];\t\tif(siz[y]&gt;siz[son[x]]) son[x]=y;\t}}void dfs_chain(int x,int tp){\tdfn[x]=++cnt,rev[cnt]=x,top[x]=tp;\tif(son[x]) dfs_chain(son[x],tp);\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(dfn[y]) continue;\t\tdfs_chain(y,y);\t}}int main(){ \tread(n),read(m),read(rt),read(p);\tfor(int i=1;i&lt;=n;++i) read(a[i]);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs_son(rt,0),dfs_chain(rt,rt),build(1,n,root);\twhile(m--)\t{\t\tint opt,x,y,v;\t\tread(opt),read(x);\t\tif(opt==1) read(y),read(v),update(x,y,v);\t\tif(opt==2) read(y),printf(\"%lld\\n\",ask(x,y));\t\tif(opt==3) read(v),modify(dfn[x],dfn[x]+siz[x]-1,1,n,v,root);\t\tif(opt==4) printf(\"%lld\\n\",query(dfn[x],dfn[x]+siz[x]-1,1,n,root));\t}\treturn 0;}\nä¸»å¸­æ ‘é™æ€åŒºé—´ç¬¬  å°ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,tot,num;int a[maxn],s[maxn],rt[maxn],cnt[maxm],ls[maxm],rs[maxm];void modify(int l,int r,int pos,int &amp;cur){    int x=++tot;    ls[x]=ls[cur],rs[x]=rs[cur],cnt[x]=cnt[cur]+1,cur=x;    if(l==r) return;    if(pos&lt;=mid) modify(l,mid,pos,ls[cur]);    else modify(mid+1,r,pos,rs[cur]);}int query(int l,int r,int k,int x,int y){    if(l==r) return l;    if(k&gt;cnt[ls[y]]-cnt[ls[x]]) return query(mid+1,r,k-cnt[ls[y]]+cnt[ls[x]],rs[x],rs[y]);    return query(l,mid,k,ls[x],ls[y]);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]),s[i]=a[i];    sort(s+1,s+n+1),num=unique(s+1,s+n+1)-s-1;    for(int i=1;i&lt;=n;++i) rt[i]=rt[i-1],modify(1,num,lower_bound(s+1,s+num+1,a[i])-s,rt[i]);    while(m--)    {        int l,r,k;        read(l),read(r),read(k);        printf(\"%d\\n\",s[query(1,num,k,rt[l-1],rt[r])]);    }    return 0;}\nå¯æŒä¹…åŒ–å¹¶æŸ¥é›†åˆå¹¶ä¸é‡‡ç”¨è·¯å¾„å‹ç¼©ï¼Œä¿è¯æ¯æ¬¡åˆå¹¶åªä¿®æ”¹ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²ï¼Œä½¿å½“å‰ç‰ˆæœ¬ä¸ä¸Šä¸€ç‰ˆæœ¬å…±ç”¨çš„èŠ‚ç‚¹å°½å¯èƒ½çš„å¤šã€‚ä¸ºé˜²æ­¢å¹¶æŸ¥é›†é€€åŒ–æˆé“¾ï¼Œé‡‡å–æŒ‰ç§©åˆå¹¶ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 10000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,tree_cnt;int ls[maxn],rs[maxn],root[maxn],a[maxn],fa[maxn],de[maxn];void build(int L,int R,int &amp;cur){\tcur=++tree_cnt;\tif(L==R)\t{\t\tfa[cur]=L;\t\treturn;\t}\tint mid=(L+R)&gt;&gt;1;\tbuild(L,mid,ls[cur]);\tbuild(mid+1,R,rs[cur]);}void merge(int L,int R,int pos,int fath,int pre,int &amp;cur){\tcur=++tree_cnt;\tif(L==R)\t{\t\tfa[cur]=fath;\t\tde[cur]=de[pre];\t\treturn;\t}\tls[cur]=ls[pre],rs[cur]=rs[pre];\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) merge(L,mid,pos,fath,ls[pre],ls[cur]);\tif(pos&gt;mid) merge(mid+1,R,pos,fath,rs[pre],rs[cur]);}int query(int L,int R,int pos,int cur){\tif(L==R) return cur;\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) return query(L,mid,pos,ls[cur]);\tif(pos&gt;mid) return query(mid+1,R,pos,rs[cur]);}void add(int L,int R,int pos,int cur){\tif(L==R)\t{\t\tde[cur]++;\t\treturn;\t}\tint mid=(L+R)&gt;&gt;1;\tif(pos&lt;=mid) add(L,mid,pos,ls[cur]);\telse add(mid+1,R,pos,rs[cur]);}int find(int pos,int cur){\tint fath=query(1,n,pos,cur);\tif(pos==fa[fath]) return fath;\treturn find(fa[fath],cur);}int main(){\tread(n),read(m);\tbuild(1,n,root[0]);\tfor(int i=1;i&lt;=m;i++)\t{\t\tint flag,a,b;\t\tread(flag);\t\tif(flag==1)\t\t{\t\t\tread(a),read(b);\t\t\troot[i]=root[i-1];\t\t\tint u=find(a,root[i]),v=find(b,root[i]);\t\t\tif(fa[u]==fa[v]) continue;\t\t\tif(de[u]&gt;de[v]) swap(u,v);\t\t\tmerge(1,n,fa[u],fa[v],root[i-1],root[i]);\t\t\tif(de[u]==de[v]) add(1,n,fa[v],root[i]);\t\t}\t\tif(flag==2)\t\t{\t\t\tread(a);\t\t\troot[i]=root[a];\t\t}\t\tif(flag==3)\t\t{\t\t\tread(a),read(b);\t\t\troot[i]=root[i-1];\t\t\tint u=find(a,root[i]),v=find(b,root[i]);\t\t\tif(fa[u]==fa[v]) puts(\"1\");\t\t\telse puts(\"0\");\t\t}\t}\treturn 0;}\nå¹³è¡¡æ ‘æ’å…¥ ï¼Œåˆ é™¤ ï¼ŒæŸ¥  çš„æ’åï¼ŒæŸ¥æ’åä¸º  çš„æ•°ï¼ŒæŸ¥  çš„å‰é©±ï¼ŒæŸ¥  çš„åç»§ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,last,ans,tot,root;int ls[maxn],rs[maxn],siz[maxn],key[maxn],val[maxn];int add(int v){\tval[++tot]=v,key[tot]=rand(),siz[tot]=1;\treturn tot;}void pushup(int x){\tsiz[x]=siz[ls[x]]+siz[rs[x]]+1;}void merge(int &amp;p,int x,int y){\tif(!x||!y)\t{\t\tp=x+y;\t\treturn;\t}\tif(key[x]&lt;key[y]) p=x,merge(rs[x],rs[x],y);\telse p=y,merge(ls[y],x,ls[y]);\tpushup(p);}void split(int p,int k,int &amp;x,int &amp;y){\tif(!p)\t{\t\tx=y=0;\t\treturn;\t}\tif(val[p]&lt;=k) x=p,split(rs[p],k,rs[x],y);\telse y=p,split(ls[p],k,x,ls[y]);\tpushup(p);}void insert(int v){\tint x,y;    split(root,v,x,y),merge(x,x,add(v)),merge(root,x,y);}void del(int v){\tint x,y,z;    split(root,v,x,y),split(x,v-1,x,z);    merge(z,ls[z],rs[z]),merge(x,x,z),merge(root,x,y);}int kth(int v){\tint x,y;    split(root,v-1,x,y);    int ans=siz[x]+1;    merge(root,x,y);    return ans;}int get(int p,int k){    if(k==siz[ls[p]]+1) return val[p];    if(k&lt;=siz[ls[p]]) return get(ls[p],k);    else return get(rs[p],k-siz[ls[p]]-1);}int pre(int v){\tint x,y;    split(root,v-1,x,y);    int ans=get(x,siz[x]);    merge(root,x,y);    return ans;}int nxt(int v){\tint x,y;    split(root,v,x,y);    int ans=get(y,1);    merge(root,x,y);    return ans;}int main(){    read(n),read(m);    for(int i=1,a;i&lt;=n;++i) read(a),insert(a);\twhile(m--)\t{\t\tint opt,a;\t\tread(opt),read(a),a^=last;\t\tif(opt==1) insert(a);\t\tif(opt==2) del(a);\t\tif(opt==3) last=kth(a);\t\tif(opt==4) last=get(root,a);\t\tif(opt==5) last=pre(a);\t\tif(opt==6) last=nxt(a);        if(opt!=1&amp;&amp;opt!=2) ans^=last;\t}    printf(\"%d\",ans);\treturn 0;}\næ’å…¥å¤šä¸ªæ•°ï¼Œåˆ é™¤å¤šä¸ªæ•°ï¼ŒåŒºé—´èµ‹å€¼ï¼ŒåŒºé—´ç¿»è½¬ï¼ŒåŒºé—´æ±‚å’Œï¼ŒåŒºé—´æœ€å¤§å­åºåˆ—ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010#define inf 500000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m,tot,root,top;int fa[maxn],siz[maxn],ch[maxn][2],tag[maxn],rev[maxn],st[maxn];int val[maxn],sum[maxn],ma[maxn],a[maxn],lm[maxn],rm[maxn],c[maxn];string opt;bool check(int x){    return ch[fa[x]][1]==x;}void pushup(int x){    int ls=ch[x][0],rs=ch[x][1];    siz[x]=siz[ls]+siz[rs]+1;    sum[x]=sum[ls]+sum[rs]+val[x];    lm[x]=max(lm[ls],sum[ls]+val[x]+lm[rs]);    rm[x]=max(rm[rs],sum[rs]+val[x]+rm[ls]);    ma[x]=max(val[x]+lm[rs]+rm[ls],max(ma[ls],ma[rs]));}void pushr(int x){    rev[x]^=1,swap(ch[x][0],ch[x][1]),swap(lm[x],rm[x]);}void pushv(int x,int v){    if(!x) return;    tag[x]=1,val[x]=v,sum[x]=v*siz[x];    lm[x]=rm[x]=max(sum[x],0),ma[x]=max(sum[x],val[x]);}void pushdown(int x){    int ls=ch[x][0],rs=ch[x][1];    if(tag[x]) pushv(ls,val[x]),pushv(rs,val[x]);    if(rev[x]) pushr(ls),pushr(rs);    tag[x]=rev[x]=0;}int add(){    int x=top?st[top--]:++tot;    fa[x]=ch[x][0]=ch[x][1]=rev[x]=siz[x]=tag[x]=0;    return x;}void build(int l,int r,int &amp;x,int *a){    x=add();    int mid=(l+r)&gt;&gt;1;    lm[x]=rm[x]=max(a[mid],0);    val[x]=ma[x]=sum[x]=a[mid];    if(l&lt;mid) build(l,mid-1,ch[x][0],a);    if(r&gt;mid) build(mid+1,r,ch[x][1],a);    fa[ch[x][0]]=fa[ch[x][1]]=x;    pushup(x);}void rotate(int x){    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];    ch[z][check(y)]=x,fa[x]=z;    ch[y][k]=w,fa[w]=y;    ch[x][k^1]=y,fa[y]=x;    pushup(y),pushup(x);}void splay(int x,int goal){    for(int y;fa[x]!=goal;rotate(x))        if(fa[y=fa[x]]!=goal)            rotate(check(x)^check(y)?x:y);    if(!goal) root=x;}int kth(int x){    int p=root;    while(1)    {        pushdown(p);        int ls=ch[p][0],rs=ch[p][1];        if(ls&amp;&amp;x&lt;=siz[ls]) p=ls;        else        {            x-=siz[ls]+1;            if(!x) return p;            p=rs;        }    }}void split(int l,int r){    l=kth(l-1),r=kth(r+1),splay(l,0),splay(r,l);}void insert(int x,int num){    int t,p;    build(1,num,t,c);    split(x+1,x);    p=ch[root][1];    ch[p][0]=t,fa[t]=p;    pushup(p),pushup(root);}void del(int x){    if(!x) return;    st[++top]=x;    del(ch[x][0]),del(ch[x][1]);}void erase(int l,int r){    int p;    split(l,r);    p=ch[root][1];    del(ch[p][0]),ch[p][0]=0;    pushup(p),pushup(root);}void cover(int l,int r,int v){    int p;    split(l,r);    p=ch[root][1];    pushv(ch[p][0],v);    pushup(p),pushup(root);}void reverse(int l,int r){    int p;    split(l,r);    p=ch[root][1];    pushr(ch[p][0]);    pushup(p),pushup(root);}int query(int l,int r){    int p;    split(l,r);    p=ch[root][1];    return sum[ch[p][0]];}int main(){\tread(n),read(m);    ma[0]=a[1]=a[n+2]=-inf;    for(int i=2;i&lt;=n+1;++i) read(a[i]);    build(1,n+2,root,a);    while(m--)    {        cin&gt;&gt;opt;        int x,num,v;        if(opt==\"MAX-SUM\") printf(\"%d\\n\",ma[root]);        else read(x),read(num),x++;        if(opt==\"INSERT\")        {            for(int i=1;i&lt;=num;++i) read(c[i]);            insert(x,num);        }        if(opt==\"DELETE\") erase(x,x+num-1);        if(opt==\"MAKE-SAME\") read(v),cover(x,x+num-1,v);        if(opt==\"REVERSE\") reverse(x,x+num-1);        if(opt==\"GET-SUM\") printf(\"%d\\n\",query(x,x+num-1));    }\treturn 0;}\nå¯æŒä¹…åŒ–å¹³è¡¡æ ‘#include&lt;bits/stdc++.h&gt;#define maxn 25000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,flag,tot,v,x,y,z;int ls[maxn],rs[maxn],siz[maxn],key[maxn],val[maxn],root[maxn];int build(int x){\tval[++tot]=x;\tsiz[tot]=1;\tkey[tot]=rand();\treturn tot;}void pushup(int x){\tsiz[x]=siz[ls[x]]+siz[rs[x]]+1;}int cpy(int x){\ttot++;\tval[tot]=val[x];\tsiz[tot]=siz[x];\tkey[tot]=key[x];\tls[tot]=ls[x];\trs[tot]=rs[x];\treturn tot;}void merge(int &amp;p,int x,int y){    if(!x||!y)    {           p=x+y;        return;    }    if(key[x]&lt;key[y]) p=cpy(x),merge(rs[p],rs[p],y);    else p=cpy(y),merge(ls[p],x,ls[p]);    pushup(p);}void split(int p,int k,int &amp;x,int &amp;y){\tif(!p)\t{\t\tx=y=0;\t\treturn;\t}\tif(val[p]&lt;=k)\t{\t\tx=cpy(p);\t\tsplit(rs[x],k,rs[x],y);\t\tpushup(x);\t}\telse\t{\t\ty=cpy(p);\t\tsplit(ls[y],k,x,ls[y]);\t\tpushup(y);\t}}int query(int p,int k){\tif(k==siz[ls[p]]+1) return val[p];\tif(k&lt;=siz[ls[p]]) return query(ls[p],k);\telse return query(rs[p],k-siz[ls[p]]-1);}int main(){\tread(n);\tfor(int i=1;i&lt;=n;++i)\t{\t\tint a;\t\tread(v),read(flag),read(a);\t\troot[i]=root[v];\t\tif(flag==1)\t\t{\t\t\tsplit(root[i],a,x,y);\t\t\tmerge(x,x,build(a));\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==2)\t\t{\t\t\tsplit(root[i],a,x,y);\t\t\tsplit(x,a-1,x,z);\t\t\tmerge(z,ls[z],rs[z]);\t\t\tmerge(x,x,z);\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==3)\t\t{\t\t\tsplit(root[i],a-1,x,y);\t\t\tprintf(\"%d\\n\",siz[x]+1);\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==4)\t\t\tprintf(\"%d\\n\",query(root[i],a));\t\tif(flag==5)\t\t{\t\t \tsplit(root[i],a-1,x,y);\t\t\tif(!siz[x]) puts(\"-2147483647\");\t\t\tprintf(\"%d\\n\",query(x,siz[x]));\t\t\tmerge(root[i],x,y);\t\t}\t\tif(flag==6)\t\t{\t\t \tsplit(root[i],a,x,y);\t\t\tif(!siz[y]) puts(\"2147483647\");\t\t\telse printf(\"%d\\n\",query(y,1));\t\t\tmerge(root[i],x,y);\t\t}\t \t}\treturn 0;}\nLCT#include&lt;bits/stdc++.h&gt;#define maxn 300010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int fa[maxn],ch[maxn][2],rev[maxn],val[maxn],sum[maxn];bool check(int x){\treturn ch[fa[x]][1]==x;}bool notroot(int x){\treturn ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void pushup(int x){\tsum[x]=sum[ch[x][0]]^sum[ch[x][1]]^val[x];\t}void pushrev(int x){\tswap(ch[x][0],ch[x][1]),rev[x]^=1;}void pushdown(int x){\tif(rev[x]) pushrev(ch[x][0]),pushrev(ch[x][1]),rev[x]=0;}void rotate(int x){\tint y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];\tif(notroot(y)) ch[z][check(y)]=x;\tch[x][k^1]=y,ch[y][k]=w;\tif(w) fa[w]=y;\tfa[x]=z,fa[y]=x;\tpushup(y),pushup(x);}void all(int x){\tif(notroot(x)) all(fa[x]);\tpushdown(x);}void splay(int x){\tall(x);\tfor(int y;notroot(x);rotate(x))\t\tif(notroot(y=fa[x]))\t\t\trotate(check(x)^check(y)?x:y);\tpushup(x);}void access(int x){\tfor(int y=0;x;y=x,x=fa[x])\t\tsplay(x),ch[x][1]=y,pushup(x);}void makeroot(int x){\taccess(x),splay(x),pushrev(x);}void split(int x,int y){\tmakeroot(x),access(y),splay(y);}int findroot(int x){\taccess(x),splay(x);\twhile(ch[x][0]) pushdown(x),x=ch[x][0];\tsplay(x);\treturn x;}void link(int x,int y){\tmakeroot(x);\tif(findroot(y)!=x) fa[x]=y;}void cut(int x,int y){\tsplit(x,y);\tif(ch[y][0]==x&amp;&amp;!ch[x][1]) fa[x]=ch[y][0]=0;}int query(int x,int y){\tsplit(x,y);\treturn sum[y];}int main(){\tread(n),read(m);\tfor(int i=1;i&lt;=n;++i) read(val[i]);\twhile(m--)\t{\t\tint opt,x,y;\t\tread(opt),read(x),read(y);\t\tif(opt==0) printf(\"%d\\n\",query(x,y));\t\tif(opt==1) link(x,y);\t\tif(opt==2) cut(x,y);\t\tif(opt==3) splay(x),val[x]=y;\t}    return 0;}\næ ‘å¥—æ ‘ä¸‰ç»´ååºï¼Œçº¿æ®µæ ‘å¥—æ ‘çŠ¶æ•°ç»„ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define lowbit(x) (x&amp;(-x))#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt,tot;int ans[maxn],rt[maxn],sum[maxm],ls[maxm],rs[maxm];struct node{    int a,b,c,val;}p[maxn];bool cmp(const node &amp;x,const node &amp;y){    if(x.a==y.a)    {        if(x.b==y.b) return x.c&lt;y.c;        return x.b&lt;y.b;    }    return x.a&lt;y.a;}void modify(int l,int r,int pos,int v,int &amp;cur){\tif(!cur) cur=++tot;\tsum[cur]+=v;\tif(l==r) return;\tif(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);\telse modify(mid+1,r,pos,v,rs[cur]);}int query(int L,int R,int l,int r,int cur){\tif(!cur) return 0;\tif(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];\tint v=0;\tif(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);\tif(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);\treturn v;}void update(int x,int c,int v){\twhile(x&lt;=m) modify(1,m,c,v,rt[x]),x+=lowbit(x);}int ask(int x,int c){\tint v=0;\twhile(x) v+=query(1,c,1,m,rt[x]),x-=lowbit(x);\treturn v;}void init(){    int pos;    sort(p+1,p+n+1,cmp);    for(int i=1;i&lt;=n;i=pos+1)    {        pos=i;        while(pos&lt;n&amp;&amp;p[i].a==p[pos+1].a&amp;&amp;p[i].b==p[pos+1].b&amp;&amp;p[i].c==p[pos+1].c) pos++;        p[++cnt]=p[i],p[cnt].val=pos-i+1;    }}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(p[i].a),read(p[i].b),read(p[i].c);    init();    for(int i=1;i&lt;=cnt;++i)\t{\t\tans[ask(p[i].b,p[i].c)+p[i].val-1]+=p[i].val;\t\tupdate(p[i].b,p[i].c,p[i].val);\t}    for(int i=0;i&lt;n;++i) printf(\"%d\\n\",ans[i]);    return 0;}\nçº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 20000010#define inf 2147483647using namespace std;typedef long long ll; template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}template&lt;typename T&gt; inline void write(T x){    short st[30],tp=0;    if(x&lt;0) putchar('-'),x=-x;    do st[++tp]=x%10,x/=10; while(x);    while(tp) putchar('0'|st[tp--]);}int n,m,tot;int a[maxn],val[maxn],key[maxn],siz[maxn],ls[maxn],rs[maxn];struct FHQ_Treap{    int root,x,y,z;    int add(int x)    {        val[++tot]=x;        siz[tot]=1;        key[tot]=rand();        return tot;    }    void pushup(int x)    {        siz[x]=siz[ls[x]]+siz[rs[x]]+1;    }    void merge(int &amp;p,int x,int y)    {        if(!x||!y)        {               p=x+y;            return;        }        if(key[x]&lt;key[y]) p=x,merge(rs[p],rs[p],y);        else p=y,merge(ls[p],x,ls[p]);        pushup(p);    }    void split(int p,int k,int &amp;x,int &amp;y)    {        if(!p)        {            x=y=0;            return;        }        if(val[p]&lt;=k) x=p,split(rs[p],k,rs[p],y);        else y=p,split(ls[p],k,x,ls[p]);        pushup(p);    }    void insert(int v)    {        split(root,v,x,y);        merge(x,x,add(v));        merge(root,x,y);    }    void del(int v)    {        split(root,v,x,y);        split(x,v-1,x,z);        merge(z,ls[z],rs[z]);        merge(x,x,z);        merge(root,x,y);    }    void build(int l,int r)    {        for(int i=l;i&lt;=r;++i) insert(a[i]);    }    int kth(int v)    {        split(root,v-1,x,y);        int ans=siz[x]+1;        merge(root,x,y);        return ans;    }    int get(int p,int k)    {        if(k==siz[ls[p]]+1) return val[p];        if(k&lt;=siz[ls[p]]) return get(ls[p],k);        else return get(rs[p],k-siz[ls[p]]-1);    }    int pre(int v)    {        split(root,v-1,x,y);        int ans;        if(siz[x]) ans=get(x,siz[x]);        else ans=-inf;        merge(root,x,y);        return ans;    }    int nxt(int v)    {        split(root,v,x,y);        int ans;        if(siz[y]) ans=get(y,1);        else ans=inf;        merge(root,x,y);        return ans;    }}treap[maxn];int tree_cnt,root;int lc[maxn],rc[maxn];struct Segment_Tree{    void build(int l,int r,int &amp;cur)    {        cur=++tree_cnt;        treap[cur].build(l,r);        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        build(l,mid,lc[cur]),build(mid+1,r,rc[cur]);    }    int q_rnk(int L,int R,int l,int r,int k,int cur)    {        if(L&lt;=l&amp;&amp;R&gt;=r)  return treap[cur].kth(k)-1;        int mid=(l+r)&gt;&gt;1,ans=0;        if(L&lt;=mid) ans+=q_rnk(L,R,l,mid,k,lc[cur]);        if(R&gt;mid) ans+=q_rnk(L,R,mid+1,r,k,rc[cur]);        return ans;    }    int q_val(int L,int R,int rnk)    {        int l=0,r=1e8,ans;        while(l&lt;=r)        {            int mid=(l+r)&gt;&gt;1;            if(q_rnk(L,R,1,n,mid,root)+1&lt;=rnk) ans=mid,l=mid+1;            else r=mid-1;        }        return ans;    }    void modify(int l,int r,int pos,int k,int cur)    {        treap[cur].del(a[pos]),treap[cur].insert(k);        if(l==r) return;        int mid=(l+r)&gt;&gt;1;        if(pos&lt;=mid) modify(l,mid,pos,k,lc[cur]);        if(pos&gt;mid) modify(mid+1,r,pos,k,rc[cur]);    }    int lower(int L,int R,int l,int r,int k,int cur)    {        if(L&gt;r||R&lt;l) return -inf;        if(L&lt;=l&amp;&amp;R&gt;=r) return treap[cur].pre(k);        int mid=(l+r)&gt;&gt;1;        return max(lower(L,R,l,mid,k,lc[cur]),lower(L,R,mid+1,r,k,rc[cur]));    }    int upper(int L,int R,int l,int r,int k,int cur)    {        if(L&gt;r||R&lt;l) return inf;        if(L&lt;=l&amp;&amp;R&gt;=r) return treap[cur].nxt(k);        int mid=(l+r)&gt;&gt;1;        return min(upper(L,R,l,mid,k,lc[cur]),upper(L,R,mid+1,r,k,rc[cur]));    }}tree;int main(){\tread(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    tree.build(1,n,root);    for(int i=1;i&lt;=m;++i)    {        int opt,l,r,p,k;        read(opt);        if(opt==1)        {            read(l),read(r),read(k);            write(tree.q_rnk(l,r,1,n,k,root)+1),puts(\"\");        }        if(opt==2)        {            read(l),read(r),read(k);            write(tree.q_val(l,r,k)),puts(\"\");        }        if(opt==3)        {            read(p),read(k);            tree.modify(1,n,p,k,root),a[p]=k;        }        if(opt==4)        {            read(l),read(r),read(k);            write(tree.lower(l,r,1,n,k,root)),puts(\"\");        }        if(opt==5)        {            read(l),read(r),read(k);            write(tree.upper(l,r,1,n,k,root)),puts(\"\");        }    }\treturn 0;}\nCDQ åˆ†æ²»ä¸‰ç»´ååºã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define lowbit(x) (x&amp;(-x))using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,k,cnt,tot;int num[maxn],tree[maxn];struct node{\tint a,b,c,val,ans;}p[maxn],q[maxn];bool cmp1(node x,node y){    if(x.a==y.a)    {        if(x.b==y.b) return x.c&lt;y.c;        return x.b&lt;y.b;    }    return x.a&lt;y.a;}bool cmp2(node x,node y){    if(x.b==y.b) return x.c&lt;y.c;    return x.b&lt;y.b;}void update(int x,int v){\twhile(x&lt;=k)\t{\t\ttree[x]+=v;\t\tx+=lowbit(x);\t}}int query(int x){\tint sum=0;\twhile(x)\t{\t\tsum+=tree[x];\t\tx-=lowbit(x);\t}\treturn sum;}void cdq(int l,int r){\tif(l==r) return;\tint mid=(l+r)&gt;&gt;1;\tcdq(l,mid),cdq(mid+1,r);\tsort(q+l,q+mid+1,cmp2);\tsort(q+mid+1,q+r+1,cmp2);\tint j=l;\tfor(int i=mid+1;i&lt;=r;++i)\t{\t\twhile(q[j].b&lt;=q[i].b&amp;&amp;j&lt;=mid)\t\t{\t\t\tupdate(q[j].c,q[j].val);\t\t\tj++;\t\t}\t\tq[i].ans+=query(q[i].c);\t}\tfor(int i=l;i&lt;j;++i) update(q[i].c,-q[i].val);}int main(){\tread(n),read(k);\tfor(int i=1;i&lt;=n;++i)\t\tread(p[i].a),read(p[i].b),read(p[i].c);\tsort(p+1,p+n+1,cmp1);\tfor(int i=1;i&lt;=n;++i)\t{\t\tcnt++;\t\tif(p[i].a!=p[i+1].a||p[i].b!=p[i+1].b||p[i].c!=p[i+1].c)\t\t{\t\t\tq[++tot]=p[i];\t\t\tq[tot].val=cnt;\t\t\tcnt=0;\t\t}\t}\tcdq(1,tot);\tfor(int i=1;i&lt;=tot;++i)\t\tnum[q[i].ans+q[i].val-1]+=q[i].val;\tfor(int i=0;i&lt;n;++i) printf(\"%d\\n\",num[i]);\treturn 0;}\nåˆ†å—void modify(int l,int r,ll v){    for(int i=l;i&lt;=min(S*bel[l],r);++i) a[i]+=v,sum[bel[l]]+=v;    if(bel[l]!=bel[r])        for(int i=S*(bel[r]-1)+1;i&lt;=r;++i)            a[i]+=v,sum[bel[r]]+=v;    for(int i=bel[l]+1;i&lt;=bel[r]-1;++i) add[i]+=v;}ll query(int l,int r){    ll ans=0;    for(int i=l;i&lt;=min(S*bel[l],r);++i) ans+=a[i]+add[bel[l]];    if(bel[l]!=bel[r])        for(int i=S*(bel[r]-1)+1;i&lt;=r;++i)            ans+=a[i]+add[bel[r]];    for(int i=bel[l]+1;i&lt;=bel[r]-1;++i) ans+=sum[i]+S*add[i];    return ans;}......for(int i=1;i&lt;=n;++i)\tread(a[i]),bel[i]=(i-1)/S+1,sum[bel[i]]+=a[i];\nç‚¹åˆ†æ²»æ±‚å‡ºæ ‘ä¸Šä¸¤ç‚¹è·ç¦»å°äºç­‰äº  çš„ç‚¹å¯¹æ•°é‡ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 80010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,k,root,tot,cnt;ll ans;int siz[maxn],mx[maxn],len[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void dfs_root(int x,int fa){    siz[x]=1,mx[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa||vis[y]) continue;        dfs_root(y,x),siz[x]+=siz[y];        mx[x]=max(mx[x],siz[y]);    }    mx[x]=max(mx[x],tot-siz[x]);    if(mx[x]&lt;mx[root]) root=x;}void dfs_get(int x,int fa,int dis){    len[++cnt]=dis;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa||vis[y]) continue;        dfs_get(y,x,dis+e[i].v);    }}ll calc(int x,int dis){    cnt=0,dfs_get(x,0,dis),sort(len+1,len+cnt+1);    ll v=0,pos=cnt;    for(int i=1;i&lt;=cnt;++i)    {        while(pos&amp;&amp;len[i]+len[pos]&gt;k) pos--;        v+=pos-(i&lt;=pos);    }    return v/2;}void solve(int x){    int now=tot;    vis[x]=true,ans+=calc(x,0);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]) continue;        ans-=calc(y,e[i].v);        root=0,tot=siz[y]&gt;siz[x]?now-siz[x]:siz[y];        dfs_root(y,x),solve(root);    }}int main(){    read(n);    for(int i=1;i&lt;n;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    read(k),tot=mx[0]=n,dfs_root(1,0),solve(root),printf(\"%lld\",ans);    return 0;}\nç‚¹åˆ†æ ‘#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 10000010#define mid ((l+r)&gt;&gt;1)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,dfn_cnt,tot,root,ans;int v[maxn],de[maxn],fa[maxn],ma[maxn],siz[maxn],si[maxn];int pos[maxn],f[maxn][20],lg[maxn];bool vis[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}struct node{    int tree_cnt;    int ls[maxm],rs[maxm],rt[maxn],sum[maxm];    void modify(int l,int r,int pos,int v,int &amp;cur)    {        if(!cur) cur=++tree_cnt;        sum[cur]+=v;        if(l==r) return;        if(pos&lt;=mid) modify(l,mid,pos,v,ls[cur]);        else modify(mid+1,r,pos,v,rs[cur]);    }    int query(int L,int R,int l,int r,int cur)    {        if(L&gt;R||!cur) return 0;        if(L&lt;=l&amp;&amp;R&gt;=r) return sum[cur];        int v=0;        if(L&lt;=mid) v+=query(L,R,l,mid,ls[cur]);        if(R&gt;mid) v+=query(L,R,mid+1,r,rs[cur]);        return v;    }}T1,T2;void dfs_pre(int x,int fa){    de[x]=de[fa]+1,f[++dfn_cnt][0]=de[x],pos[x]=dfn_cnt;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_pre(y,x),f[++dfn_cnt][0]=de[x];    }}void st(){    lg[0]=-1;    for(int i=1;i&lt;=dfn_cnt;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int j=1;j&lt;=18;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=dfn_cnt;++i)            f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);}int ask(int x,int y){    int l=pos[x],r=pos[y],len;    if(l&gt;r) swap(l,r);    len=lg[r-l+1];    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);}int dis(int x,int y){    return de[x]+de[y]-2*ask(x,y);}void dfs_root(int x,int fath){    siz[x]=1,ma[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]||y==fath) continue;        dfs_root(y,x),siz[x]+=siz[y],ma[x]=max(ma[x],siz[y]);    }    ma[x]=max(ma[x],tot-siz[x]);    if(ma[x]&lt;ma[root]) root=x;}void solve(int x){    int now=tot;    vis[x]=true,si[x]=now;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(vis[y]) continue;        root=0,tot=siz[y];        if(siz[y]&gt;siz[x]) tot=now-siz[x];        dfs_root(y,x),fa[root]=x,solve(root);    }}void update(int x,int val){    T1.modify(0,si[x],0,val,T1.rt[x]);    for(int i=x;fa[i];i=fa[i])    {        T1.modify(0,si[fa[i]],dis(x,fa[i]),val,T1.rt[fa[i]]);        T2.modify(0,si[fa[i]],dis(x,fa[i]),val,T2.rt[i]);    }}int query(int x,int k){    int v=T1.query(0,k,0,si[x],T1.rt[x]);    for(int i=x;fa[i];i=fa[i])    {        v+=T1.query(0,k-dis(x,fa[i]),0,si[fa[i]],T1.rt[fa[i]]);        v-=T2.query(0,k-dis(x,fa[i]),0,si[fa[i]],T2.rt[i]);    }    return v;}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(v[i]);    for(int i=1;i&lt;n;++i)    {        int x,y;        read(x),read(y);        add(x,y),add(y,x);    }    dfs_pre(1,0),st(),tot=ma[0]=n,dfs_root(1,0),solve(root);    for(int i=1;i&lt;=n;++i) update(i,v[i]);    while(m--)    {        int opt,x,k;        read(opt),read(x),read(k),x^=ans,k^=ans;        if(!opt) printf(\"%d\\n\",ans=query(x,k));        else update(x,k-v[x]),v[x]=k;    }    return 0;}\nç¬›å¡å°”æ ‘void build(){    for(int i=1;i&lt;=n;++i)    {        while(top&amp;&amp;a[st[top]]&gt;a[i]) ls[i]=st[top--];        if(top) rs[st[top]]=i;        st[++top]=i;    }}\nå·¦åæ ‘ç»´æŠ¤  ä¸ªå°æ ¹å †ï¼Œæ”¯æŒå †çš„åˆå¹¶ï¼ŒæŸ¥è¯¢æœ€å°å€¼ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 100010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int fa[maxn],ls[maxn],rs[maxn],dis[maxn],val[maxn];int find(int x){    return fa[x]==x?x:fa[x]=find(fa[x]);}int merge(int x,int y){\tif(!x||!y) return x+y;\tif(val[x]&gt;val[y]) swap(x,y);\trs[x]=merge(rs[x],y),fa[rs[x]]=x;\tif(dis[ls[x]]&lt;dis[rs[x]]) swap(ls[x],rs[x]);\tdis[x]=dis[rs[x]]+1;\treturn x;}void del(int x){    val[x]=-1,fa[ls[x]]=ls[x],fa[rs[x]]=rs[x];    fa[x]=merge(ls[x],rs[x]);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(val[i]),fa[i]=i;    while(m--)    {        int opt,x,y;        read(opt);        if(opt==1)        {            read(x),read(y);            if(val[x]==-1||val[y]==-1) continue;            x=find(x),y=find(y);            if(x!=y) merge(x,y);        }        else        {            read(x);            if(val[x]==-1) puts(\"-1\");            else x=find(x),printf(\"%d\\n\",val[x]),del(x);        }    }    return 0;}\nK-D TreeæŸ¥è¯¢äºŒç»´å¹³é¢ä¸Šæ¬§æ°è·ç¦»ä¸‹çš„ç¬¬  è¿œç‚¹å¯¹ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010#define inf 200000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,k,root,type;struct KD_tree{    ll d[2];    int mi[2],ma[2],ls,rs,id;}t[maxn];bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }}void build(int l,int r,int k,int &amp;cur){    int mid=(l+r)&gt;&gt;1;    cur=mid,type=k;    nth_element(t+l+1,t+mid+1,t+r+1,cmp);    if(l&lt;mid) build(l,mid-1,k^1,t[mid].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[mid].rs);    pushup(cur);}ll calc(ll x){    return x*x;}ll dis(int cur,ll x,ll y){    return calc(t[cur].d[0]-x)+calc(t[cur].d[1]-y);}ll dist(int cur,ll x,ll y){    return max(calc(t[cur].ma[0]-x),calc(t[cur].mi[0]-x))+max(calc(t[cur].ma[1]-y),calc(t[cur].mi[1]-y));}priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; q;void query(int cur,ll x,ll y){    ll d,dl,dr;    int ls=t[cur].ls,rs=t[cur].rs;    d=dis(cur,x,y);    if(d&gt;q.top()) q.pop(),q.push(d);    if(ls) dl=dist(ls,x,y);    else dl=-inf;    if(rs) dr=dist(rs,x,y);    else dr=-inf;    if(dl&gt;q.top()) query(ls,x,y);    if(dr&gt;q.top()) query(rs,x,y);}int main(){\tread(n),read(k);    for(int i=1;i&lt;=n;++i)        read(t[i].d[0]),read(t[i].d[1]);    build(1,n,0,root);    for(int i=1;i&lt;=2*k;++i) q.push(0);    for(int i=1;i&lt;=n;++i)        query(root,t[i].d[0],t[i].d[1]);    printf(\"%lld\",q.top());\treturn 0;}\næŸ¥è¯¢äºŒç»´å¹³é¢ä¸Šæ»¡è¶³ ï¼ˆæ¯æ¬¡è¯¢é—®ç»™å‡º ï¼‰çš„ç‚¹çš„æƒå€¼å’Œã€‚\nstruct KD_tree{    int d[2],mi[2],ma[2],ls,rs,id;    ll val,sum;}t[maxn],dat[maxn];bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }    t[cur].sum=t[ls].sum+t[rs].sum+t[cur].val;}void build(int l,int r,int k,int &amp;cur){    cur=++tot,type=k;    int mid=(l+r)&gt;&gt;1;    nth_element(dat+l,dat+mid,dat+r+1,cmp);    t[cur]=dat[mid];    if(l&lt;mid) build(l,mid-1,k^1,t[cur].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[cur].rs);    pushup(cur);}bool check(ll x,ll y){    return a*x+b*y&lt;c;}ll query(int cur){    ll ans=0;    int ls=t[cur].ls,rs=t[cur].rs,cnt=0;    cnt+=check(t[cur].ma[0],t[cur].ma[1]);    cnt+=check(t[cur].ma[0],t[cur].mi[1]);    cnt+=check(t[cur].mi[0],t[cur].mi[1]);    cnt+=check(t[cur].mi[0],t[cur].ma[1]);    if(cnt==4) return t[cur].sum;    if(!cnt) return 0;    if(check(t[cur].d[0],t[cur].d[1])) ans+=t[cur].val;    if(ls) ans+=query(ls);    if(rs) ans+=query(rs);    return ans;}\næ”¯æŒæ’å…¥ç‚¹å’ŒæŸ¥è¯¢äºŒç»´å¹³é¢ä¸ŠçŸ©å½¢å†…æ‰€æœ‰ç‚¹çš„æƒå€¼å’Œï¼Œå¼ºåˆ¶åœ¨çº¿ï¼Œç”¨  å®ç°ï¼Œå½“ä¸å¹³è¡¡æ—¶ï¼Œåƒæ›¿ç½ªç¾Šæ ‘ä¸€æ ·é‡æ„ã€‚\nstruct KD_tree{    int d[2],mi[2],ma[2],ls,rs,val,sum,siz;}t[maxn],dat[maxn],p;bool cmp(const KD_tree &amp;a,const KD_tree &amp;b){    return a.d[type]&lt;b.d[type];}int add(){    if(top) return st[top--];    return ++tot;}void pushup(int cur){    int ls=t[cur].ls,rs=t[cur].rs;    for(int i=0;i&lt;=1;++i)    {        t[cur].ma[i]=t[cur].mi[i]=t[cur].d[i];        if(ls)        {            t[cur].ma[i]=max(t[cur].ma[i],t[ls].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[ls].mi[i]);        }        if(rs)        {            t[cur].ma[i]=max(t[cur].ma[i],t[rs].ma[i]);            t[cur].mi[i]=min(t[cur].mi[i],t[rs].mi[i]);        }    }    t[cur].sum=t[ls].sum+t[rs].sum+t[cur].val;    t[cur].siz=t[ls].siz+t[rs].siz+1;}void build(int l,int r,int k,int &amp;cur){    cur=add(),type=k;    int mid=(l+r)&gt;&gt;1;    nth_element(dat+l,dat+mid,dat+r+1,cmp);    t[cur]=dat[mid];    t[cur].ls=t[cur].rs=0;    if(l&lt;mid) build(l,mid-1,k^1,t[cur].ls);    if(r&gt;mid) build(mid+1,r,k^1,t[cur].rs);    pushup(cur);}void del(int cur){    if(!cur) return;    dat[++now]=t[cur];    st[++top]=cur;    del(t[cur].ls),del(t[cur].rs);}void check(int &amp;cur,int k){    int ls=t[cur].ls,rs=t[cur].rs;    if(t[cur].siz*alpha&lt;max(t[ls].siz,t[rs].siz))        now=0,del(cur),build(1,t[cur].siz,k,cur);}void insert(KD_tree p,int k,int &amp;cur){    if(!cur)    {        cur=add();        t[cur]=p;        t[cur].ls=t[cur].rs=0;        pushup(cur);        return;    }    if(p.d[k]&lt;=t[cur].d[k]) insert(p,k^1,t[cur].ls);    else insert(p,k^1,t[cur].rs);    pushup(cur);    check(cur,k);}bool check_p(KD_tree p){    return p.d[0]&lt;=bx&amp;&amp;p.d[0]&gt;=ax&amp;&amp;p.d[1]&lt;=by&amp;&amp;p.d[1]&gt;=ay;}bool check_in(KD_tree p){    return p.mi[0]&gt;=ax&amp;&amp;p.ma[0]&lt;=bx&amp;&amp;p.mi[1]&gt;=ay&amp;&amp;p.ma[1]&lt;=by;}bool check_out(KD_tree p){    return p.mi[0]&gt;bx||p.ma[0]&lt;ax||p.mi[1]&gt;by||p.ma[1]&lt;ay;}int query(int cur){    int ls=t[cur].ls,rs=t[cur].rs,val=t[cur].val,sum=t[cur].sum,ans=0;    if(check_in(t[cur])) return sum;    if(check_out(t[cur])) return 0;    if(check_p(t[cur])) ans+=val;    if(ls) ans+=query(ls);    if(rs) ans+=query(rs);    return ans;}\nå›¾è®ºå¼ºè¿é€šåˆ†é‡#include&lt;bits/stdc++.h&gt;#define maxn 200010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt,top,tot,ans;int dfn[maxn],low[maxn],col[maxn],st[maxn],d[maxn];int v[maxn],val[maxn],f[maxn];bool vis[maxn];struct Edge{\tint x,y;}ed[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]},head[from]=edge_cnt;}void tarjan(int x){\tdfn[x]=low[x]=++cnt,vis[st[++top]=x]=true;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);\t\telse if(vis[y]) low[x]=min(low[x],dfn[y]);\t}\tif(dfn[x]==low[x])\t{\t\ttot++;\t\tint now;\t\tdo\t\t{\t\t\tvis[now=st[top--]]=false;\t\t\tval[col[now]=tot]+=v[now]; \t\t}while(now!=x);\t}}void clear(){\tfor(int i=1;i&lt;=n;++i) head[i]=0;\tfor(int i=1;i&lt;=edge_cnt;++i) e[i].nxt=e[i].to=0;\tedge_cnt=0;}void dp(){\tqueue&lt;int&gt; q;\tfor(int i=1;i&lt;=tot;++i)\t{\t\tf[i]=val[i];\t\tif(!d[i]) q.push(i);\t}\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\td[y]--,f[y]=max(f[y],f[x]+val[y]);\t\t\tif(!d[y]) q.push(y);\t\t}\t}\tfor(int i=1;i&lt;=tot;++i) ans=max(ans,f[i]);}int main(){    read(n),read(m);\tfor(int i=1;i&lt;=n;++i) read(v[i]);\tfor(int i=1;i&lt;=m;++i)\t{\t\tread(ed[i].x),read(ed[i].y);\t\tadd(ed[i].x,ed[i].y);\t}\tfor(int i=1;i&lt;=n;++i)\t\tif(!dfn[i])\t\t\ttarjan(i);\tclear();\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x=col[ed[i].x],y=col[ed[i].y];\t\tif(x==y) continue;\t\tadd(x,y),d[y]++;\t}\tdp(),printf(\"%d\",ans);\t    return 0;}\n2-SATvoid tarjan(int x){    dfn[x]=low[x]=++dfn_cnt;    st[++top]=x;    vis[x]=true;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(!dfn[y])        {            tarjan(y);            low[x]=min(low[x],low[y]);        }        else if(vis[y])            low[x]=min(low[x],dfn[y]);    }    if(low[x]==dfn[x])    {        co_cnt++;        int now;        do        {            now=st[top--];            vis[now]=false;            co[now]=co_cnt;        }while(now!=x);    }}bool check(){    for(int i=1;i&lt;=2*n;++i)        if(!dfn[i])            tarjan(i);    for(int i=1;i&lt;=n;++i)        if(co[i]==co[i+n])            return false;    return true;}......add(x+(a^1)*n,y+b*n),add(y+(b^1)*n,x+a*n);\nç‚¹åŒè¿é€šåˆ†é‡void tarjan(int x,int root){\tint son=0;\tdfn[x]=low[x]=++dfn_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y])\t\t{\t\t\ttarjan(y,root),low[x]=min(low[x],low[y]);\t\t\tif(x!=root&amp;&amp;dfn[x]&lt;=low[y]) cut[x]=true;\t\t\tif(x==root) son++;\t\t}\t\telse low[x]=min(low[x],dfn[y]);\t}\tif(son&gt;1) cut[x]=true;}......for(int i=1;i&lt;=n;++i)    if(!dfn[i])        tarjan(i,i);\næ±‚å‰²ç‚¹æ—¶ç»´æŠ¤ä¸€ä¸ªæ ˆå³å¯æ±‚å‡ºæ¯ä¸ªç‚¹åŒè¿é€šåˆ†é‡ã€‚å½“  æ»¡è¶³ä¸ºå‰²ç‚¹æ—¶ï¼Œå°±ä¾æ¬¡å¼¹æ ˆï¼Œç›´åˆ°å¼¹å‡º  å°±åœæ­¢ï¼Œ è¿˜éœ€ç•™åœ¨æ ˆä¸­ï¼Œå› ä¸ºå‰²ç‚¹  å¯èƒ½å±äºå¤šä¸ªç‚¹åŒè¿é€šåˆ†é‡ã€‚\nvoid tarjan(int x){    dfn[x]=low[x]=++dfn_cnt,st[++top]=x;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(!dfn[y])        {            tarjan(y),low[x]=min(low[x],low[y]);            if(dfn[x]&lt;=low[y])            {                col_cnt++;                int now;                do now=st[top--],col[now]=col_cnt; while(now!=y);            }        }        else low[x]=min(low[x],dfn[y]);    }}\nè¾¹åŒè¿é€šåˆ†é‡void tarjan(int x,int link){\tdfn[x]=low[x]=++dfn_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(!dfn[y])\t\t{\t\t\ttarjan(y,i),low[x]=min(low[x],low[y]);\t\t\tif(dfn[x]&lt;low[y]) bri[i]=bri[i^1]=true;\t\t}\t\telse if(i!=(link^1)) low[x]=min(low[x],dfn[y]);\t}}void dfs_col(int x){\tcol[x]=co_cnt;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(col[y]||bri[i]) continue;\t\tdfs_col(y);\t}}......for(int i=1;i&lt;=n;++i)\tif(!dfn[i])\t\ttarjan(i,0);for(int i=1;i&lt;=n;++i)    if(!col[i])\t    col_cnt++,dfs_col(i);\næœ€çŸ­è·¯spfa\n#include&lt;bits/stdc++.h&gt;#define maxn 15010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void spfa(){    queue&lt;int&gt; q;    for(int i=1;i&lt;=n;++i) dis[i]=inf;    q.push(s),dis[s]=0,vis[s]=true;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)            {                dis[y]=dis[x]+v;                if(!vis[y]) q.push(y),vis[y]=true;            }        }    }}int main(){    read(n),read(m),read(s),read(t);    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    spfa(),printf(\"%lld\",dis[t]);    return 0;}\ndijkstra\n#include&lt;bits/stdc++.h&gt;#define maxn 15010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;}void dij(){    priority_queue&lt;pair&lt;ll,int&gt; &gt; q;    for(int i=1;i&lt;=n;++i) dis[i]=inf;    q.push({0,s}),dis[s]=0;    while(!q.empty())    {        int x=q.top().second;        q.pop();        if(vis[x]) continue;        vis[x]=true;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)                dis[y]=dis[x]+v,q.push({-dis[y],y});        }    }}int main(){    read(n),read(m),read(s),read(t);    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v);    }    dij(),printf(\"%lld\",dis[t]);    return 0;}\nè´Ÿç¯#include&lt;bits/stdc++.h&gt;#define maxn 10010#define inf 1000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int T,n,m;int cnt[maxn],dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]={to,head[from],val},head[from]=edge_cnt;    if(val&gt;=0) e[++edge_cnt]={from,head[to],val},head[to]=edge_cnt;}bool spfa(){    for(int i=1;i&lt;=n;++i) cnt[i]=vis[i]=0,dis[i]=inf;    queue&lt;int&gt; q;    q.push(1),vis[1]=true,dis[1]=0;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        if(++cnt[x]&gt;n) return true;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to,v=e[i].v;            if(dis[y]&gt;dis[x]+v)            {                dis[y]=dis[x]+v;                if(!vis[y]) q.push(y),vis[y]=true;            }        }    }    return false;}int main(){    read(T);    while(T--)    {        read(n),read(m);        edge_cnt=0,memset(head,0,sizeof(head));        for(int i=1;i&lt;=m;++i)        {            int x,y,v;            read(x),read(y),read(v);            add(x,y,v);        }        puts(spfa()?\"YES\":\"NO\");    }    return 0;}\nLCAé‡é“¾å‰–åˆ†\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s;struct edge{\tint to;\tint nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=(edge){to,head[from]};\thead[from]=edge_cnt;}int fa[maxn],siz[maxn],de[maxn],son[maxn];void dfs_son(int x,int fath){\tfa[x]=fath;\tsiz[x]=1;\tde[x]=de[fath]+1;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fath) continue;\t\tdfs_son(y,x);\t\tsiz[x]+=siz[y];\t\tif(siz[y]&gt;siz[son[x]]) son[x]=y;\t}}int top[maxn],dfn[maxn];int dfn_cnt;void dfs_chain(int x,int tp){\ttop[x]=tp;\tdfn[x]=++dfn_cnt;\tif(son[x]) dfs_chain(son[x],tp);\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(dfn[y]) continue;\t\tdfs_chain(y,y);\t}}int lca(int x,int y){\twhile(top[x]!=top[y])\t{\t\tif(de[top[x]]&lt;de[top[y]]) swap(x,y);\t\tx=fa[top[x]];\t}\tif(de[x]&gt;de[y]) swap(x,y);\treturn x;}int main(){\tread(n),read(m),read(s);\tfor(int i=1;i&lt;n;++i)\t{\t\tint a,b;\t\tread(a),read(b);\t\tadd(a,b),add(b,a);\t}\tdfs_son(s,0);\tdfs_chain(s,s);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint a,b;\t\tread(a),read(b);\t\tprintf(\"%d\\n\",lca(a,b));\t}\treturn 0;}\nST è¡¨\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,rt,cnt;int pos[maxn],dep[maxn],lg[maxn];pair&lt;int,int&gt; f[22][maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}void dfs(int x,int fa){\tdep[x]=dep[fa]+1,f[0][pos[x]=++cnt]={dep[x],x};\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fa) continue;\t\tdfs(y,x),f[0][++cnt]={dep[x],x};\t}}void ST(){\tlg[0]=-1;\tfor(int i=1;i&lt;=cnt;++i) lg[i]=lg[i&gt;&gt;1]+1;\tfor(int j=1;j&lt;=19;++j)\t\tfor(int i=1;i+(1&lt;&lt;j)-1&lt;=cnt;++i)\t\t\tf[j][i]=min(f[j-1][i],f[j-1][i+(1&lt;&lt;(j-1))]);\t}int ask(int l,int r){\tl=pos[l],r=pos[r];\tif(l&gt;r) swap(l,r);\tint len=lg[r-l+1];\treturn min(f[len][l],f[len][r-(1&lt;&lt;len)+1]).second;}int main(){\tread(n),read(m),read(rt);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs(rt,0),ST();\twhile(m--)\t{\t\tint x,y;\t\tread(x),read(y),printf(\"%d\\n\",ask(x,y));\t}    return 0;}\næœ€å¤§æµ#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;int d[maxn],cur[maxn];struct edge{\tint to,nxt;\tll v;\tedge(int a=0,int b=0,ll c=0)\t{\t\tto=a,nxt=b,v=c;\t}}e[maxn];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=edge(to,head[from],val),head[from]=edge_cnt;\te[++edge_cnt]=edge(from,head[to],0),head[to]=edge_cnt;}bool bfs(){\tfor(int i=1;i&lt;=n;++i) cur[i]=head[i],d[i]=0;\tqueue&lt;int&gt; q;\tq.push(s),d[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\tif(d[y]||!e[i].v) continue;\t\t\td[y]=d[x]+1,q.push(y);\t\t}\t}\treturn d[t];}ll dfs(int x,ll lim){\tif(x==t) return lim;\tll res=lim,flow;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tll v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(flow=dfs(y,min(res,v)))\t\t{\t\t\tres-=flow,e[i].v-=flow,e[i^1].v+=flow;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}ll dinic(){\tll v=0,flow;\twhile(bfs())\t\twhile(flow=dfs(s,inf))\t\t\tv+=flow;\treturn v;}int main(){\tread(n),read(m),read(s),read(t);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y,v;\t\tread(x),read(y),read(v),add(x,y,v);\t}\tprintf(\"%lld\",dinic());    return 0;}\næœ€å°è´¹ç”¨æœ€å¤§æµ#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t;ll ans,sum;ll dis[maxn];bool vis[maxn];struct edge{\tint to,nxt;\tll v,c;\tedge(int x=0,int y=0,ll z=0,ll w=0)\t{\t\tto=x,nxt=y,v=z,c=w;\t}}e[maxn];int head[maxn],edge_cnt=1;void add(int from,int to,int val,int cost){\te[++edge_cnt]=edge(to,head[from],val,cost),head[from]=edge_cnt;\te[++edge_cnt]=edge(from,head[to],0,-cost),head[to]=edge_cnt;}bool bfs(){\tfor(int i=1;i&lt;=n;++i) dis[i]=inf,vis[i]=false;\tqueue&lt;int&gt; q;\tq.push(s),dis[s]=0,vis[s]=true;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop(),vis[x]=false;\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to;\t\t\tll c=e[i].c;\t\t\tif(dis[y]&lt;=dis[x]+c||!e[i].v) continue;\t\t\tdis[y]=dis[x]+c;\t\t\tif(!vis[y]) vis[y]=true,q.push(y);\t\t}\t}\treturn dis[t]!=inf;}ll dfs(int x,ll lim){\tif(x==t) return lim;\tvis[x]=true;\tll res=lim,flow;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tll v=e[i].v;\t\tif(dis[y]!=dis[x]+e[i].c||!v||vis[y]) continue;\t\tif(flow=dfs(y,min(res,v)))\t\t{\t\t\tres-=flow,e[i].v-=flow,e[i^1].v+=flow;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}void dinic(){\tll flow;\twhile(bfs())\t\twhile(flow=dfs(s,inf))\t\t\tans+=flow,sum+=flow*dis[t];}int main(){\tread(n),read(m),s=1,t=n;\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y,v,w;\t\tread(x),read(y),read(v),read(w);\t\tadd(x,y,v,w);\t}\tdinic(),printf(\"%lld %lld\",ans,sum);    return 0;}\næ— æºæ±‡æœ‰ä¸Šä¸‹ç•Œå¯è¡Œæµ#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 1002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn],low[maxn];bool bfs(){\tfor(int i=s;i&lt;=t;++i) cur[i]=head[i];\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(res&lt;=0) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,ans=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tans+=k; \t\t}\t}\treturn ans;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,high;        read(a),read(b),read(low[i]),read(high);        in[a]-=low[i],in[b]+=low[i];        add(a,b,high-low[i]);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    dinic();    if(check())     {        puts(\"YES\");        for(int i=1;i&lt;=m;i++) printf(\"%d\\n\",e[(i&lt;&lt;1)^1].v+low[i]);    }    else puts(\"NO\");\treturn 0;}\næœ‰æºæ±‡æœ‰ä¸Šä¸‹ç•Œæœ€å¤§æµ#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 1002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t,S,T,ans;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn],low[maxn];bool bfs(){\tmemcpy(cur,head,sizeof(head));\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(res&lt;=0) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,flow=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tflow+=k; \t\t}\t}\treturn flow;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),read(S),read(T),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,up;        read(a),read(b),read(low[i]),read(up);        in[a]-=low[i],in[b]+=low[i];        add(a,b,up-low[i]);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    add(T,S,inf);    dinic();    ans=e[edge_cnt].v;    e[edge_cnt].v=e[edge_cnt^1].v=0;    if(check())     {        s=S,t=T;        printf(\"%d\",ans+dinic());    }    else puts(\"please go home to sleep\");\treturn 0;}\næœ‰æºæ±‡æœ‰ä¸Šä¸‹ç•Œæœ€å°æµ#include&lt;bits/stdc++.h&gt;#define maxn 500010#define maxm 5002010#define inf 2000000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,s,t,S,T;struct edge{\tint to,nxt,v;}e[maxm];int head[maxn],edge_cnt=1;void add(int from,int to,int val){\te[++edge_cnt]=(edge){to,head[from],val};\thead[from]=edge_cnt;\te[++edge_cnt]=(edge){from,head[to],0};\thead[to]=edge_cnt;}int d[maxn],cur[maxn],in[maxn];bool bfs(){\tfor(int i=0;i&lt;=n+1;++i) cur[i]=head[i];\tmemset(d,0,sizeof(d));\tqueue&lt;int&gt; q;\tq.push(s);\td[s]=1;\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=head[x];i;i=e[i].nxt)\t\t{\t\t\tint y=e[i].to,v=e[i].v;\t\t\tif(d[y]||!v) continue;\t\t\tq.push(y);\t\t\td[y]=d[x]+1;\t\t}\t}\treturn d[t];}int dfs(int x,int lim){\tif(x==t) return lim;\tint res=lim,k;\tfor(int &amp;i=cur[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to,v=e[i].v;\t\tif(d[y]!=d[x]+1||!v) continue;\t\tif(k=dfs(y,min(res,v)))\t\t{\t\t\tres-=k;\t\t\te[i].v-=k;\t\t\te[i^1].v+=k;\t\t\tif(!res) break;\t\t}\t}\treturn lim-res;}int dinic(){\tint k,flow=0;\twhile(bfs())\t{\t\twhile(k=dfs(s,inf))\t\t{\t\t\tflow+=k; \t\t}\t}\treturn flow;}bool check(){    for(int i=head[s];i;i=e[i].nxt)        if(e[i].v)            return false;    return true;}int main(){\tread(n),read(m),read(S),read(T),t=n+1;    for(int i=1;i&lt;=m;++i)    {        int a,b,up,low;        read(a),read(b),read(low),read(up);        in[a]-=low,in[b]+=low;        add(a,b,up-low);    }    for(int i=1;i&lt;=n;i++)    {           if(in[i]&gt;0) add(s,i,in[i]);        else add(i,t,-in[i]);    }    dinic();    add(T,S,inf);    dinic();    if(!check())    {        puts(\"please go home to sleep\");        return 0;    }    printf(\"%d\",e[edge_cnt].v);\treturn 0;}\næœ€å¤§è´¹ç”¨å¾ªç¯æµå¯¹äºè¾¹ ï¼Œè‹¥è´¹ç”¨ä¸ºæ­£ï¼Œåˆ™å°†å…¶å…ˆæµæ»¡ï¼Œè®°å½•è´¹ç”¨æ€»å’Œ ï¼Œé€šè¿‡å»ºç«‹æºæ±‡ç‚¹æ¥å®ç°è¡¥æµï¼Œè¾¹æ­£å¸¸è¿ã€‚è‹¥è´¹ç”¨ä¸ºè´Ÿï¼Œåˆ™è¿è¾¹ ã€‚ç„¶åè·‘æœ€å°è´¹ç”¨æœ€å¤§æµå¾—å‡ºè´¹ç”¨ ï¼Œæœ€ç»ˆæœ€å¤§è´¹ç”¨å¾ªç¯æµæ±‚è§£çš„ç­”æ¡ˆä¸º ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define maxm 5000010#define inf 1000000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int T,n,m,s,t;ll ans;int in[maxn],de[maxn];ll dis[maxn];bool vis[maxn];struct edge{    int to,nxt,v;    ll c;}e[maxm];int head[maxn],edge_cnt;void add(int from,int to,int val,int cost){    e[++edge_cnt]=(edge){to,head[from],val,cost};\thead[from]=edge_cnt;    e[++edge_cnt]=(edge){from,head[to],0,-cost};\thead[to]=edge_cnt;}void Add(int from,int to,int val,ll cost){    in[from]+=val,in[to]-=val,ans+=cost,add(from,to,val,cost);}struct Edge{    int to,nxt,v;}ed[maxn];int hd[maxn],e_cnt;void link(int from,int to,int val){    ed[++e_cnt]=(Edge){to,hd[from],val};    hd[from]=e_cnt;}void dfs_pre(int x,int fa){\tde[x]=de[fa]+1;\tfor(int i=hd[x];i;i=ed[i].nxt)\t{\t\tint y=ed[i].to;\t\tif(y==fa) continue;        Add(x,y,ed[i].v,0),dfs_pre(y,x);\t}\t}bool spfa(){    for(int i=s;i&lt;=t;++i) vis[i]=0,dis[i]=inf;    queue&lt;int&gt; q;    q.push(s),dis[s]=0,vis[s]=true;    while(!q.empty())    {        int x=q.front();        q.pop(),vis[x]=false;        for(int i=head[x];i;i=e[i].nxt)        {            int y=e[i].to;            ll v=e[i].v,c=e[i].c;            if(dis[y]&gt;dis[x]+c&amp;&amp;v)            {                dis[y]=dis[x]+c;                if(!vis[y])                {                    vis[y]=true;                    q.push(y);                }            }        }    }    return dis[t]!=inf;}ll dfs(int x,ll lim){    if(x==t) return lim;    vis[x]=true;    ll res=lim,flow;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v,c=e[i].c;        if(dis[y]!=dis[x]+c||!v||vis[y]) continue;        if(flow=dfs(y,min(res,v)))        {            res-=flow;            e[i].v-=flow;            e[i^1].v+=flow;            if(!res) break;        }    }    return lim-res;}ll dinic(){    ll flow,sum=0;    while(spfa())        while(flow=dfs(s,inf))            sum+=flow*dis[t];    return sum;}void clear(){    e_cnt=ans=0,edge_cnt=1;    memset(in,0,sizeof(in));    memset(hd,0,sizeof(hd));    memset(head,0,sizeof(head));}int main(){    read(T);    while(T--)    {        clear(),read(n),read(m),t=n+1;        for(int i=1;i&lt;n;++i)        {            int x,y,v;            read(x),read(y),read(v);            link(x,y,v),link(y,x,v);        }        dfs_pre(1,0);        for(int i=1;i&lt;=m;++i)        {            int x,y,v;            read(x),read(y),read(v);            if(de[x]&lt;de[y]) swap(x,y);            Add(x,y,1,v);        }        for(int i=1;i&lt;=n;++i)        {            if(in[i]&gt;0) add(s,i,in[i],0);            else add(i,t,-in[i],0);        }        printf(\"%lld\\n\",ans-dinic());    }    return 0;}\næœ€å°å‰²æ ‘é€šè¿‡å»ºæœ€å°å‰²æ ‘æ¥å¿«é€Ÿæ±‚è§£æ— å‘å›¾ä¸­ä¸¤ç‚¹é—´çš„æœ€å°å‰²ã€‚æœ€å°å‰²æ ‘ä¸­çš„ä¸€æ¡è¾¹çš„æƒå€¼ï¼Œä¸ºå…¶ä¸¤ç«¯ç‚¹çš„æœ€å°å‰²ï¼Œé‚£ä¹ˆä»»æ„ä¸¤ç‚¹ä¹‹é—´çš„æœ€å°å‰²å³ä¸ºè·¯å¾„ä¸Šçš„æœ€å°å€¼ã€‚é€šè¿‡é€’å½’å»ºæ ‘å³å¯ã€‚\nvoid build(int l,int r){    if(l==r) return;    s=p[l],t=p[l+1];    int v=F.dinic(),cnt1=0,cnt2=0;    add(s,t,v),add(t,s,v);    for(int i=l;i&lt;=r;++i)    {        int x=p[i];        if(F.d[x]) p1[++cnt1]=x;        else p2[++cnt2]=x;    }    for(int i=1;i&lt;=cnt1;++i) p[l+i-1]=p1[i];    for(int i=1;i&lt;=cnt2;++i) p[l+cnt1+i-1]=p2[i];    build(l,l+cnt1-1),build(l+cnt1,r);}\næ ‘çš„ç›´å¾„å¯ä»¥é€šè¿‡ä¸¤æ¬¡  æˆ–  æ±‚å‡ºæ ‘çš„ç›´å¾„ï¼Œä»ä»»æ„ç»“ç‚¹å‡ºå‘ï¼Œæœç´¢å¾—å‡ºç›´å¾„çš„ä¸€ä¸ªç«¯ç‚¹ï¼Œç„¶åä»è¿™ä¸ªç«¯ç‚¹ç»§ç»­æœç´¢ï¼Œå¾—å‡ºå¦ä¸€ä¸ªç«¯ç‚¹ï¼Œä½†æ— æ³•å¤„ç†è´Ÿè¾¹æƒã€‚ä¹Ÿå¯ä»¥ç”¨æ ‘å½¢æ±‚ç›´å¾„ï¼Œè€ƒè™‘æ¯ä¸ªç»“ç‚¹ï¼Œæ±‚å‡ºç»è¿‡ç»“ç‚¹çš„æœ€é•¿é“¾é•¿åº¦ï¼Œåˆ™æ ‘çš„ç›´å¾„é•¿åº¦å°±æ˜¯è¿™äº›æœ€é•¿é“¾é•¿åº¦çš„æœ€å¤§å€¼ï¼Œä½†æ— æ³•æ±‚å‡ºç›´å¾„çš„ç«¯ç‚¹ã€‚\nvoid dp(int x,int fa){    for(int i=head[x];i;i=e[i].nxt)\t{        int y=e[i].to,v=e[i].v;\t\tif(y==fa) continue;        dp(y,x);        maxd=max(maxd,dis[x]+dis[y]+v);        dis[x]=max(dis[x],dis[y]+v);    }}\næ ‘ä¸Š k çº§ç¥–å…ˆ#include&lt;bits/stdc++.h&gt;#define maxn 500010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,q,root,cnt;ll ans,last;int son[maxn],top[maxn],de[maxn],dep[maxn];int lg[maxn],f[maxn][22],u[maxn],d[maxn],dfn[maxn];unsigned int s;struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}unsigned int get(){    s^=s&lt;&lt;13,s^=s&gt;&gt;17,s^=s&lt;&lt;5;\treturn s; }void dfs_son(int x){    de[x]=dep[x]=de[f[x][0]]+1;    for(int i=1;i&lt;=19;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        dfs_son(y),dep[x]=max(dep[x],dep[y]);        if(dep[y]&gt;dep[son[x]]) son[x]=y;    }}void dfs_dfn(int x,int tp,int anc){    top[x]=tp,dfn[x]=++cnt,u[cnt]=anc,d[cnt]=x;    if(son[x]) dfs_dfn(son[x],tp,f[anc][0]);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==son[x]) continue;        dfs_dfn(y,y,y);    }}int ask(int x,int k){    if(!k) return x;    x=f[x][lg[k]],k-=(1&lt;&lt;lg[k])+de[x]-de[top[x]],x=top[x];    if(k&gt;=0) return u[dfn[x]+k];    else return d[dfn[x]-k];}int main(){    read(n),read(q),read(s),lg[0]=-1;    for(int i=1;i&lt;=n;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int i=1;i&lt;=n;++i)    {        read(f[i][0]);        if(!f[i][0]) root=i;        else add(f[i][0],i);    }    dfs_son(root),dfs_dfn(root,root,root);    for(int i=1;i&lt;=q;++i)    {        int x=(get()^last)%n+1,k=(get()^last)%de[x];        last=ask(x,k),ans^=last*i;    }    printf(\"%lld\",ans);    return 0;}\næ— å‘å›¾ä¸‰å…ƒç¯è®¡æ•°for(int i=1;i&lt;=m;++i){    int x=ed[i].x,y=ed[i].y;    if(deg[x]&gt;deg[y]||(deg[x]==deg[y]&amp;&amp;x&gt;y)) swap(x,y);    add(x,y);}for(int x=1;x&lt;=n;++x){    for(int i=head[x];i;i=e[i].nxt) vis[e[i].to]=x;    for(int i=head[x];i;i=e[i].nxt)        for(int j=head[e[i].to];j;j=e[j].nxt)            if(vis[e[j].to]==x)                ans++;}\næ¬§æ‹‰å›è·¯ ä¸ºæ— å‘å›¾ï¼Œ ä¸ºæœ‰å‘å›¾ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 400010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,s,t,cnt;int deg[maxn],p[maxn];bool vis[maxn];struct edge{    int to,nxt;    edge(int a=0,int b=0)    {        to=a,nxt=b;    }}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void dfs1(int x){    for(int &amp;i=head[x];i;i=e[i].nxt)    {        if(vis[i]) continue;        int l=i;        vis[i]=vis[i^1]=true,dfs1(e[i].to),p[++cnt]=l&amp;1?-(l&gt;&gt;1):(l&gt;&gt;1);    }}void dfs2(int x){    for(int &amp;i=head[x];i;i=e[i].nxt)    {        if(vis[i]) continue;        int l=i;        vis[i]=true,dfs2(e[i].to),p[++cnt]=l;    }}bool check(){    for(int i=1;i&lt;=n;++i)        if(deg[i])            return false;    return true;}int main(){    read(t),read(n),read(m),edge_cnt=t==1;    for(int i=1;i&lt;=m;++i)    {        int x,y;        read(y),read(x),add(x,y),s=x;        if(t==1) add(y,x),deg[x]^=1,deg[y]^=1;        else deg[x]++,deg[y]--;    }    if(!check())    {        puts(\"NO\");        return 0;    }       if(t==1) dfs1(s);    else dfs2(s);    if(cnt!=m)    {        puts(\"NO\");        return 0;    }    puts(\"YES\");    for(int i=1;i&lt;=m;++i) printf(\"%d \",p[i]);    return 0;}\nKruskal é‡æ„æ ‘ç”¨  æ„å»ºç”Ÿæˆæ ‘çš„é¡ºåºæ¥æ„å»º  é‡æ„æ ‘ã€‚ä¸¤ä¸ªè¿é€šå—åˆå¹¶æ—¶ï¼Œæ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œç‚¹æƒä¸ºè”é€šè¿™ä¸¤ä¸ªè¿é€šå—è¾¹çš„è¾¹æƒï¼Œæ–°èŠ‚ç‚¹å‘ä¸¤ä¸ªè¿é€šå—çš„æ ¹è¿è¾¹ï¼Œæ–°èŠ‚ç‚¹ä¸ºåˆå¹¶åçš„è¿é€šå—çš„æ ¹ã€‚å¾—åˆ°çš„æ ‘ä¸ºæœ‰  ä¸ªå¶å­èŠ‚ç‚¹çš„äºŒå‰æ ‘ï¼Œå…¶æ»¡è¶³å †çš„æ€§è´¨ã€‚æ±‚ä¸€ä¸ªç‚¹  åœ¨åªç»è¿‡è¾¹æƒä¸å¤§äº  çš„è¾¹æ‰€èƒ½åˆ°è¾¾çš„ç‚¹ã€‚è¾¹æƒä»å°åˆ°å¤§æ’åºï¼Œå»º  é‡æ„æ ‘ï¼Œå¾—åˆ°çš„æ˜¯ä¸€ä¸ªå¤§æ ¹å †ï¼Œä»  å‘ä¸Šå€å¢ï¼Œåˆ°è¾¾æ»¡è¶³ç‚¹æƒä¸å¤§äº  æ·±åº¦æœ€æµ…çš„èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹å­æ ‘ä¸­çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹  éƒ½å¯åˆ°è¾¾ã€‚\nfor(int i=1;i&lt;=m;++i){    int x=find(ed[i].x),y=find(ed[i].y);    if(x==y) continue;    val[++tot]=ed[i].v,add(tot,x),add(tot,y);    fa[x]=fa[y]=f[x][0]=f[y][0]=tot;    if(tot==2*n-1) break;}\né™æ€ä»™äººæŒè¯¢é—®ä¸¤ç‚¹æœ€çŸ­è·¯ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 40010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,q,tot,dfn_cnt;int dfn[maxn],low[maxn],fa[maxn],pre[maxn],sum[maxn],dis[maxn],de[maxn],f[maxn][18];struct node{    struct edge    {        int to,nxt,v;    }e[maxn];    int head[maxn],edge_cnt;    void add(int from,int to,int val)    {        e[++edge_cnt]=(edge){to,head[from],val};        head[from]=edge_cnt;    }}T1,T2;void build(int x,int y,int v){    int s=v;    for(int i=y;i!=fa[x];i=fa[i]) sum[i]=s,s+=pre[i];    sum[++tot]=sum[x],sum[x]=0;    for(int i=y;i!=fa[x];i=fa[i])        T2.add(tot,i,min(sum[i],sum[tot]-sum[i])),T2.add(i,tot,min(sum[i],sum[tot]-sum[i]));}void tarjan(int x,int fath){    dfn[x]=low[x]=++dfn_cnt;    for(int i=T1.head[x];i;i=T1.e[i].nxt)    {        int y=T1.e[i].to,v=T1.e[i].v;        if(y==fath) continue;        if(!dfn[y])        {            fa[y]=x,pre[y]=v,tarjan(y,x);            low[x]=min(low[x],low[y]);        }        else low[x]=min(low[x],dfn[y]);        if(dfn[x]&lt;low[y]) T2.add(x,y,v),T2.add(y,x,v);    }    for(int i=T1.head[x];i;i=T1.e[i].nxt)    {        int y=T1.e[i].to;        if(fa[y]!=x&amp;&amp;dfn[x]&lt;dfn[y])            build(x,y,T1.e[i].v);    }}void dfs(int x,int fath){    f[x][0]=fath,de[x]=de[fath]+1;    for(int i=1;i&lt;=15;++i) f[x][i]=f[f[x][i-1]][i-1];    for(int i=T2.head[x];i;i=T2.e[i].nxt)    {        int y=T2.e[i].to;        if(y==fath) continue;        dis[y]=dis[x]+T2.e[i].v,dfs(y,x);    }}int lca(int x,int y){    if(de[x]&lt;de[y]) swap(x,y);    for(int i=15;i&gt;=0;--i)        if(de[f[x][i]]&gt;=de[y])            x=f[x][i];    if(x==y) return x;    for(int i=15;i&gt;=0;--i)        if(f[x][i]!=f[y][i])            x=f[x][i],y=f[y][i];    return f[x][0];}int find(int x,int k){    for(int i=0;i&lt;=15;++i)        if(k&amp;(1&lt;&lt;i))            x=f[x][i];    return x;}int main(){    read(n),read(m),read(q),tot=n;    for(int i=1;i&lt;=m;++i)    {        int x,y,v;        read(x),read(y),read(v);        T1.add(x,y,v),T1.add(y,x,v);    }    tarjan(1,0),dfs(1,0);    while(q--)    {        int x,y,anc;        read(x),read(y),anc=lca(x,y);        if(anc&lt;=n) printf(\"%d\\n\",dis[x]+dis[y]-dis[anc]*2);        else        {            int sx=find(x,de[x]-de[anc]-1),sy=find(y,de[y]-de[anc]-1);            if(sum[sx]&lt;sum[sy]) swap(sx,sy);            printf(\"%d\\n\",dis[x]-dis[sx]+dis[y]-dis[sy]+min(sum[sx]-sum[sy],sum[anc]+sum[sy]-sum[sx]));        }    }    return 0;}\nè™šæ ‘ç»™å‡ºä¸€æ£µå•ä½è¾¹æƒçš„æ ‘å’Œè‹¥å¹²å…³é”®ç‚¹ï¼Œæ±‚å‡ºæ¯ä¸¤ä¸ªå…³é”®ç‚¹é—´çš„è·ç¦»ä¹‹å’Œä»¥åŠè·ç¦»æœ€å¤§ã€æœ€å°å€¼ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010#define inf 200000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,q;ll ans,tot,maxd,mind;ll dma[maxn],dmi[maxn];bool flag;int query[maxn];struct edge{    int to,nxt;    ll v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,ll val=0){    e[++edge_cnt]=(edge){to,head[from],val};    head[from]=edge_cnt;}int dfn_cnt;int dfn[maxn],top_fa[maxn],fa[maxn],son[maxn];ll de[maxn],siz[maxn];void dfs_son(int x,int fath){    siz[x]=1;    fa[x]=fath;    de[x]=de[fath]+1;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fath) continue;        dfs_son(y,x);        siz[x]+=siz[y];        if(siz[son[x]]&lt;siz[y]) son[x]=y;    }}void dfs_chain(int x,int tp){    dfn[x]=++dfn_cnt,top_fa[x]=tp;    if(son[x]) dfs_chain(son[x],tp);    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(dfn[y]) continue;        dfs_chain(y,y);    }}int lca(int x,int y){    while(top_fa[x]!=top_fa[y])    {        if(de[top_fa[x]]&lt;de[top_fa[y]]) swap(x,y);        x=fa[top_fa[x]];    }    if(dfn[x]&gt;dfn[y]) swap(x,y);    return x;}ll dis(int x,int y){    return de[x]+de[y]-de[lca(x,y)]*2;}bool cmp(const int &amp;a,const int &amp;b){    return dfn[a]&lt;dfn[b];}int st[maxn],top;void insert(int x){    if(x==1) return;    if(top==1)    {        st[++top]=x;        return;    }    int anc=lca(x,st[top]);    if(anc==st[top])    {        st[++top]=x;        return;    }    while(top&gt;1&amp;&amp;dfn[anc]&lt;=dfn[st[top-1]])         add(st[top-1],st[top],dis(st[top-1],st[top])),top--;    if(anc!=st[top]) add(anc,st[top],dis(anc,st[top])),st[top]=anc;    st[++top]=x;}bool vis[maxn];void dp(int x){    dma[x]=-inf,dmi[x]=inf;    if(vis[x]) dma[x]=dmi[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        dp(y);        maxd=max(maxd,dma[x]+dma[y]+v);        dma[x]=max(dma[x],dma[y]+v);        mind=min(mind,dmi[x]+dmi[y]+v);        dmi[x]=min(dmi[x],dmi[y]+v);    }}void dfs_ans(int x){    if(vis[x]) siz[x]=1;    else siz[x]=0;    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        dfs_ans(y);        siz[x]+=siz[y];        ans+=siz[y]*(tot-siz[y])*v;    }    head[x]=0;}void clear(){    edge_cnt=0;    memset(siz,0,sizeof(siz));    memset(head,0,sizeof(head));}int main(){\tread(n);    for(int i=1;i&lt;n;++i)    {        int a,b;        read(a),read(b);        add(a,b),add(b,a);    }    dfs_son(1,0),dfs_chain(1,1),clear();    read(q);    while(q--)    {        int k;        read(k);        tot=k;        edge_cnt=ans=0;        mind=inf,maxd=-inf;        for(int i=1;i&lt;=k;++i)        {            read(query[i]);            vis[query[i]]=true;        }        sort(query+1,query+k+1,cmp);        st[top=1]=1;        for(int i=1;i&lt;=k;++i) insert(query[i]);        while(top) add(st[top-1],st[top],dis(st[top-1],st[top])),top--;        dp(1),dfs_ans(1);        for(int i=1;i&lt;=k;++i) vis[query[i]]=false;        printf(\"%lld %lld %lld\\n\",ans,mind,maxd);    }\treturn 0;}\næœ€å°æ ‘å½¢å›¾ç»™å®šåŒ…å«  ä¸ªç»“ç‚¹ï¼Œ  æ¡æœ‰å‘è¾¹çš„ä¸€ä¸ªå›¾ã€‚è¯•æ±‚ä¸€æ£µä»¥ç»“ç‚¹  ä¸ºæ ¹çš„æœ€å°æ ‘å½¢å›¾ï¼Œå¹¶è¾“å‡ºæœ€å°æ ‘å½¢å›¾æ¯æ¡è¾¹çš„æƒå€¼ä¹‹å’Œï¼Œå¦‚æœæ²¡æœ‰ä»¥  ä¸ºæ ¹çš„æœ€å°æ ‘å½¢å›¾ï¼Œè¾“å‡º ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 20010#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n,m,root;struct edge{    int x,y,v;}e[maxn];int id[maxn],pre[maxn],ine[maxn],vis[maxn];int zhuliu(){    int ans=0,cnt;    while(1)    {        cnt=0;        for(int i=1;i&lt;=n;++i) ine[i]=inf,id[i]=vis[i]=0;        for(int i=1;i&lt;=m;++i)        {            int x=e[i].x,y=e[i].y,v=e[i].v;            if(x!=y&amp;&amp;v&lt;ine[y]) ine[y]=v,pre[y]=x;        }        for(int i=1;i&lt;=n;++i)            if(i!=root&amp;&amp;ine[i]==inf)                return -1;        for(int i=1;i&lt;=n;++i)        {            if(i==root) continue;            ans+=ine[i];            int y=i;            while(vis[y]!=i&amp;&amp;!id[y]&amp;&amp;y!=root)            {                vis[y]=i;                y=pre[y];            }            if(!id[y]&amp;&amp;y!=root)            {                id[y]=++cnt;                for(int x=pre[y];x!=y;x=pre[x]) id[x]=cnt;            }        }        if(!cnt) break;        for(int i=1;i&lt;=n;++i)            if(!id[i])                id[i]=++cnt;        for(int i=1;i&lt;=m;++i)        {            int x=e[i].x,y=e[i].y;            e[i].x=id[x],e[i].y=id[y];            if(id[x]!=id[y]) e[i].v-=ine[y];        }        root=id[root];        n=cnt;    }    return ans;}int main(){\tread(n),read(m),read(root);    for(int i=1;i&lt;=m;++i)        read(e[i].x),read(e[i].y),read(e[i].v);    printf(\"%d\",zhuliu());\treturn 0;}\næ”¯é…æ ‘ç»™å®šä¸€å¼ æœ‰å‘å›¾ï¼Œæ±‚ä»  å·ç‚¹å‡ºå‘ï¼Œæ¯ä¸ªç‚¹èƒ½æ”¯é…çš„ç‚¹çš„ä¸ªæ•°ï¼ˆåŒ…æ‹¬è‡ªå·±ï¼‰ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define maxm 600010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m;struct node{\tstruct edge\t{\t\tint to,nxt;\t}e[maxm];\tint head[maxn],edge_cnt;\tvoid add(int from,int to)\t{\t\te[++edge_cnt]=(edge){to,head[from]};\t\thead[from]=edge_cnt;\t}}a,b,c,d;int dfn_cnt;int dfn[maxn],id[maxn],fa[maxn];int sdom[maxn],idom[maxn],fath[maxn],val[maxn],ans[maxn];void dfs_dfn(int x){\tdfn[x]=++dfn_cnt;\tid[dfn_cnt]=x;\tfor(int i=a.head[x];i;i=a.e[i].nxt)\t{\t\tint y=a.e[i].to;\t\tif(dfn[y]) continue;\t\tfa[y]=x;\t\tdfs_dfn(y);\t}}int find(int x){\tif(x==fath[x]) return x;\tint tmp=find(fath[x]);\tif(dfn[sdom[val[fath[x]]]]&lt;dfn[sdom[val[x]]])\t\tval[x]=val[fath[x]];\treturn fath[x]=tmp;}void tarjan(){\tfor(int i=1;i&lt;=n;++i) sdom[i]=fath[i]=val[i]=i;\tfor(int i=dfn_cnt;i&gt;1;--i)\t{\t\tint x=id[i];\t\tfor(int i=b.head[x];i;i=b.e[i].nxt)\t\t{\t\t\tint y=b.e[i].to;\t\t\tif(!dfn[y]) continue;\t\t\tfind(y);\t\t\tif(dfn[sdom[val[y]]]&lt;dfn[sdom[x]])\t\t\t\tsdom[x]=sdom[val[y]];\t\t}\t\tc.add(sdom[x],x);\t\tfath[x]=fa[x];\t\tx=fa[x];\t\tfor(int i=c.head[x];i;i=c.e[i].nxt)\t\t{\t\t\tint y=c.e[i].to;\t\t\tfind(y);\t\t\tif(sdom[val[y]]==x) idom[y]=x;\t\t\telse idom[y]=val[y];\t\t}\t\tc.head[x]=0;\t}\tfor(int i=2;i&lt;=dfn_cnt;++i)\t{\t\tint x=id[i];\t\tif(idom[x]!=sdom[x])\t\t\tidom[x]=idom[idom[x]];\t}\tfor(int i=2;i&lt;=n;++i) d.add(idom[i],i);}void dfs_ans(int x){\tans[x]=1;\tfor(int i=d.head[x];i;i=d.e[i].nxt)\t{\t\tint y=d.e[i].to;\t\tdfs_ans(y);\t\tans[x]+=ans[y];\t}}int main(){\tread(n),read(m);\tfor(int i=1;i&lt;=m;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\ta.add(x,y),b.add(y,x);\t}\tdfs_dfn(1);\ttarjan();\tdfs_ans(1);\tfor(int  i=1;i&lt;=n;++i) printf(\"%d \",ans[i]);\treturn 0;}\nåŠ¨æ€è§„åˆ’å•è°ƒé˜Ÿåˆ—ä¼˜åŒ– DPä¼˜åŒ–å½¢å¦‚  çš„  æ–¹ç¨‹ã€‚\n\nwhile(h&lt;=t&amp;&amp;f[x][y]&gt;q[t].val+dis(x,y,q[t].x,q[t].y)) t--;q[++t]=(que){f[x][y],x,y};while(h&lt;=t&amp;&amp;(abs(x-q[h].x)&gt;len||abs(y-q[h].y)&gt;len)) h++;f[x][y]=max(f[x][y],q[h].val+dis(x,y,q[h].x,q[h].y));ans=max(ans,f[x][y]);\næ•°ä½ DPä¸å«å‰å¯¼é›¶ä¸”ç›¸é‚»ä¸¤ä¸ªæ•°å­—ä¹‹å·®è‡³å°‘ä¸º  çš„æ­£æ•´æ•°è¢«ç§°ä¸º windy æ•°ã€‚windy æƒ³çŸ¥é“ï¼Œåœ¨  å’Œ  ä¹‹é—´ï¼ŒåŒ…æ‹¬  å’Œ  ï¼Œæ€»å…±æœ‰å¤šå°‘ä¸ª windy æ•°ï¼Ÿ\n#include&lt;bits/stdc++.h&gt;#define maxn 15using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll a,b,cnt;ll num[maxn],f[maxn][maxn][2][2][2];ll dp(int pos,int las,bool lim,bool lead,bool flag){    if(!pos) return flag;    if(f[pos][las][lim][lead][flag]!=-1) return f[pos][las][lim][lead][flag];    ll v=0,ma=9;    if(lim) ma=num[pos];    for(int i=0;i&lt;=ma;++i)    {        if(!i&amp;&amp;lead) v+=dp(pos-1,12,0,1,1);        else v+=dp(pos-1,i,lim&amp;&amp;i==ma,0,flag&amp;&amp;(abs(las-i)&gt;=2));    }    return f[pos][las][lim][lead][flag]=v;}ll solve(ll x){    cnt=0,memset(f,-1,sizeof(f));    while(x) num[++cnt]=x%10,x/=10;    return dp(cnt,12,1,1,1);}int main(){    read(a),read(b),printf(\"%lld\",solve(b)-solve(a-1));    return 0;}\næ–œç‡ä¼˜åŒ–æœ€å°å€¼\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,h,t;ll f[maxn],p[maxn],s[maxn],c[maxn],dis[maxn],q[maxn];double x(int i){    return p[i];}double y(int i){    return f[i]+s[i];}double slope(int j,int k){    return (y(j)-y(k))/(x(j)-x(k));}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        read(dis[i]),read(p[i]),read(c[i]);        s[i]=s[i-1]+dis[i]*p[i],p[i]+=p[i-1];    }    for(int i=1;i&lt;=n;++i)    {        while(h&lt;t&amp;&amp;slope(q[h],q[h+1])&lt;dis[i]) h++;        f[i]=f[q[h]]+dis[i]*(p[i]-p[q[h]])-(s[i]-s[q[h]])+c[i];        while(h&lt;t&amp;&amp;slope(q[t],q[t-1])&gt;slope(q[t],i)) t--;        q[++t]=i;    }    printf(\"%lld\",f[n]);\treturn 0;}\næœ€å¤§å€¼\n#include&lt;bits/stdc++.h&gt;#define maxn 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,h,t,a,b,c;ll f[maxn],s[maxn],q[maxn];ll calc(ll x){    return x*x;}double x(int i){    return s[i];}double y(int i){    return f[i]+a*calc(s[i])-b*s[i];}double slope(int j,int k){    return (y(j)-y(k))/(x(j)-x(k));}int main(){    read(n),read(a),read(b),read(c);    for(int i=1;i&lt;=n;++i) read(s[i]),s[i]+=s[i-1];    for(int i=1;i&lt;=n;++i)    {        while(h&lt;t&amp;&amp;slope(q[h],q[h+1])&gt;2*a*s[i]) h++;        f[i]=f[q[h]]+a*calc(s[i]-s[q[h]])+b*(s[i]-s[q[h]])+c;        while(h&lt;t&amp;&amp;slope(q[t],q[t-1])&lt;slope(q[t],i)) t--;        q[++t]=i;    }    printf(\"%lld\",f[n]);\treturn 0;}\nå†³ç­–å•è°ƒæ€§\näºŒåˆ†æ ˆï¼š\ndouble calc(int i,int j){    return a[j]-a[i]+sqrt(i-j);}int find(node t,int x){\tint l=t.l,r=t.r,ans=t.r+1;\twhile(l&lt;=r)\t{\t\tint mid=(l+r)&gt;&gt;1;\t\tif(calc(mid,x)&gt;=calc(mid,t.pos)) r=mid-1,ans=mid;\t\telse l=mid+1;\t}\treturn ans;}void dp(double *f){\tq[h=t=1]=node(1,n,0);\tfor(int i=1;i&lt;=n;++i)\t{\t\twhile(h&lt;=t&amp;&amp;q[h].r&lt;i) h++;\t\tf[i]=calc(i,q[h].pos);\t\tif(calc(n,i)&gt;=calc(n,q[t].pos))\t\t{\t\t\twhile(h&lt;=t&amp;&amp;calc(q[t].l,i)&gt;=calc(q[t].l,q[t].pos)) t--;\t\t\tif(h&gt;t) q[++t]=node(i,n,i);\t\t\telse\t\t\t{\t\t\t\tint x=find(q[t],i);\t\t\t\tq[t].r=x-1,q[++t]=node(x,n,i);\t\t\t}\t\t}\t}}\nåˆ†æ²»ï¼š\nå¯¹äºåŒºé—´ ï¼Œå·²çŸ¥å…¶æœ€ä¼˜å†³ç­–èŒƒå›´ä¸º ã€‚å–  åæ‰«ä¸€éåŒºé—´  æ¥å¾—å‡º  çš„  å€¼å’Œæœ€ä¼˜å†³ç­–ç‚¹ ï¼Œé‚£ä¹ˆå·¦åŒºé—´çš„æœ€ä¼˜å†³ç­–èŒƒå›´ä¸º ï¼Œå³åŒºé—´çš„æœ€ä¼˜å†³ç­–èŒƒå›´ä¸º ã€‚åº”ç”¨åˆ†æ²»æ—¶è¦æ±‚ä¿è¯åŒºé—´  çš„ä¿¡æ¯éƒ½å·²å­˜åœ¨ï¼Œå› æ­¤åº”ç”¨åˆ†æ²»å¤§éƒ¨åˆ†æ—¶å€™éƒ½æ˜¯åˆ†å±‚çš„ä¸¤ç»´ ã€‚\ndouble calc(int i,int j){    return a[j]-a[i]+sqrt(i-j);}void solve(int l,int r,int L,int R,double *f){    if(l&gt;r) return;    int pos,mid=(l+r)&gt;&gt;1;    for(int i=L;i&lt;=min(mid,R);++i)    {        double v=calc(mid,i);        if(v&gt;f[mid]) f[mid]=v,pos=i;    }    solve(l,mid-1,L,pos,f),solve(mid+1,r,pos,R,f);}\nå¯ä»¥å¤„ç†æ— æ³•å¿«é€Ÿ  è®¡ç®—  çš„ ã€‚ï¼Œå…¶ä¸­  ä¸ºåŒºé—´  ç›¸åŒå…ƒç´ çš„å¯¹æ•°ã€‚\nvoid add(int c){    sum+=cnt[c],cnt[c]++;}void del(int c){    sum-=cnt[c]-1,cnt[c]--;}ll get(int ql,int qr){    while(l&lt;ql) del(a[l++]);    while(r&gt;qr) del(a[r--]);    while(l&gt;ql) add(a[--l]);    while(r&lt;qr) add(a[++r]);    return sum;}void solve(int id,int l,int r,int L,int R){    if(l&gt;r) return;    int pos,mid=(l+r)&gt;&gt;1;    for(int i=L;i&lt;=min(mid,R);++i)    {        ll v=f[i][id-1]+get(i+1,mid);        if(v&lt;f[mid][id]) f[mid][id]=v,pos=i;    }    solve(id,l,mid-1,L,pos),solve(id,mid+1,r,pos,R);}\næŒ‡é’ˆçš„ç§»åŠ¨å‡æ‘Šæ˜¯  çš„ã€‚\né•¿é“¾å‰–åˆ†ç»™å®šä¸€æ£µä»¥  ä¸ºæ ¹ï¼Œ ä¸ªèŠ‚ç‚¹çš„æ ‘ã€‚è®¾  ä¸º  å­æ ‘ä¸­åˆ°  è·ç¦»ä¸º  çš„èŠ‚ç‚¹æ•°ã€‚  å¯¹äºæ¯ä¸ªç‚¹ï¼Œæ±‚ä¸€ä¸ªæœ€å°çš„ ï¼Œä½¿å¾—  æœ€å¤§ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n;int len[maxn],son[maxn],ans[maxn];vector&lt;int&gt; f[maxn];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void dfs_son(int x,int fa){    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fa) continue;        dfs_son(y,x);\t\tif(len[y]&gt;=len[son[x]]) son[x]=y,len[x]=len[y]+1;    }}void dfs(int x,int fa){\tif(!son[x])\t{\t\tf[x].push_back(1);\t\treturn;\t}\tdfs(son[x],x),swap(f[x],f[son[x]]),f[x].push_back(1),ans[x]=ans[son[x]]+1;\tif(f[x][len[x]-ans[x]]==1) ans[x]=0;\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tif(y==fa||y==son[x]) continue;\t\tdfs(y,x);\t\tfor(int j=0;j&lt;=len[y];++j)\t\t{\t\t\tf[x][len[x]-j-1]+=f[y][len[y]-j];\t\t\tif(f[x][len[x]-j-1]&gt;f[x][len[x]-ans[x]]||(f[x][len[x]-j-1]==f[x][len[x]-ans[x]]&amp;&amp;j+1&lt;ans[x]))\t\t\t\tans[x]=j+1;\t\t}\t}}int main(){\tread(n);\tfor(int i=1;i&lt;n;++i)\t{\t\tint x,y;\t\tread(x),read(y);\t\tadd(x,y),add(y,x);\t}\tdfs_son(1,0),dfs(1,0);\tfor(int i=1;i&lt;=n;++i) printf(\"%d\\n\",ans[i]);\treturn 0;}\nå‡¸ä¼˜åŒ–ç†è§£å¯ä»¥æ˜¯äºŒåˆ†æ–œç‡åˆ‡å‡¸åŒ…ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸Šä¸‹å¹³ç§»å‡¸å‡½æ•°çš„å¯¼å‡½æ•°ï¼Œæ¥å·¦å³å¹³ç§»å¯¼å‡½æ•°çš„é›¶ç‚¹ï¼Œä½¿åŸå‡¸å‡½æ•°çš„å–åˆ°æå€¼çš„ä½ç½®å‘ç”Ÿå˜åŒ–ã€‚å¯ä»¥ä¼˜åŒ–ä¸€ç§æœ‰é™åˆ¶ä¸ªæ•°çš„ ï¼Œå³æ°å¥½é€‰  ä¸ªï¼Œé€šè¿‡äºŒåˆ†æ¥å»æ‰ä¸€ç»´æ¥å®ç°ä¼˜åŒ–ã€‚é€šè¿‡é¢˜é¢æ€§è´¨æ¥è¯æ˜å‡¸å‡½æ•°ï¼Œè´¹ç”¨æµæ¨¡å‹éƒ½ä¸ºå‡¸å‡½æ•°ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 600010#define inf 1000000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,k;ll l,r,ans;struct edge{    int to,nxt;    ll v;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to,int val){    e[++edge_cnt]=(edge){to,head[from],val};    head[from]=edge_cnt;}struct node{    ll val,cnt;}f[maxn][3],g[3];bool operator &lt;(const node &amp;a,const node &amp;b){    if(a.val==b.val) return a.cnt&lt;b.cnt;    return a.val&lt;b.val;}node operator +(const node &amp;a,const node &amp;b){    return (node){a.val+b.val,a.cnt+b.cnt};}void dfs(int x,int fa,ll delta){    f[x][0]=(node){0,0},f[x][1]=(node){-inf,-inf},f[x][2]=(node){delta,1};    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        ll v=e[i].v;        if(y==fa) continue;        dfs(y,x,delta),g[0]=g[1]=g[2]=(node){-inf,-inf};        for(int j=0;j&lt;3;++j)            for(int k=0;k&lt;3;++k)                g[j]=max(g[j],f[x][j]+f[y][k]);        g[1]=max(g[1],max(f[x][0]+f[y][0]+(node){v+delta,1},f[x][0]+f[y][1]+(node){v,0}));        g[2]=max(g[2],max(f[x][1]+f[y][1]+(node){v-delta,-1},f[x][1]+f[y][0]+(node){v,0}));        f[x][0]=g[0],f[x][1]=g[1],f[x][2]=g[2];    }}bool check(ll x){    dfs(1,0,x);    return max(f[1][0],max(f[1][1],f[1][2])).cnt&gt;=k;}int main(){    read(n),read(k),k++;    for(int i=1;i&lt;n;++i)    {        int x,y,v;        read(x),read(y),read(v);        add(x,y,v),add(y,x,v),r+=abs(v);    }    l=-r;    while(l&lt;=r)    {        ll mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,r=mid-1;        else l=mid+1;    }    check(ans),printf(\"%lld\",max(f[1][0],max(f[1][1],f[1][2])).val-ans*k);    return 0;}\né€šè¿‡é™åˆ¶äºŒåˆ†æ¥å¤„ç†é€‰è‡³å¤šé€‰  ä¸ªçš„é—®é¢˜ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 500010#define inf 1000000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,k,pos,l=-inf,r=0;ll ans,sum,cnt;struct node{    ll v,p;}a[maxn],b[maxn];bool cmp(const node &amp;a,const node &amp;b){    if(a.p==b.p) return a.v&lt;b.v;    return a.p&lt;b.p;}bool check(int x){    priority_queue&lt;int&gt; q;    sum=cnt=0,pos=1;    for(int i=1;i&lt;=n;++i)    {        while(pos&lt;=m&amp;&amp;a[i].p&gt;=b[pos].p) q.push(b[pos++].v);        if(q.empty()) continue;        if(q.top()-a[i].v+x&gt;=0)            sum+=q.top()-a[i].v+x,cnt++,q.pop();    }    return cnt&lt;=k;}int main(){    read(n),read(m),read(k);    for(int i=1;i&lt;=n;++i) read(a[i].v),read(a[i].p);    for(int i=1;i&lt;=m;++i) read(b[i].v),read(b[i].p);    sort(a+1,a+n+1,cmp),sort(b+1,b+m+1,cmp);    while(l&lt;=r)    {        int mid=(l+r)&gt;&gt;1;        if(check(mid)) ans=mid,l=mid+1;        else r=mid-1;    }    check(ans),printf(\"%lld\\n\",sum-ans*cnt);    return 0;}\næ•´ä½“ DP\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define maxm 15000010#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,k,tot;int d[maxn],w[maxn],rt[maxn],ls[maxm],rs[maxm];ll mx[maxm],tag[maxm];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void pushtag(int cur,ll v){\tif(cur) mx[cur]+=v,tag[cur]+=v;}void pushdown(int cur){\tif(tag[cur]) pushtag(ls[cur],tag[cur]),pushtag(rs[cur],tag[cur]),tag[cur]=0;}void modify(int l,int r,int p,ll v,int &amp;cur){\tif(!cur) cur=++tot;\tif(l==r)\t{\t\tmx[cur]=v;\t\treturn;\t}\tpushdown(cur);\tif(p&lt;=mid) modify(l,mid,p,v,ls[cur]);\telse modify(mid+1,r,p,v,rs[cur]);\tmx[cur]=max(mx[ls[cur]],mx[rs[cur]]);}ll query(int L,int R,int l,int r,int cur){\tif(!cur) return 0;\tif(L&lt;=l&amp;&amp;R&gt;=r) return mx[cur];\tll v=0;\tpushdown(cur);\tif(L&lt;=mid) v=max(v,query(L,R,l,mid,ls[cur]));\tif(R&gt;mid) v=max(v,query(L,R,mid+1,r,rs[cur]));\treturn v;}int get(int x,int y,int l,int r,ll v1,ll v2){\tif(!x&amp;&amp;!y) return 0;\tif(x&amp;&amp;!y)\t{\t\tpushtag(x,v2);\t\treturn x;\t}\tif(!x&amp;&amp;y)\t{\t\tpushtag(y,v1);\t\treturn y;\t}\tif(l==r)\t{\t\tmx[x]=max(mx[x],v1)+max(mx[y],v2);\t\treturn x;\t}\tpushdown(x),pushdown(y);\trs[x]=get(rs[x],rs[y],mid+1,r,max(v1,mx[ls[x]]),max(v2,mx[ls[y]]));\tls[x]=get(ls[x],ls[y],l,mid,v1,v2);\tmx[x]=max(mx[ls[x]],mx[rs[x]]);\treturn x;}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tdfs(y),rt[x]=get(rt[x],rt[y],1,k,0,0);\t}\tif(d[x]) modify(1,k,d[x],w[x]+query(1,d[x],1,k,rt[x]),rt[x]);}int main(){\tread(n),read(m),read(k);\tfor(int i=2,p;i&lt;=n;++i) read(p),add(p,i);\tfor(int i=1,x;i&lt;=m;++i) read(x),read(d[x]),read(w[x]);\tdfs(1),printf(\"%lld\\n\",mx[rt[1]]);    return 0;}\nåŠ¨æ€ DPç»™å®šä¸€æ£µ  ä¸ªç‚¹çš„æ ‘ï¼Œç‚¹å¸¦ç‚¹æƒã€‚æœ‰  æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œç»™å®š ï¼Œè¡¨ç¤ºä¿®æ”¹ç‚¹  çš„æƒå€¼ä¸º ã€‚ä½ éœ€è¦åœ¨æ¯æ¬¡æ“ä½œä¹‹åæ±‚å‡ºè¿™æ£µæ ‘çš„æœ€å¤§æƒç‹¬ç«‹é›†çš„æƒå€¼å¤§å°ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 200010#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,m;int f[maxn][2],a[maxn],ch[maxn][2],fa[maxn];struct edge{    int to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){    e[++edge_cnt]=(edge){to,head[from]};    head[from]=edge_cnt;}struct matrix{    int a[2][2];    matrix()    {        a[0][0]=a[0][1]=a[1][0]=a[1][1]=-inf;    }    int get()    {        return max(a[0][0],a[1][0]);    }}val[maxn],mul[maxn];matrix operator *(const matrix &amp;x,const matrix &amp;y){    matrix z;    for(int k=0;k&lt;=1;++k)        for(int i=0;i&lt;=1;++i)            for(int j=0;j&lt;=1;++j)                z.a[i][j]=max(z.a[i][j],x.a[i][k]+y.a[k][j]);    return z;}void pushup(int x) {    mul[x]=val[x];    if(ch[x][0]) mul[x]=mul[ch[x][0]]*mul[x];    if(ch[x][1]) mul[x]=mul[x]*mul[ch[x][1]];}bool check(int x){    return ch[fa[x]][1]==x;}bool notroot(int x){    return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void rotate(int x){    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];    if(notroot(y)) ch[z][check(y)]=x;    ch[x][k^1]=y,ch[y][k]=w;    if(w) fa[w]=y;    fa[x]=z,fa[y]=x;    pushup(y),pushup(x);}void splay(int x){    for(int y;notroot(x);rotate(x))        if(notroot(y=fa[x]))            rotate(check(x)^check(y)?x:y);}void access(int x){    for(int y=0;x;y=x,x=fa[x])    {            splay(x);        if(ch[x][1]) val[x].a[0][0]+=mul[ch[x][1]].get(),val[x].a[1][0]+=mul[ch[x][1]].a[0][0];        if(y) val[x].a[0][0]-=mul[y].get(),val[x].a[1][0]-=mul[y].a[0][0];        val[x].a[0][1]=val[x].a[0][0],ch[x][1]=y,pushup(x);    }}void modify(int x,int v){    access(x),splay(x);    val[x].a[1][0]-=a[x]-v;    pushup(x),a[x]=v;}void dfs(int x,int fath){    fa[x]=fath,f[x][1]=a[x];    for(int i=head[x];i;i=e[i].nxt)    {        int y=e[i].to;        if(y==fath) continue;        dfs(y,x),f[x][0]+=max(f[y][0],f[y][1]),f[x][1]+=f[y][0];    }    val[x].a[0][0]=val[x].a[0][1]=f[x][0],val[x].a[1][0]=f[x][1],mul[x]=val[x];}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i) read(a[i]);    for(int i=1;i&lt;n;++i)    {        int x,y;        read(x),read(y);        add(x,y),add(y,x);    }    dfs(1,0);    while(m--)    {        int x,y;        read(x),read(y),modify(x,y),splay(1);        printf(\"%d\\n\",mul[1].get());    }\treturn 0;}\nå­—ç¬¦ä¸²KMPfor(int i=2;i&lt;=m;++i){    while(pos&amp;&amp;t[i]!=t[pos+1]) pos=nxt[pos];    if(t[i]==t[pos+1]) pos++;    nxt[i]=pos;}pos=0;for(int i=1;i&lt;=n;++i){    while(pos&amp;&amp;s[i]!=t[pos+1]) pos=nxt[pos];    if(s[i]==t[pos+1]) pos++;    if(pos==m) printf(\"%d\\n\",i-m+1);}\nManacherè®¾  ä¸ºä»¥  ä¸ºä¸­å¿ƒçš„é•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡ä¸²ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯æœ€é•¿å›æ–‡ä¸²çš„å›æ–‡åŠå¾„ã€‚\nvoid manacher(){\ts[0]='/',s[1]='#';\tfor(int i=1;i&lt;=n;++i) s[i&lt;&lt;1]=t[i],s[i&lt;&lt;1|1]='#';\tn=n&lt;&lt;1|1,s[n+1]='!';\tfor(int i=1,mr=1,mid=0;i&lt;=n;++i)\t{\t\tf[i]=i&lt;mr?min(f[mid*2-i],mr-i):1;\t\twhile(s[i+f[i]]==s[i-f[i]]) f[i]++;\t\tif(i+f[i]&gt;mr) mr=i+f[i],mid=i;\t}}\nAC è‡ªåŠ¨æœºç»™ä½ ä¸€ä¸ªæ–‡æœ¬ä¸²  å’Œ  ä¸ªæ¨¡å¼ä¸² ï¼Œè¯·ä½ åˆ†åˆ«æ±‚å‡ºæ¯ä¸ªæ¨¡å¼ä¸²  åœ¨  ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot,root;int ch[maxn][28],fail[maxn],siz[maxn],bel[maxn];char s[maxn];struct edge{\tint to,nxt;}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]={to,head[from]},head[from]=edge_cnt;}int insert(char *s){\tint len=strlen(s+1),p=root;\tfor(int i=1;i&lt;=len;++i)\t{\t\tint c=s[i]-'a';\t\tif(!ch[p][c]) ch[p][c]=++tot;\t\tp=ch[p][c];\t}\treturn p;}void build(){\tqueue&lt;int&gt; q;\tfor(int i=0;i&lt;26;++i)\t\tif(ch[root][i])\t\t\tq.push(ch[root][i]);\twhile(!q.empty())\t{\t\tint x=q.front();\t\tq.pop();\t\tfor(int i=0;i&lt;26;++i)\t\t{\t\t\tint y=ch[x][i];\t\t\tif(y) fail[y]=ch[fail[x]][i],q.push(y);\t\t\telse ch[x][i]=ch[fail[x]][i];\t\t}\t}\tfor(int i=1;i&lt;=tot;++i) add(fail[i],i);}void update(){\tscanf(\"%s\",s+1);\tint len=strlen(s+1);\tfor(int i=1,p=root;i&lt;=len;++i) p=ch[p][s[i]-'a'],siz[p]++;}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt) dfs(e[i].to),siz[x]+=siz[e[i].to];}int main(){\tread(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%s\",s+1),bel[i]=insert(s);\tbuild(),update(),dfs(root);\tfor(int i=1;i&lt;=n;++i) printf(\"%d\\n\",siz[bel[i]]);    return 0;}\nåç¼€æ’åºå°†å­—ç¬¦ä¸²æ¯ä¸ªåç¼€æŒ‰ç…§å­—å…¸åºæ’åºã€‚ è¡¨ç¤ºæ’åä¸º  çš„åç¼€çš„èµ·å§‹ä½ç½®ã€‚ è¡¨ç¤ºèµ·å§‹ä½ç½®ä¸º  çš„åç¼€çš„æ’åã€‚ã€‚ä¸¤ä¸ªåç¼€çš„  ä¸ºåŒºé—´  æ•°ç»„çš„æœ€å°å€¼ã€‚\nvoid rsort(){    for(int i=0;i&lt;=m;++i) b[i]=0;    for(int i=1;i&lt;=n;++i) b[rk[i]]++;    for(int i=1;i&lt;=m;++i) b[i]+=b[i-1];    for(int i=n;i;--i) sa[b[rk[tp[i]]]--]=tp[i];}void SA(){    for(int i=1;i&lt;=n;++i) rk[i]=s[i],tp[i]=i;    rsort();    for(int k=1;k&lt;=n;k&lt;&lt;=1)    {        int num=0;        for(int i=n-k+1;i&lt;=n;++i) tp[++num]=i;        for(int i=1;i&lt;=n;++i)             if(sa[i]&gt;k)                tp[++num]=sa[i]-k;        rsort();        memcpy(tp,rk,sizeof(rk));        rk[sa[1]]=num=1;        for(int i=2;i&lt;=n;++i)            rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k])?num:++num;        if(num==n) break;        m=num;    }}void height(){    int k=0;    for(int i=1;i&lt;=n;++i) rk[sa[i]]=i;    for(int i=1;i&lt;=n;++i)    {        if(rk[i]==1) continue;        if(k) k--;        int j=sa[rk[i]-1];        while(s[i+k]==s[j+k]) k++;        ht[rk[i]]=k;    }}void ST(){    lg[0]=-1;    for(int i=1;i&lt;=n;++i) lg[i]=lg[i&gt;&gt;1]+1;    for(int i=1;i&lt;=n;++i) f[i][0]=ht[i];    for(int j=1;j&lt;=20;++j)        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i)            f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]);}int lcp(int l,int r){    l=rk[l],r=rk[r];    if(l&gt;r) swap(l,r);    l++;    int len=lg[r-l+1];    return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]);}\nåç¼€è‡ªåŠ¨æœºåç¼€è‡ªåŠ¨æœºå¯ä»¥ç†è§£ä¸ºæ˜¯å°†å­—ç¬¦ä¸²æ‰€æœ‰åç¼€æ‰€å»ºå‡ºçš„  è¿›è¡Œå‹ç¼©åå¾—å‡ºçš„ ã€‚å¯¹äºä¸€ä¸ªå­ä¸² ï¼Œå®ƒç»“æŸä½ç½®çš„é›†åˆç§°ä¸º ï¼Œå¦‚ ï¼Œã€‚ ä¸ºåŸä¸²çš„ä¸¤ä¸ªå­ä¸²ï¼Œè®¾ ï¼Œåˆ™  æ˜¯  çš„åç¼€å½“ä¸”ä»…å½“ ï¼Œ ä¸æ˜¯  çš„åç¼€å½“ä¸”ä»…å½“ ã€‚ç”±  çš„åŒ…å«å…³ç³»å¯ä»¥å¾—å‡ºä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œç§°ä¸º  æ ‘ã€‚\nåç¼€è‡ªåŠ¨æœºçš„èŠ‚ç‚¹å°±æ˜¯  æ ‘çš„èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ª ã€‚ çš„èŠ‚ç‚¹æ•°ä¸è¶…è¿‡ ï¼Œè¾¹æ•°ä¸è¶…è¿‡ ï¼Œæ•°ç»„å¤§å°åº”å¼€æˆä¸¤å€ã€‚ä¸ºä¸€ä¸ª  æ‰€å¯¹åº”çš„å­ä¸²ä¸­æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚ä¸ºè½¬ç§»å‡½æ•°ã€‚ä¸ºåç¼€è¿æ¥ã€‚è®¾  ä¸ºä¸€ä¸ª  æ‰€å¯¹åº”çš„å­ä¸²ä¸­æœ€çŸ­å­ä¸²çš„é•¿åº¦ï¼Œå¾— ã€‚åç¼€è‡ªåŠ¨æœºæ˜¯ä¸€å¼ æœ‰å‘æ— ç¯å›¾ï¼Œå…¶ä¸­é¡¶ç‚¹æ˜¯çŠ¶æ€ï¼Œè€Œè¾¹ä»£è¡¨äº†çŠ¶æ€ä¹‹é—´çš„è½¬ç§»ã€‚æ¯ä¸€ä¸ªçŠ¶æ€åŒ…å«äº†å®ƒåŒ…å«çš„æœ€é•¿å­ä¸²çš„ä¸€äº›è¿ç»­é•¿åº¦çš„åç¼€ï¼Œä¸æ˜¯æ‰€æœ‰åç¼€ï¼Œå†çŸ­çš„å…¶ä»–åç¼€åœ¨  è¿æ¥çš„çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯è¯¥ä¸²çš„æ‰€æœ‰åç¼€åœ¨  æ ‘çš„é“¾ä¸Šã€‚ä¸€ä¸ªå­—ç¬¦ä¸²çš„  æ ‘ï¼Œæ˜¯å…¶åä¸²çš„åç¼€æ ‘ã€‚ä»åˆå§‹çŠ¶æ€ç»ç”±ä»»æ„è·¯å¾„èµ°åˆ°æŸä¸€ç»ˆæ­¢çŠ¶æ€ï¼Œå¾—åˆ°çš„å­—ç¬¦ä¸²ä¸ºåŸä¸²çš„æŸä¸€åç¼€ã€‚ä»åˆå§‹çŠ¶æ€ç»ç”±ä»»æ„è·¯å¾„èµ°åˆ°æŸä¸€çŠ¶æ€ï¼Œå¾—åˆ°çš„å­—ç¬¦ä¸²ä¸ºåŸä¸²çš„æŸä¸€å­ä¸²ã€‚æ‰€æœ‰ç»ˆæ­¢çŠ¶æ€åŒ…å«äº†åŸä¸²çš„æ‰€æœ‰åç¼€ï¼Œæ•´ä¸²çŠ¶æ€æ˜¯ç»ˆæ­¢çŠ¶æ€ï¼Œæ•´ä¸²çŠ¶æ€åœ¨  æ ‘ä¸Šçš„ç¥–å…ˆä¹Ÿéƒ½æ˜¯ç»ˆæ­¢çŠ¶æ€ã€‚ä¸€ä¸ªçŠ¶æ€çš„  é›†åˆå¤§å°ç­‰äºè¯¥çŠ¶æ€è½¬ç§»åˆ°ç»ˆæ­¢çŠ¶æ€çš„æ–¹æ¡ˆæ•°ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,tot=1,las=1;ll ans;int len[maxn],fa[maxn],ch[maxn][28],siz[maxn];char s[maxn];struct edge{\tint to,nxt;\tedge(int a=0,int b=0)\t{\t\tto=a,nxt=b;\t}}e[maxn];int head[maxn],edge_cnt;void add(int from,int to){\te[++edge_cnt]=edge(to,head[from]),head[from]=edge_cnt;}void insert(int c){\tint p=las,np=las=++tot;\tlen[np]=len[p]+1,siz[np]=1;\twhile(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p];\tif(!p) fa[np]=1;\telse\t{\t\tint q=ch[p][c];\t\tif(len[q]==len[p]+1) fa[np]=q;\t\telse\t\t{\t\t\tint nq=++tot;\t\t\tmemcpy(ch[nq],ch[q],sizeof(ch[q]));\t\t\tlen[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;\t\t\twhile(ch[p][c]==q) ch[p][c]=nq,p=fa[p];\t\t}\t}}void dfs(int x){\tfor(int i=head[x];i;i=e[i].nxt)\t{\t\tint y=e[i].to;\t\tdfs(y),siz[x]+=siz[y];\t}\tif(siz[x]&gt;1) ans=max(ans,(ll)len[x]*siz[x]);}int main(){\tscanf(\"%s\",s+1),n=strlen(s+1);\tfor(int i=1;i&lt;=n;++i) insert(s[i]-'a');\tfor(int i=2;i&lt;=tot;++i) add(fa[i],i);\tdfs(1),printf(\"%lld\",ans);\t    return 0;}\nå¹¿ä¹‰åç¼€è‡ªåŠ¨æœº#include&lt;bits/stdc++.h&gt;#define maxn 2000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,las,tot=1,root=1;ll ans;int fa[maxn],len[maxn],ch[maxn][26];char s[maxn];int insert(int c){    if(ch[las][c]&amp;&amp;len[las]+1==len[ch[las][c]]) return ch[las][c];    int p=las,np=++tot;    len[np]=len[p]+1;    while(p&amp;&amp;!ch[p][c]) ch[p][c]=np,p=fa[p];    if(!p) fa[np]=root;    else    {        int q=ch[p][c];        if(len[q]==len[p]+1) fa[np]=q;        else        {            int nq=++tot;            bool flag=las==p;            memcpy(ch[nq],ch[q],sizeof(ch[q]));            len[nq]=len[p]+1,fa[nq]=fa[q],fa[q]=fa[np]=nq;            while(ch[p][c]==q) ch[p][c]=nq,p=fa[p];            return flag?nq:np;        }    }    return np;}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        int lenth;        scanf(\"%s\",s+1),lenth=strlen(s+1),las=1;        for(int j=1;j&lt;=lenth;++j) las=insert(s[j]-'a');    }    for(int i=2;i&lt;=tot;++i) ans+=len[i]-len[fa[i]];    printf(\"%lld\",ans);    return 0;}\nå›æ–‡è‡ªåŠ¨æœºå›æ–‡æ ‘å¯ä»¥ç”¨æ¥å¤„ç†ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰çš„å›æ–‡å­ä¸²ã€‚ä¸€ä¸ªä¸²çš„æœ¬è´¨ä¸åŒå›æ–‡å­ä¸²ä¸ªæ•°æœ€å¤šä¸º  ä¸ªã€‚ä¸€ä¸ªå­—ç¬¦ä¸²çš„å›æ–‡æ ‘ç”±ä¸¤æ£µæ ‘ç»„æˆï¼Œä¸€ä¸ªç»´æŠ¤æ‰€æœ‰é•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡å­ä¸²ï¼Œä¸€ä¸ªç»´æŠ¤æ‰€æœ‰é•¿åº¦ä¸ºå¶æ•°çš„å›æ–‡å­ä¸²ã€‚æ ‘ä¸Šé™¤æ ¹èŠ‚ç‚¹å¤–çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è¡¨ç¤ºä¸²ä¸­çš„ä¸€ä¸ªå›æ–‡å­ä¸²ã€‚\n èŠ‚ç‚¹å¯¹åº”çš„å›æ–‡å­ä¸²é•¿åº¦ã€‚\n æŒ‡å‘è¯¥èŠ‚ç‚¹æ‰€å¯¹åº”çš„å›æ–‡å­ä¸²çš„æœ€é•¿å›æ–‡åç¼€æ‰€å¯¹åº”çš„èŠ‚ç‚¹ã€‚\n è½¬ç§»åˆ°è¯¥æ ‘çš„å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè½¬ç§»ä¸ºå‘å½“å‰å›æ–‡å­ä¸²ä¸¤ç«¯åŠ ä¸Šä¸€ä¸ªå­—ç¬¦ã€‚\n ä»¥ä¸€ä¸ªä½ç½®ç»“å°¾å¯¹åº”èŠ‚ç‚¹çš„å›æ–‡å­ä¸²ä¸ªæ•°\nä¸ºæ–¹ä¾¿å¤„ç†ï¼Œå¶æ ‘çš„æ ¹çš„  è®¾ä¸º ï¼Œ è®¾ä¸ºå¥‡æ ‘çš„æ ¹ï¼Œå¥‡æ ‘çš„æ ¹çš„  è®¾ä¸º ï¼Œ è®¾ä¸ºå…¶æœ¬èº«ã€‚æ„é€ æ—¶ç”¨å¢é‡æ³•å³å¯ã€‚\nvoid init(){    len[1]=-1,fail[0]=fail[1]=tot=1;}void insert(int i){    int p=las,c=s[i]-'a';    while(s[i-1-len[p]]!=s[i]) p=fail[p];    if(ch[p][c])    {        las=ch[p][c];        return;    }    int x=fail[p],y=++tot;    while(s[i-1-len[x]]!=s[i]) x=fail[x];    fail[y]=ch[x][c],len[y]=len[p]+2,ch[p][c]=las=y,cnt[y]=cnt[fail[y]]+1;}\nå»º  æ ‘ï¼š\nfor(int i=0;i&lt;=tot;++i)    if(i!=1)    \tadd(fail[i],i);\nä¸€ä¸ªå­—ç¬¦ä¸²çš„æœ¬è´¨ä¸åŒå›æ–‡å­ä¸²ä¸ªæ•°å³ä¸ºå…¶å›æ–‡æ ‘é™¤äº†ä¸¤ä¸ªæ ¹çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚å­—ç¬¦ä¸²ä¸­ä¸€ä¸ªä½ç½®çš„å›æ–‡åç¼€ä¸ªæ•°å³ä¸ºè¯¥ä½ç½®å¯¹åº”çš„èŠ‚ç‚¹çš„  é“¾é•¿åº¦ã€‚åœ¨ç»´æŠ¤æ¯ä¸ªæœ¬è´¨ä¸åŒå›æ–‡å­ä¸²çš„å‡ºç°æ¬¡æ•°æ—¶ï¼Œè¿˜éœ€åœ¨  æ ‘ä¸Šç”¨å„¿å­æ¥æ›´æ–°çˆ¶äº²ã€‚\nfor(int i=tot;i;--i) cnt[fail[i]]+=cnt[i];\næœ‰æ—¶è¿˜éœ€ç”¨åˆ° ï¼ŒæŒ‡å‘é•¿åº¦å°äºç­‰äºå…¶å›æ–‡å­ä¸²é•¿åº¦ä¸€åŠçš„æœ€é•¿å›æ–‡åç¼€çš„èŠ‚ç‚¹ï¼Œå»ºæ ‘æ—¶ç»´æŠ¤å³å¯ã€‚\nvoid insert(int i){    int p=las,c=s[i]-'a';    while(s[i-1-len[p]]!=s[i]) p=fail[p];    if(ch[p][c])    {        las=ch[p][c];        return;    }    int x=fail[p],y=++tot;    while(s[i-1-len[x]]!=s[i]) x=fail[x];    fail[y]=ch[x][c],len[y]=len[p]+2,ch[p][c]=las=y;    if(len[y]&lt;=2) trans[y]=fail[y];    else    {        int q=trans[p];        while(s[i-1-len[q]]!=s[i]||(len[q]+2)*2&gt;len[y]) q=fail[q];        trans[y]=ch[q][c];    }}\næ‰©å±• KMPæ‰©å±•  å¯ä»¥  å¾—å‡ºä¸€ä¸ªå­—ç¬¦ä¸²çš„  å‡½æ•°ï¼Œ ä¸ºä»¥  å¼€å¤´çš„åç¼€å’Œæ•´ä¸ªä¸²çš„ ã€‚\nz[1]=n;for(int i=2;i&lt;=n;++i){    if(i&lt;=r) z[i]=min(z[i-l+1],r-i+1);    while(i+z[i]&lt;=n&amp;&amp;s[i+z[i]]==s[z[i]+1]) z[i]++;    if(i+z[i]-1&gt;r) l=i,r=i+z[i]-1;}\nè®¡ç®—å‡ ä½•äºŒç»´å‡¸åŒ…æ±‚å‡¸åŒ…å‘¨é•¿ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 100010#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,top;double ans;int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }}p[maxn],st[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}double operator &amp; (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double dis(const Vec &amp;a,const Vec &amp;b){    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}bool cmp(const Vec &amp;a,const Vec &amp;b){    double A=atan2(a.y-p[1].y,a.x-p[1].x),B=atan2(b.y-p[1].y,b.x-p[1].x);    return sgn(A-B)?A&lt;B:a.x&lt;b.x;}void graham(){\tint k=1;\tfor(int i=2;i&lt;=n;++i)\t\tif(p[i].x&lt;p[k].x||(p[i].x==p[k].x&amp;&amp;p[i].y&lt;p[k].y))\t\t\tk=i;\tswap(p[1],p[k]),sort(p+2,p+n+1,cmp),st[top=1]=p[1];\tfor(int i=2;i&lt;=n;++i)\t{\t\twhile(top&gt;1&amp;&amp;sgn((p[i]-st[top-1])&amp;(st[top]-st[top-1]))&gt;=0) top--;\t\tst[++top]=p[i];\t}}int main(){    read(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y);\tgraham();\tfor(int i=1;i&lt;top;++i) ans+=dis(st[i],st[i+1]);\tprintf(\"%.2lf\",ans+dis(st[top],st[1]));\treturn 0;}\næ—‹è½¬å¡å£³æ±‚å‡¸åŒ…ç›´å¾„ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 50010#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,top;int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }}p[maxn],st[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double operator % (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}int dis(const Vec &amp;a,const Vec &amp;b){    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}bool cmp(const Vec &amp;a,const Vec &amp;b){    double A=atan2(a.y-p[1].y,a.x-p[1].x),B=atan2(b.y-p[1].y,b.x-p[1].x);    return sgn(A-B)?A&lt;B:a.x&lt;b.x;}void graham(){\tint k=1;\tfor(int i=2;i&lt;=n;++i)\t\tif(p[i].x&lt;p[k].x||(p[i].x==p[k].x&amp;&amp;p[i].y&lt;p[k].y))\t\t\tk=i;\tswap(p[1],p[k]),sort(p+2,p+n+1,cmp),st[top=1]=p[1];\tfor(int i=2;i&lt;=n;++i)\t{\t\twhile(top&gt;1&amp;&amp;sgn((p[i]-st[top-1])*(st[top]-st[top-1]))&gt;=0) top--;\t\tst[++top]=p[i];\t}}int calc(){\tif(top==2) return dis(st[1],st[2]);\tint j=3,v=0;;\tst[top+1]=st[1];\tfor(int i=1;i&lt;=top;++i)\t{\t\twhile((st[i+1]-st[i])*(st[j]-st[i])&lt;=(st[i+1]-st[i])*(st[j+1]-st[i])) j=j%top+1;\t\tv=max(v,max(dis(st[j],st[i]),dis(st[j],st[i+1])));\t}\treturn v;}int main(){    read(n);\tfor(int i=1;i&lt;=n;++i) scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y);\tgraham(),printf(\"%d\",calc());\treturn 0;}\nåŠå¹³é¢äº¤æ±‚åŠå¹³é¢äº¤é¢ç§¯ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 510#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}int n,cnt,tot,h,t;int q[maxn];int sgn(double x){    if(fabs(x)&lt;eps) return 0;    return x&gt;0?1:-1;}struct Vec{    double x,y;    Vec(const double a=0,const double b=0)    {        x=a,y=b;    }    void in()    {        scanf(\"%lf%lf\",&amp;x,&amp;y);    }    double len()    {        return sqrt(x*x+y*y);    }}p[maxn];Vec operator + (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x+b.x,a.y+b.y);}Vec operator - (const Vec &amp;a,const Vec &amp;b){    return Vec(a.x-b.x,a.y-b.y);}Vec operator * (const Vec &amp;a,const double &amp;b){    return Vec(a.x*b,a.y*b);}Vec operator / (const Vec &amp;a,const double &amp;b){    return Vec(a.x/b,a.y/b);}double operator * (const Vec &amp;a,const Vec &amp;b){    return a.x*b.y-a.y*b.x;}double operator % (const Vec &amp;a,const Vec &amp;b){    return a.x*b.x+a.y*b.y;}struct Line{    Vec a,b,c;    double k;    void init()    {        c=b-a,k=atan2(c.y,c.x);    }}l[maxn];bool cmp(const Line &amp;u,const Line &amp;v){    return sgn(u.k-v.k)?u.k&lt;v.k:sgn(u.c*(v.b-u.a))==-1;}Vec cross(Line u,Line v){    return v.a+v.c*((v.a-u.a)*u.c)/(u.c*v.c);}bool check(Line u,Line v,Line w){    return sgn(w.c*(cross(u,v)-w.a))==-1;}double get(){    double v=0;    sort(l+1,l+cnt+1,cmp);    for(int i=1;i&lt;=cnt;++i)        if(sgn(l[i].k-l[i-1].k))            l[++tot]=l[i];    q[h=t=1]=1,q[++t]=2;    for(int i=3;i&lt;=tot;++i)    {        while(h&lt;t&amp;&amp;check(l[q[t-1]],l[q[t]],l[i])) t--;        while(h&lt;t&amp;&amp;check(l[q[h]],l[q[h+1]],l[i])) h++;        q[++t]=i;    }    while(h&lt;t&amp;&amp;check(l[q[t-1]],l[q[t]],l[q[h]])) t--;    if(t-h+1&lt;=2) return 0;    q[t+1]=q[h],cnt=0;    for(int i=h;i&lt;=t;++i) p[++cnt]=cross(l[q[i]],l[q[i+1]]);    p[cnt+1]=p[1];    for(int i=1;i&lt;=cnt;++i) v+=p[i]*p[i+1];    return v/2;}int main(){    read(n);    for(int i=1;i&lt;=n;++i)    {        int k;        read(k);        for(int j=1;j&lt;=k;++j)            l[++cnt].b.in(),l[cnt].a=l[cnt-1].b;        l[cnt-k+1].a=l[cnt].b;    }    for(int i=1;i&lt;=cnt;++i) l[i].init();    printf(\"%.3lf\",get());\treturn 0;}\næ•°å­¦FFT#include&lt;bits/stdc++.h&gt;#define maxn 8000010#define Pi acos(-1.0)using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;int rev[maxn];struct Complex{\tdouble x,y;\tComplex(double a=0,double b=0)\t{\t\tx=a,y=b;\t}}f[maxn],g[maxn];Complex operator +(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x+b.x,a.y+b.y);}Complex operator -(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x-b.x,a.y-b.y);}Complex operator *(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void FFT(Complex *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tComplex T(cos(Pi/len),type*sin(Pi/len));\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tComplex t(1,0);\t\t\tfor(int j=i;j&lt;i+len;++j,t=t*T)\t\t\t{\t\t\t\tComplex x=a[j],y=t*a[j+len];\t\t\t\ta[j]=x+y,a[j+len]=x-y;\t\t\t}\t\t}\t}    if(type==1) return;    for(int i=0;i&lt;lim;++i) a[i].x=a[i].x/lim+0.5;}void mul(Complex *f,Complex *g){    int lim=calc(n+m);    FFT(f,lim,1),FFT(g,lim,1);    for(int i=0;i&lt;lim;++i) f[i]=f[i]*g[i];    FFT(f,lim,-1);}int main(){    read(n),read(m);    for(int i=0,x;i&lt;=n;++i) read(x),f[i].x=x;    for(int i=0,x;i&lt;=m;++i) read(x),g[i].x=x;    mul(f,g);    for(int i=0;i&lt;=n+m;++i) printf(\"%d \",(int)f[i].x);    return 0;}\nå¤šé¡¹å¼å…¨å®¶æ¡¶#include&lt;bits/stdc++.h&gt;#define maxn 400010#define P 998244353#define G 3#define Gi (P+1)/Gusing namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,k,T,lenth;ll rev[maxn],f[maxn],g[maxn];char s[maxn];ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%P;        x=x*x%P,y&gt;&gt;=1;    }    return v;}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void NTT(ll *a,int lim,int type){    for(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);    for(int len=1;len&lt;lim;len&lt;&lt;=1)    {        ll wn=qp(type==1?G:Gi,(P-1)/(len&lt;&lt;1));        for(int i=0;i&lt;lim;i+=len&lt;&lt;1)        {            ll w=1;            for(int j=i;j&lt;i+len;++j,w=w*wn%P)            {                ll x=a[j],y=w*a[j+len]%P;                a[j]=(x+y)%P,a[j+len]=(x-y+P)%P;            }        }    }    if(type==1) return;    ll inv=qp(lim,P-2);    for(int i=0;i&lt;lim;++i) a[i]=a[i]*inv%P;}void Inv(int deg,ll *a,ll *b){    static ll t[maxn];    if(deg==1)    {        b[0]=qp(a[0],P-2);        return;    }    Inv((deg+1)&gt;&gt;1,a,b);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=b[i]*(2-t[i]*b[i]%P+P)%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Ln(int deg,ll *a,ll *b){    static ll inva[maxn],dera[maxn];    Inv(deg,a,inva);    for(int i=0;i&lt;deg-1;++i) dera[i]=a[i+1]*(i+1)%P;    dera[deg-1]=0;    int lim=calc(deg&lt;&lt;1);    for(int i=deg;i&lt;lim;++i) dera[i]=inva[i]=0;    NTT(dera,lim,1),NTT(inva,lim,1);    for(int i=0;i&lt;lim;++i) b[i]=dera[i]*inva[i]%P;    NTT(b,lim,-1);    for(int i=deg-1;i&gt;=1;--i) b[i]=b[i-1]*qp(i,P-2)%P;    b[0]=0;    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Exp(int deg,ll *a,ll *b){    static ll t[maxn],lnb[maxn];    if(deg==1)    {        b[0]=1;        return;    }    Exp((deg+1)&gt;&gt;1,a,b),Ln(deg,b,lnb);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1),NTT(lnb,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=b[i]*(1-lnb[i]+t[i]+P)%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}void Pow(int deg,ll *a,ll *b,ll k){    static ll lna[maxn];    Ln(deg,a,lna);    for(int i=0;i&lt;deg;++i) lna[i]=lna[i]*k%P;    Exp(deg,lna,b);}void Sqrt(int deg,ll *a,ll *b){    static ll t[maxn],invb[maxn];    if(deg==1)    {        b[0]=1;        return;    }    Sqrt((deg+1)&gt;&gt;1,a,b);    int lim=calc(deg&lt;&lt;1);    for(int i=0;i&lt;deg;++i) t[i]=2*b[i]%P,invb[i]=0;    for(int i=deg;i&lt;lim;++i) t[i]=invb[i]=0;    Inv(deg,t,invb);    for(int i=0;i&lt;deg;++i) t[i]=a[i];    for(int i=deg;i&lt;lim;++i) t[i]=b[i]=0;    NTT(t,lim,1),NTT(b,lim,1),NTT(invb,lim,1);    for(int i=0;i&lt;lim;++i)        b[i]=(b[i]*b[i]%P+t[i])%P*invb[i]%P;    NTT(b,lim,-1);    for(int i=deg;i&lt;lim;++i) b[i]=0;}int main(){\tread(n);    for(int i=0;i&lt;n;++i) read(f[i]);    Sqrt(n,f,g);    for(int i=0;i&lt;n;++i) printf(\"%lld \",g[i]);\treturn 0;}\nåˆ†æ²» FFT#include&lt;bits/stdc++.h&gt;#define maxn 400010#define p 998244353using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n;int rev[maxn];ll f[maxn],g[maxn];ll qp(ll x,ll y){\tll v=1;\twhile(y)\t{\t\tif(y&amp;1) v=v*x%p;\t\tx=x*x%p,y&gt;&gt;=1;\t}\treturn v;}int calc(int n){\tint lim=1;\twhile(lim&lt;=n) lim&lt;&lt;=1;\tfor(int i=0;i&lt;lim;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);\treturn lim;}void NTT(ll *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)\t\tif(i&lt;rev[i])\t\t\tswap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tll wn=qp(3,(p-1)/(len&lt;&lt;1));\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tll w=1;\t\t\tfor(int j=i;j&lt;i+len;++j,w=w*wn%p)\t\t\t{\t\t\t\tll x=a[j],y=w*a[j+len]%p;\t\t\t\ta[j]=(x+y)%p,a[j+len]=(x-y+p)%p;\t\t\t}\t\t}\t}\tif(type==1) return;\tll inv=qp(lim,p-2);\tfor(int i=0;i&lt;lim;++i) a[i]=a[i]*inv%p;\treverse(a+1,a+lim);}void Inv(int deg,ll *f,ll *g){\tif(deg==1)\t{\t\tg[0]=qp(f[0],p-2);\t\treturn;\t}\tstatic ll t[maxn];\tInv((deg+1)&gt;&gt;1,f,g);\tint lim=calc(deg&lt;&lt;1);\tfor(int i=0;i&lt;deg;++i) t[i]=f[i];\tfor(int i=deg;i&lt;lim;++i) t[i]=0;\tNTT(t,lim,1),NTT(g,lim,1);\tfor(int i=0;i&lt;lim;++i) g[i]=(2*g[i]-t[i]*g[i]%p*g[i]%p+p)%p;\tNTT(g,lim,-1);\tfor(int i=deg;i&lt;lim;++i) g[i]=0;}int main(){\tread(n),f[0]=1;\tfor(int i=1;i&lt;n;++i) read(f[i]),f[i]=p-f[i];\tInv(n,f,g);\tfor(int i=0;i&lt;n;++i) printf(\"%lld \",g[i]);    return 0;}\nä»»æ„æ¨¡æ•°å¤šé¡¹å¼ä¹˜æ³•#include&lt;bits/stdc++.h&gt;#define maxn 800010#define all 262144#define M 32767#define Pi acos(-1.0)using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,p;int rev[maxn],f[maxn],g[maxn],h[maxn];struct Complex{\tlong double x,y;\tComplex(long double a=0,long double b=0)\t{\t\tx=a,y=b;\t}}w[maxn];Complex operator +(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x+b.x,a.y+b.y);}Complex operator -(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x-b.x,a.y-b.y);}Complex operator *(const Complex &amp;a,const Complex &amp;b){\treturn Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}Complex operator ~(const Complex &amp;a){\treturn Complex(a.x,-a.y);}int calc(int n){    int lim=1;    while(lim&lt;=n) lim&lt;&lt;=1;    for(int i=0;i&lt;lim;++i)        rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?lim&gt;&gt;1:0);    return lim;}void init(int n){    int lim=calc(n);    for(int len=1;len&lt;lim;len&lt;&lt;=1)        for(int i=0;i&lt;len;++i)            w[i+len]=Complex(cos(Pi*i/len),sin(Pi*i/len));}void FFT(Complex *a,int lim,int type){\tfor(int i=0;i&lt;lim;++i)        if(i&lt;rev[i])            swap(a[i],a[rev[i]]);\tfor(int len=1;len&lt;lim;len&lt;&lt;=1)\t{\t\tfor(int i=0;i&lt;lim;i+=len&lt;&lt;1)\t\t{\t\t\tfor(int j=0;j&lt;len;++j)\t\t\t{\t\t\t\tComplex x=a[i+j],y=w[j+len]*a[i+j+len];\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\t\t\t}\t\t}\t}    if(type==1) return;    reverse(a+1,a+lim);    for(int i=0;i&lt;lim;++i)        a[i].x=a[i].x/lim+0.5,a[i].y=a[i].y/lim+0.5;} void MTT(int *f,int *g,int *h){    static Complex a[maxn],b[maxn],a0[maxn],b0[maxn];    int lim=calc(n+m);    for(int i=0;i&lt;lim;++i) a[i]=Complex(f[i]&gt;&gt;15,f[i]&amp;M);    for(int i=0;i&lt;lim;++i) b[i]=Complex(g[i]&gt;&gt;15,g[i]&amp;M);    FFT(a,lim,1),FFT(b,lim,1),a0[0]=~a[0],b0[0]=~b[0];    for(int i=1;i&lt;lim;++i) a0[i]=~a[lim-i],b0[i]=~b[lim-i];    for(int i=0;i&lt;lim;++i)    {        Complex v1=a[i],v2=a0[i],v3=b[i],v4=b0[i];        a[i]=(v1+v2)*Complex(0.5,0),a0[i]=(v1-v2)*Complex(0,-0.5);        b[i]=(v3+v4)*Complex(0.5,0),b0[i]=(v3-v4)*Complex(0,-0.5);    }    for(int i=0;i&lt;lim;++i)        a[i]=a[i]*b[i]+(a[i]*b0[i]+a0[i]*b[i])*Complex(0,1),b[i]=a0[i]*b0[i];    FFT(a,lim,-1),FFT(b,lim,-1);    for(int i=0;i&lt;lim;++i)        h[i]=((((ll)a[i].x%p&lt;&lt;30)%p+((ll)a[i].y%p&lt;&lt;15)%p)%p+(ll)b[i].x)%p;}int main(){    read(n),read(m),read(p),n++,m++,init(n+m);    for(int i=0;i&lt;n;++i) read(f[i]),f[i]%=p;    for(int i=0;i&lt;m;++i) read(g[i]),g[i]%=p;    MTT(f,g,h);    for(int i=0;i&lt;n+m-1;++i) printf(\"%d \",h[i]);    return 0;}\nFWT#include&lt;bits/stdc++.h&gt;#define maxn 131082#define p 998244353#define inv 499122177using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,all;ll va[maxn],vb[maxn],a[maxn],b[maxn];void FWT_or(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t\ta[j+len]=(a[j+len]+a[j]*type+p)%p;}void FWT_and(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t\ta[j]=(a[j]+a[j+len]*type+p)%p;}void FWT_xor(ll *a,int type){\tfor(int len=1;len&lt;all;len&lt;&lt;=1)\t{\t\tfor(int i=0;i&lt;all;i+=len&lt;&lt;1)\t\t{\t\t\tfor(int j=i;j&lt;i+len;++j)\t\t\t{\t\t\t\tll x=a[j],y=a[j+len];\t\t\t\ta[j]=(x+y)%p,a[j+len]=(x-y+p)%p;\t\t\t\tif(type==-1) a[j]=a[j]*inv%p,a[j+len]=a[j+len]*inv%p;\t\t\t}\t\t}\t}}void copy(){\tmemcpy(a,va,sizeof(va)),memcpy(b,vb,sizeof(vb));}void Or(){\tcopy(),FWT_or(a,1),FWT_or(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_or(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\tputchar('\\n');}void And(){\tcopy(),FWT_and(a,1),FWT_and(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_and(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\t\tputchar('\\n');}void Xor(){\tcopy(),FWT_xor(a,1),FWT_xor(b,1);\tfor(int i=0;i&lt;all;++i) a[i]=a[i]*b[i]%p;\tFWT_xor(a,-1);\tfor(int i=0;i&lt;all;++i) printf(\"%lld \",a[i]);\tputchar('\\n');}int main(){\tread(n),all=1&lt;&lt;n;\tfor(int i=0;i&lt;all;++i) read(va[i]);\tfor(int i=0;i&lt;all;++i) read(vb[i]);\tOr(),And(),Xor();    return 0;}\nå­é›†å·ç§¯#include&lt;bits/stdc++.h&gt;#define maxn 21#define maxs 1200010#define p 1000000009#define lowbit(x) (x&amp;(-x))using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,all;int cnt[maxs],h[maxn][maxs],f[maxn][maxs],g[maxn][maxs];void FWT(int *a,int type){    for(int len=1;len&lt;all;len&lt;&lt;=1)        for(int i=0;i&lt;all;i+=len&lt;&lt;1)            for(int j=i;j&lt;i+len;++j)                a[j+len]=((a[j+len]+a[j]*type)%p+p)%p;}int main(){    read(n),all=1&lt;&lt;n;    for(int i=1;i&lt;all;++i) cnt[i]=cnt[i-lowbit(i)]+1;    for(int i=0;i&lt;all;++i) read(f[cnt[i]][i]);    for(int i=0;i&lt;all;++i) read(g[cnt[i]][i]);    for(int i=0;i&lt;=n;++i) FWT(f[i],1),FWT(g[i],1);    for(int i=0;i&lt;=n;++i)        for(int j=0;j&lt;=i;++j)            for(int s=0;s&lt;all;++s)                h[i][s]=(h[i][s]+(ll)f[i-j][s]*g[j][s]%p)%p;    for(int i=0;i&lt;=n;++i) FWT(h[i],-1);    for(int i=0;i&lt;all;++i) printf(\"%lld \",h[cnt[i]][i]);    return 0;}\næ‹‰æ ¼æœ—æ—¥æ’å€¼æ³• ä¸ªç‚¹  å¯ä»¥å”¯ä¸€åœ°ç¡®å®šä¸€ä¸ªå¤šé¡¹å¼ ã€‚ç°åœ¨ï¼Œç»™å®šè¿™  ä¸ªç‚¹ï¼Œè¯·ä½ ç¡®å®šè¿™ä¸ªå¤šé¡¹å¼ï¼Œå¹¶æ±‚å‡º  çš„å€¼ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 2010#define mod 998244353using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag)x=-x;}ll n,k,ans;ll x[maxn],y[maxn];ll qp(ll x,ll y){\tll ans=1;\twhile(y)\t{\t\tif(y&amp;1) ans=(ans*x)%mod;\t\tx=(x*x)%mod;\t\ty&gt;&gt;=1;\t}\treturn ans;}int main(){\tread(n),read(k);\tfor(int i=1;i&lt;=n;++i) read(x[i]),read(y[i]);\tfor(int i=1;i&lt;=n;++i)\t{\t\tll p=1;\t\tfor(int j=1;j&lt;=n;++j)\t\t\tif(i!=j)\t\t\t\tp=p*(((x[i]-x[j])%mod+mod)%mod)%mod;\t\tp=qp(p,mod-2);\t\tfor(int j=1;j&lt;=n;++j)\t\t\tif(i!=j)\t\t\t\tp=p*(((k-x[j])%mod+mod)%mod)%mod;\t\tp=p*y[i]%mod;\t\tans=(ans+p)%mod;\t}\tprintf(\"%lld\\n\",ans);\treturn 0;}\nçŸ©é˜µæ ‘å®šç†ç»™å®šä¸€å¼   ä¸ªç»“ç‚¹  æ¡è¾¹çš„å¸¦æƒå›¾ï¼ˆå¯èƒ½ä¸ºæ— å‘å›¾ï¼Œå¯èƒ½ä¸ºæœ‰å‘å›¾ï¼‰ã€‚å®šä¹‰å…¶ä¸€ä¸ªç”Ÿæˆæ ‘  çš„æƒå€¼ä¸º  ä¸­æ‰€æœ‰è¾¹æƒçš„ä¹˜ç§¯ã€‚æ±‚å…¶æ‰€æœ‰ä¸åŒç”Ÿæˆæ ‘çš„æƒå€¼ä¹‹å’Œï¼Œå¯¹  å–æ¨¡ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 310#define p 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,type;ll a[maxn][maxn];void add1(int x,int y,int v){    a[x][x]=(a[x][x]+v)%p;    a[y][y]=(a[y][y]+v)%p;    a[x][y]=(a[x][y]-v)%p;    a[y][x]=(a[y][x]-v)%p;}void add2(int x,int y,int v){    a[y][y]=(a[y][y]+v)%p;    a[x][y]=(a[x][y]-v)%p;}ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll det(){    ll ans=1;    for(int i=2;i&lt;=n;++i)    {        int ma=i;        for(int j=i+1;j&lt;=n;++j)            if(a[j][i]&gt;a[ma][i])                ma=j;        if(ma!=i) swap(a[i],a[ma]),ans*=-1;        if(!a[i][i]) return 0;        ll inv=qp(a[i][i],p-2);        for(int j=i+1;j&lt;=n;++j)        {            ll d=a[j][i]*inv%p;            for(int k=i;k&lt;=n;++k) a[j][k]=((a[j][k]-a[i][k]*d%p)%p+p)%p;        }        ans=ans*a[i][i]%p;    }    return (ans%p+p)%p;}int main(){    read(n),read(m),read(type);    for(int i=1;i&lt;=m;++i)    {        int a,b,v;        read(a),read(b),read(v);        if(!type) add1(a,b,v);        else add2(a,b,v);    }    printf(\"%lld\",det());    return 0;}\né«˜æ–¯æ¶ˆå…ƒ#include&lt;bits/stdc++.h&gt;#define maxn 110#define eps 1e-8using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}int n;double a[maxn][maxn];bool gauss(){    for(int i=1;i&lt;=n;++i)    {        int ma=i;        for(int j=i+1;j&lt;=n;++j)            if(fabs(a[j][i])&gt;fabs(a[ma][i]))                ma=j;        swap(a[ma],a[i]);        double d=a[i][i];        if(fabs(d)&lt;eps) return false;        for(int j=i;j&lt;=n+1;++j) a[i][j]/=d;        for(int j=i+1;j&lt;=n;++j)        {            d=a[j][i];            for(int k=i;k&lt;=n+1;++k)                a[j][k]-=a[i][k]*d;        }    }    for(int i=n;i;--i)        for(int j=i-1;j;--j)            a[j][n+1]-=a[j][i]*a[i][n+1];    return true;}int main(){\tread(n);    for(int i=1;i&lt;=n;++i)    {        for(int j=1;j&lt;=n+1;++j)        {            int val;            read(val);            a[i][j]=val;        }    }    if(!gauss())    {        puts(\"No Solution\");        return 0;    }    for(int i=1;i&lt;=n;++i)         printf(\"%.2lf\\n\",a[i][n+1]);\treturn 0;}\nçŸ©é˜µæ±‚é€†#include&lt;bits/stdc++.h&gt;#define maxn 810#define mod 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m;ll a[maxn][maxn];ll inv(ll x){    ll y=mod-2,ans=1;    while(y)    {        if(y&amp;1) ans=ans*x%mod;        x=x*x%mod;        y&gt;&gt;=1;    }    return ans;}bool gauss(){    for(int i=1;i&lt;=n;++i)    {        for(int j=i;j&lt;=n;++j)        {               if(a[j][i])            {                swap(a[j],a[i]);                break;            }        }        if(!a[i][i]) return false;        ll d=inv(a[i][i]);        for(int j=i;j&lt;=m;++j) a[i][j]=a[i][j]*d%mod;        for(int j=1;j&lt;=n;++j)        {            if(i==j) continue;            d=a[j][i]%mod;            for(int k=i;k&lt;=m;++k)                a[j][k]=((a[j][k]-a[i][k]*d%mod)%mod+mod)%mod;        }    }    return true;}int main(){    read(n),m=2*n;    for(int i=1;i&lt;=n;++i)    {        for(int j=1;j&lt;=n;++j) read(a[i][j]);        a[i][i+n]=1;    }    if(gauss())    {        for(int i=1;i&lt;=n;++i)        {            for(int j=n+1;j&lt;=m;++j)                printf(\"%lld \",a[i][j]);            puts(\"\");        }    }    else puts(\"No Solution\");    return 0;}\næ¬§æ‹‰ç­›void init(){    mu[1]=1;    for(int i=2;i&lt;=all;++i)    {        if(!tag[i]) pri[++tot]=i,mu[i]=-1;        for(int j=1;j&lt;=tot;++j)        {            int k=i*pri[j];            if(k&gt;all) break;            tag[k]=true;            if(i%pri[j]) mu[k]=mu[i]*mu[pri[j]];            else            {                mu[k]=0;                break;            }        }    }}\nPollardâ€™s rhoæ±‚æœ€å¤§è´¨å› å­ã€‚\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll T,n,fac_max;ll pri[14]={2,3,5,7,11,13,17,19,23,29};ll mul(ll x,ll y,ll mod){\tll c=(long double)x*y/mod+0.5;\tc=x*y-c*mod;\treturn c&lt;0?c+mod:c;}ll qp(ll x,ll y,ll mod){    ll ans=1;    while(y)    {        if(y&amp;1) ans=mul(ans,x,mod);        x=mul(x,x,mod);        y&gt;&gt;=1;    }    return ans%mod;}bool check(ll x,ll p,ll mod){    ll t=qp(x,p,mod);    if(t==mod-1) return true;    if(t==1) return p&amp;1?true:check(x,p/2,mod);    return false;}bool Miller_Rabin(ll n){    if(n==1) return false;    if(n&lt;=3) return true;    if(!(n&amp;1)) false;    for(int i=0;i&lt;10;++i)    {        if(n==pri[i]) return true;        if(!check(pri[i],n-1,n)) return false;    }    return true;}ll gcd(ll a,ll b){    return b?gcd(b,a%b):a;}ll f(ll x,ll y,ll mod){    return (mul(x,x,mod)+y)%mod;}ll Pollard_Rho(ll x){    ll s=0,t=0,c=(ll)1*rand()%(x-1)+1,val=1;    for(ll goal=1;;goal&lt;&lt;=1,s=t,val=1)    {        for(ll step=1;step&lt;=goal;++step)        {            t=f(t,c,x);            val=mul(val,abs(t-s),x);            if(step%127==0)            {                ll d=gcd(val,x);                if(d&gt;1) return d;            }        }        ll d=gcd(val,x);        if(d&gt;1) return d;    }}void fac(ll x){    if(x&lt;=fac_max||x&lt;2) return;    if(Miller_Rabin(x))     {        fac_max=max(fac_max,x);        return;    }    ll p=x;    while(p&gt;=x) p=Pollard_Rho(x);    while(x%p==0) x/=p;    fac(x),fac(p);}int main(){    read(T);    while(T--)    {        srand(114514);        read(n);        fac_max=0;        fac(n);        if(fac_max==n) puts(\"Prime\");        else printf(\"%lld\\n\",fac_max);    }\treturn 0;}\næœæ•™ç­›æ±‚  çš„å‰ç¼€å’Œã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 5000010#define all 5000000using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n,tot;ll p[maxn],phi[maxn],mu[maxn];bool tag[maxn];unordered_map&lt;int,ll&gt; s_phi,s_mu;void init(){    mu[1]=phi[1]=1;    for(int i=2;i&lt;=all;++i)    {        if(!tag[i]) p[++tot]=i,phi[i]=i-1,mu[i]=-1;        for(int j=1;j&lt;=tot;++j)        {            int k=i*p[j];            if(k&gt;all) break;            tag[k]=true;            if(i%p[j]) phi[k]=phi[i]*phi[p[j]],mu[k]=mu[i]*mu[p[j]];            else            {                mu[k]=0,phi[k]=phi[i]*p[j];                break;               }        }    }    for(int i=1;i&lt;=all;++i) phi[i]+=phi[i-1],mu[i]+=mu[i-1];}ll getphi(ll n){    if(n&lt;=all) return phi[n];    if(s_phi[n]) return s_phi[n];    ll v=n*(n+1)/2;    for(int l=2,r;l&lt;=n;l=r+1)        r=n/(n/l),v-=(r-l+1)*getphi(n/l);    return s_phi[n]=v;}ll getmu(ll n){    if(n&lt;=all) return mu[n];    if(s_mu[n]) return s_mu[n];    ll v=1;    for(int l=2,r;l&lt;=n;l=r+1)        r=n/(n/l),v-=(r-l+1)*getmu(n/l);    return s_mu[n]=v;}int main(){    init(),read(T);    while(T--) read(n),printf(\"%lld %lld\\n\",getphi(n),getmu(n));    return 0;}\næ‰©å±• BSGSç»™å®š ï¼Œæ±‚æ»¡è¶³  çš„æœ€å°è‡ªç„¶æ•° ã€‚\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll a,b,p,x,y,ans;unordered_map&lt;ll,int&gt; h;ll qp(ll x,ll y,ll p){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll exgcd(ll a,ll b){    if(!b)    {        x=1,y=0;        return a;    }    ll g=exgcd(b,a%b),tmp=x;    x=y,y=tmp-a/b*y;    return g;}ll inv(ll a,ll p){    exgcd(a,p);    return (x%p+p)%p;}ll bsgs(ll a,ll b,ll p){    ll s=ceil(sqrt(p)),v=b,val;    for(int i=0;i&lt;=s;++i,v=v*a%p) h[v]=i;    v=val=qp(a,s,p);    for(int i=1;i&lt;=s;++i,v=v*val%p)        if(h.count(v))            return i*s-h[v];    return -1;}ll exbsgs(ll a,ll b,ll p){    a%=p,b%=p;    if(b==1||p==1) return 0;    ll g,cnt=0,mul=1,v=a;    for(int i=1;i&lt;=30;++i,v=v*a%p)        if(v==b)            return i;    while((g=exgcd(a,p))!=1)    {        if(b%g!=0) return -1;        cnt++,b/=g,p/=g,mul=mul*(a/g)%p;    }    ll ans=bsgs(a,b*inv(mul,p)%p,p);    if(~ans) return ans+cnt;    return -1;}int main(){    while(1)    {        read(a),read(p),read(b);        if(!a&amp;&amp;!b&amp;&amp;!p) break;        h.clear(),ans=exbsgs(a,b,p);        if(~ans) printf(\"%lld\\n\",ans);        else puts(\"No Solution\");    }\treturn 0;}\næ‰©å±•ä¸­å›½å‰©ä½™å®šç†ç»™å®š   ç»„éè´Ÿæ•´æ•°   ï¼Œæ±‚è§£å…³äº   çš„æ–¹ç¨‹ç»„çš„æœ€å°éè´Ÿæ•´æ•°è§£ã€‚\n\n\\begin{cases} x \\equiv b_1\\ ({\\rm mod}\\ a_1) \\\\ x\\equiv b_2\\ ({\\rm mod}\\ a_2) \\\\ ... \\\\ x \\equiv b_n\\ ({\\rm mod}\\ a_n)\\end{cases}#include&lt;bits/stdc++.h&gt;#define maxn 100010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}\tif(flag) x=-x;}ll n,x,y;ll a[maxn],m[maxn];ll mul(ll x,ll y,ll mod){    ll ans=0;    while(y)     {        if(y&amp;1) ans=(ans+x)%mod;        x=(x+x)%mod;        y&gt;&gt;=1;    }    return ans%mod;}ll exgcd(ll a,ll b){    if(!b)    {        x=1,y=0;        return a;    }    ll ans=exgcd(b,a%b);    ll tmp=x;    x=y,y=tmp-a/b*y;    return ans;}ll excrt(){    ll ans=a[1],M=m[1];    for(int i=2;i&lt;=n;++i)    {        ll g=exgcd(M,m[i]),tmp=((a[i]-ans)%m[i]+m[i])%m[i];        if(tmp%g!=0) return -1;        ans+=mul(x,tmp/g,m[i])*M,M*=m[i]/g,ans=(ans%M+M)%M;    }    return ans;}int main(){    read(n);    for(int i=1;i&lt;=n;++i) read(m[i]),read(a[i]);    printf(\"%lld\",excrt());\treturn 0;}\næ‰©å±•æ¬§æ‹‰å®šç†ç»™ä½ ä¸‰ä¸ªæ­£æ•´æ•°ï¼Œï¼Œä½ éœ€è¦æ±‚ï¼šã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 20000010 using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll a,m,b,phi,len;char s[maxn];bool flag;ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%m;        x=x*x%m,y&gt;&gt;=1;    }    return v%m;}ll get_phi(ll x){\tll v=x,t=sqrt(x);\tfor(int i=2;i&lt;=t;++i)    {\t\tif(x%i) continue;\t\tv=v*(i-1)/i;\t\twhile(x%i==0) x/=i;\t}\tif(x&gt;1) v=v*(x-1)/x;\treturn v;}int main(){\tread(a),read(m),phi=get_phi(m);    scanf(\"%s\",s+1),len=strlen(s+1);    for(int i=1;i&lt;=len;++i)     {        b=((b&lt;&lt;1)+(b&lt;&lt;3)+(s[i]^48));        if(b&gt;=phi) b%=phi,flag=true;    }    if(flag) b+=phi;    printf(\"%lld\",qp(a,b));\treturn 0;}\næ‰©å±•å¢å¡æ–¯å®šç†æ±‚ ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 12#define maxm 1000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll n,m,p,cnt;ll pri[maxn],pk[maxn],a[maxn][maxm];void exgcd(ll a,ll b,ll &amp;x,ll &amp;y){    if(!b) x=1,y=0;    else exgcd(b,a%b,y,x),y-=a/b*x;}ll inv(ll a,ll p){    ll x,y;    exgcd(a,p,x,y);    return (x%p+p)%p;}ll qp(ll x,ll y,ll p){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll f(ll n,int x){    if(!n) return 1;    ll k=pk[x];    return f(n/pri[x],x)*qp(a[x][k],n/k,k)%k*a[x][n%k]%k;}ll C(ll n,ll m,int x){    ll v=0,p=pri[x],k=pk[x];    for(ll i=n;i;i=i/p) v+=i/p;    for(ll i=m;i;i=i/p) v-=i/p;    for(ll i=n-m;i;i=i/p) v-=i/p;    return f(n,x)*inv(f(m,x),k)%k*inv(f(n-m,x),k)%k*qp(p,v,k)%k;}ll crt(ll x,ll m,ll p){    return x*(m/p)*inv(m/p,p);}ll exlucas(ll n,ll m){    ll v=0;    for(int i=1;i&lt;=cnt;++i) v=(v+crt(C(n,m,i),p,pk[i]))%p;    return v;}void init(int x){    a[x][0]=1;    for(int i=1;i&lt;=pk[x];++i)    {        a[x][i]=a[x][i-1];        if(i%pri[x]) a[x][i]=a[x][i]*i%pk[x];    }}void pre(ll x){    for(int i=2;i*i&lt;=x;++i)    {        if(x%i) continue;        ll v=1;        while(x%i==0) x/=i,v*=i;        pri[++cnt]=i,pk[cnt]=v;    }    if(x!=1) pri[++cnt]=x,pk[cnt]=x;    for(int i=1;i&lt;=cnt;++i) init(i);}int main(){    read(n),read(m),read(p),pre(p),printf(\"%lld\",exlucas(n,m));    return 0;}\näºŒæ¬¡å‰©ä½™ç»™å‡º ï¼Œæ±‚è§£æ–¹ç¨‹ ï¼Œä¿è¯  æ˜¯å¥‡ç´ æ•°ã€‚\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n,p,t,v1,v2;struct Complex{    ll x,y;    Complex(ll a=0,ll b=0)    {        x=a,y=b;    }};Complex operator * (const Complex &amp;a,const Complex &amp;b){    return Complex((a.x*b.x%p+a.y*b.y%p*t%p)%p,(a.x*b.y%p+a.y*b.x%p)%p);}Complex qp(Complex x,ll y){    Complex v=Complex(1,0);    while(y)    {        if(y&amp;1) v=v*x;        x=x*x,y&gt;&gt;=1;    }    return v;}ll qp(ll x,ll y){    ll v=1;    while(y)    {        if(y&amp;1) v=v*x%p;        x=x*x%p,y&gt;&gt;=1;    }    return v;}ll solve(ll n,ll p){    if(p==2) return n;    if(qp(n,(p-1)/2)==p-1) return -1;    ll a;    while(true)    {        a=rand()%p,t=((a*a%p-n)%p+p)%p;        if(qp(t,(p-1)/2)==p-1) break;    }    return qp(Complex(a,1),(p+1)/2).x;}int main(){    read(T);    while(T--)    {        read(n),read(p),n%=p;        if(!n)        {            puts(\"0\");            continue;        }        v1=solve(n,p);        if(v1==-1)        {            puts(\"Hola!\");            continue;        }        v2=p-v1;        if(v1&gt;v2) swap(v1,v2);        if(v1==v2) printf(\"%lld\\n\",v1);        else printf(\"%lld %lld\\n\",v1,v2);    }    return 0;}\næ‚é¡¹çŸ©é˜µå¿«é€Ÿå¹‚#include&lt;bits/stdc++.h&gt;#define p 1000000007using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}ll T,n;struct matrix{    ll a[6][6];    matrix()    {        memset(a,0,sizeof(a));    }}m,ans;matrix operator *(const matrix &amp;a,const matrix &amp;b){    matrix c;    for(int i=0;i&lt;5;++i)        for(int j=0;j&lt;5;++j)            for(int k=0;k&lt;5;++k)                c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%p+p)%p;    return c;}matrix qp(matrix x,ll y){    matrix e;    for(int i=0;i&lt;5;++i) e.a[i][i]=1;    while(y)    {        if(y&amp;1) e=e*x;        x=x*x,y&gt;&gt;=1;    }    return e;}ll m1[6][6]={    {2,0,1,1,1}};ll m2[6][6]={    {1,1,0,0,0},    {1,0,0,0,0},    {2,0,1,1,1},    {0,0,1,0,0},    {2,0,0,0,1}};int main(){    read(T);    memcpy(ans.a,m1,sizeof(ans.a));    memcpy(m.a,m2,sizeof(m.a));    while(T--)    {        read(n);        if(n&lt;3) puts(\"0\");        else printf(\"%lld\\n\",(ans*qp(m,n-3)).a[0][0]);    }    return 0;}\næ¨¡æ‹Ÿé€€ç«æœ€å¤§åŒ–\n#include&lt;bits/stdc++.h&gt;#define maxn 55#define eps 1e-10using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,ans,cnt=1000;struct node{    int a,b;}p[maxn];int calc(){    int v=0;    for(int i=1;i&lt;=n+m;++i)    {        v+=p[i].a+p[i].b;        if(p[i-1].a==10) v+=p[i].a+p[i].b;        else if(p[i-1].a+p[i-1].b==10) v+=p[i].a;    }    return v;}void SA(){    double T=1000000,delta=0.9895;\twhile(T&gt;eps)\t{\t\tint x=rand()%(n+m)+1,y=rand()%(n+m)+1,v;        while(x==y||(m&amp;&amp;(x==n||y==n))) x=rand()%(n+m)+1,y=rand()%(n+m)+1;\t\tswap(p[x],p[y]),v=calc();\t\tif(v&gt;ans) ans=v;\t\telse if(exp((v-ans)/T)*RAND_MAX&lt;rand()) swap(p[x],p[y]);\t\tT*=delta;\t}}int main(){    srand((long long)new char),read(n);    for(int i=1;i&lt;=n;++i) read(p[i].a),read(p[i].b);    if(p[n].a==10) m=1,read(p[n+1].a),read(p[n+1].b);    while(cnt--) SA();    printf(\"%d\",ans);    return 0;}\næœ€å°åŒ–\n#include&lt;bits/stdc++.h&gt;#define maxn 35#define inf 200000000using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){\tx=0;char c=getchar();bool flag=false;\twhile(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\twhile(isdigit(c)){x=x*10+(c^48);c=getchar();}\tif(flag)x=-x;}int t,n,num;int a[maxn];int ans;int work(){\tint u=0,v=0;\tfor(int i=1;i&lt;=(n+1)/2;++i) u+=a[i];\tfor(int i=(n+1)/2+1;i&lt;=n;++i) v+=a[i];\treturn abs(u-v);}void SA(){\tdouble T=3000,delta=0.925;\twhile(T&gt;1e-10)\t{\t\tint x=rand()%n+1, y=rand()%n+1;\t\tswap(a[x],a[y]);\t\tint now=work();\t\tif(now&lt;ans) ans=now;\t\telse if(exp((ans-now)/T)*RAND_MAX&lt;rand())  swap(a[x],a[y]);\t\tT*=delta;\t}}void clear(){\tans=inf;\tnum=1111;}int main(){\tsrand(19260817);\tread(t);\twhile(t--)\t{\t\tclear();\t\tread(n);\t\tfor(int i=1;i&lt;=n;++i) read(a[i]);\t\twhile(num--) SA();\t\tprintf(\"%d\\n\",ans);\t}\treturn 0;}\næ•´ä½“äºŒåˆ†å¸¦ä¿®åŒºé—´ç¬¬  å°ã€‚\n#include&lt;bits/stdc++.h&gt;#define maxn 600010#define inf 1000000000#define lowbit(x) (x&amp;(-x))using namespace std;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m,cnt;int a[maxn],ans[maxn],tr[maxn];char s[8];struct node{    int l,r,k,id,pos;}p[maxn],q1[maxn],q2[maxn];void update(int x,int v){    while(x&lt;=n)        tr[x]+=v,x+=lowbit(x);}int query(int x){    int ans=0;    while(x)        ans+=tr[x],x-=lowbit(x);    return ans;}void solve(int L,int R,int l,int r){    if(L&gt;R) return;    if(l==r)    {        for(int i=L;i&lt;=R;++i)            if(p[i].l)                ans[p[i].id]=l;        return;    }    int mid=(l+r)&gt;&gt;1,cnt1=0,cnt2=0;    for(int i=L;i&lt;=R;++i)    {        if(p[i].l)        {            int v=query(p[i].r)-query(p[i].l-1);            if(p[i].k&lt;=v) q1[++cnt1]=p[i];            else p[i].k-=v,q2[++cnt2]=p[i];        }        else        {            if(p[i].k&lt;=mid) q1[++cnt1]=p[i],update(p[i].pos,p[i].id);            else q2[++cnt2]=p[i];        }    }    for(int i=1;i&lt;=cnt1;++i) p[L+i-1]=q1[i];    for(int i=1;i&lt;=cnt2;++i) p[L+cnt1+i-1]=q2[i];    for(int i=1;i&lt;=cnt1;++i)        if(q1[i].pos)            update(q1[i].pos,-q1[i].id);    solve(L,L+cnt1-1,l,mid),solve(L+cnt1,R,mid+1,r);}int main(){    read(n),read(m);    for(int i=1;i&lt;=n;++i)        read(a[i]),p[++cnt].k=a[i],p[cnt].pos=i,p[cnt].id=1;    for(int i=1;i&lt;=m;++i)    {        scanf(\"%s\",s);        if(s[0]=='Q')            read(p[++cnt].l),read(p[cnt].r),read(p[cnt].k),p[cnt].id=i;        else        {            int x,y;            read(x),read(y);            p[++cnt].k=a[x],p[cnt].pos=x,p[cnt].id=-1;            p[++cnt].k=a[x]=y,p[cnt].pos=x,p[cnt].id=1;        }    }    solve(1,cnt,-inf,inf);    for(int i=1;i&lt;=cnt;++i)        if(ans[i])            printf(\"%d\\n\",ans[i]);    return 0;}\næ ‘å“ˆå¸Œ#include&lt;bits/stdc++.h&gt;#define fi first#define se second#define mp make_pair#define pb push_backusing namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;template&lt;typename T&gt; bool chkmax(T &amp;x,T y){return x&lt;y?x=y,1:0;}template&lt;typename T&gt; bool chkmin(T &amp;x,T y){return x&gt;y?x=y,1:0;}int readint(){\tint x=0,f=1; char ch=getchar();\twhile(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}\treturn x*f;}int n,tot,cnt;int v[2000005],nxt[2000005],h[1000005];ull hs[1000005];mt19937_64 mrand(chrono::steady_clock::now().time_since_epoch().count());void addedge(int x,int y){\tv[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\tv[++tot]=x; nxt[tot]=h[y]; h[y]=tot;}ull f(ull x){return x*x*x+x+7;}ull calc(ull x){return f(x);}void dfs(int u,int fa){\ths[u]=1;\tfor(int p=h[u];p;p=nxt[p]){\t\tif(v[p]==fa) continue;\t\tdfs(v[p],u);\t\ths[u]+=hs[v[p]];\t}\ths[u]=calc(hs[u]);}int main(){\tn=readint();\tfor(int i=1;i&lt;n;i++) addedge(readint(),readint());\tdfs(1,-1);\tsort(hs+1,hs+n+1);\tprintf(\"%d\\n\",unique(hs+1,hs+n+1)-hs-1);\treturn 0;}\nPrufer åºåˆ—#include&lt;bits/stdc++.h&gt;#define maxn 5000010using namespace std;typedef long long ll;template&lt;typename T&gt; inline void read(T &amp;x){    x=0;char c=getchar();bool flag=false;    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}    while(isdigit(c)){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48);c=getchar();}    if(flag)x=-x;}int n,m;ll ans;ll fa[maxn],p[maxn],d[maxn];void Prufer(){    for(int i=1;i&lt;n;++i) read(fa[i]),d[fa[i]]++;    int pos=1;    for(int i=1;i&lt;=n-2;++i)    {        while(d[pos]) pos++;        p[i]=fa[pos];        while(i&lt;=n-2&amp;&amp;--d[p[i]]==0&amp;&amp;p[i]&lt;pos) p[i+1]=fa[p[i]],i++;        pos++;    }    for(int i=1;i&lt;=n-2;++i) ans^=i*p[i];}void Father(){    for(int i=1;i&lt;=n-2;++i) read(p[i]),d[p[i]]++;    p[n-1]=n;    int pos=1;    for(int i=1;i&lt;n;++i)    {        while(d[pos]) pos++;        fa[pos]=p[i];        while(i&lt;n&amp;&amp;--d[p[i]]==0&amp;&amp;p[i]&lt;pos) fa[p[i]]=p[i+1],i++;        pos++;    }    for(int i=1;i&lt;n;++i) ans^=i*fa[i];}int main(){    read(n),read(m);    if(m==1) Prufer();    else Father();    printf(\"%lld\",ans);    return 0;}\né«˜ç²¾åº¦struct bign{     int len, s[30005];    bign (){        memset(s, 0, sizeof(s));        len = 1;    }    bign (int num) { *this = num; }    bign (const char *num) { *this = num; }    bign operator = (const int num){        char s[30005];        sprintf(s, \"%d\", num);        *this = s;        return *this;    }    void clean(){        while(len &gt; 1 &amp;&amp; !s[len-1]) len--;    }     bign operator = (const char *num){        memset(s, 0, sizeof s);        len = strlen(num);        for(int i = 0; i &lt; len; i++) {            if (isdigit(num[len-i-1])) s[i] = num[len-i-1] - '0';            else s[i] = num[len-i-1] - 'A' + 10;        }        clean();        return *this;    }    bign operator + (const bign &amp;b) const{        bign c;        c.len = max(len, b.len);        for (int i = 0; i &lt; c.len; i++){            c.s[i] += s[i] + b.s[i];            c.s[i+1] += c.s[i] / 10;            c.s[i] %= 10;        }        if (c.s[c.len]) c.len++;        c.clean();        return c;    }    bign operator += (const bign &amp;b){        *this = *this + b;        return *this;    }    bign operator * (const bign &amp;b) {        bign c;        c.len = len + b.len;        for(int i = 0; i &lt; len; i++)            for(int j = 0; j &lt; b.len; j++){                c.s[i+j] += s[i] * b.s[j];            }        for(int i = 0; i &lt; c.len; i++){            c.s[i+1] += c.s[i]/10;            c.s[i] %= 10;        }        c.clean();        return c;    }    bign operator *= (const bign &amp;b){        *this = *this * b;        return *this;    }    bign operator - (const bign &amp;b){        bign c;        c.len = 0;        for(int i = 0, g = 0; i &lt; len; i++){            int x = s[i] - g;            if(i &lt; b.len) x -= b.s[i];            if(x &gt;= 0) g = 0;            else{                g = 1;                x += 10;            }            c.s[c.len++] = x;        }        c.clean();        return c;    }    bign operator -= (const bign &amp;b){        *this = *this - b;        return *this;    }    bign operator / (const int &amp;b){        int f = 0;        bign c;        for (int i = len-1; i &gt;= 0; i--){            f = f *10 + s[i];            c.s[i] = f / b;            f %= b;        }        c.len = len;        c.clean();        return c;    }    bign operator / (const bign &amp;b){        bign c, f = 0;        for(int i = len-1; i &gt;= 0; i--){            f = f*10;             f.s[0] = s[i];             while(f &gt; b || f == b){                f -= b;                c.s[i]++;            }        }        c.len = len;        c.clean();        return c;    }    bign operator /= (const bign &amp;b){        *this  = *this / b;        return *this;    }    bign operator % (const bign &amp;b){        bign r = *this / b;        r = *this - r*b;        return r;    }    bign operator %= (const bign &amp;b){        *this = *this % b;        return *this;    }    bool operator &lt; (const bign &amp;b){        if(len != b.len) return len &lt; b.len;        for(int i = len-1; i &gt;= 0; i--){            if(s[i] != b.s[i]) return s[i] &lt; b.s[i];        }        return false;    }    bool operator &gt; (const bign &amp;b){        if(len != b.len) return len &gt; b.len;        for(int i = len-1; i &gt;= 0; i--){            if(s[i] != b.s[i]) return s[i] &gt; b.s[i];        }        return false;    }    bool operator == (const bign &amp;b){        return !(*this &gt; b) &amp;&amp; !(*this &lt; b);    }    string str() const{        string res = \"\";         for (int i = 0; i &lt; len; i++) {            if (s[i] &lt; 10) res = char(s[i]+'0') + res;            else res = char(s[i] + 'A' - 10) + res;        }        return res;    }} a, b, c;\n","categories":["ç®—æ³•ç«èµ›"],"tags":["æ¨¡æ¿"]},{"title":"è¾¹ç¼˜è®¡ç®—","url":"/2023/09/24/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/","content":"Edge IntelligencePyramid: Enabling Hierarchical Neural Networks with Edge ComputingQiang He, Zeqian Dong, Feifei Chen, Shuiguang Deng, Weifa Liang, and Yun Yang. â€œPyramid: Enabling Hierarchical Neural Networks with Edge Computingâ€, The Web Conference (2022): 1860-1870.\näº‘ç«¯çš„  æ¨¡å‹å­˜åœ¨å›ºæœ‰çš„å±€é™æ€§ã€‚é¦–å…ˆï¼Œå…¶å¯¹äºå»¶è¿Ÿæ•æ„Ÿçš„åº”ç”¨ï¼Œå¾ˆéš¾ä¿æŒä½å»¶è¿Ÿã€‚å…¶æ¬¡ï¼Œå®ƒä¼šåœ¨å·²ç»æ‰¿å—å¾ˆå¯¹å‹åŠ›çš„å›ç¨‹ç½‘ç»œä¸Šäº§ç”Ÿè¿‡å¤šçš„æµé‡ã€‚ï¼ˆå›ç¨‹æŒ‡æ ¸å¿ƒç½‘æˆ–éª¨å¹²ç½‘ä¸ç½‘ç»œè¾¹ç¼˜çš„å°å­ç½‘ä¹‹é—´çš„ä¸­é—´é“¾è·¯ï¼‰\nè¾¹ç¼˜è®¡ç®—æä¾›ä¸€ç§æ–°çš„è®¡ç®—æ¨¡å¼ï¼Œä½¿ç½‘ç»œè¾¹ç¼˜çš„  å…‹æœäº†ä¸Šè¿°é™åˆ¶ã€‚åœ¨è¾¹ç¼˜è®¡ç®—ç¯å¢ƒä¸­ï¼Œé…ç½®äº†è®¡ç®—èµ„æºçš„è¾¹ç¼˜æœåŠ¡å™¨è¢«éƒ¨ç½²åœ¨åŸºç«™æˆ–è€…æ¥å…¥ç‚¹ã€‚è¿™ä½¿å¾—  æ¨¡å‹å¯ä»¥åœ¨è¾¹ç¼˜æœåŠ¡å™¨è€Œä¸æ˜¯è¿œç¨‹çš„äº‘æœåŠ¡å™¨ä¸Šè¿›è¡Œè®­ç»ƒå’Œéƒ¨ç½²ã€‚\næœ¬ç¯‡è®ºæ–‡æå‡ºäº†ä¸€ç§æ–°çš„æ¡†æ¶ï¼Œï¼Œæ¥åœ¨è¾¹ç¼˜æœåŠ¡å™¨å®ç° ï¼Œåœ¨äº‘æœåŠ¡å™¨å®ç° ã€‚\nPROBLEM STATEMENT\n ä¸ªåœ°åŒºè¢«  æ¡é«˜é€Ÿç›¸è¿ã€‚ç¬¬  ä¸ªåœ°åŒºæœ‰  ä¸ªé“è·¯ä¼ æ„Ÿå™¨ï¼Œã€‚æ‰€æœ‰çš„é“è·¯ä¼ æ„Ÿå™¨ä¸º ã€‚æ¯æ¡é«˜é€Ÿä¸Šè‡³å°‘æœ‰  ä¸ªé«˜é€Ÿä¼ æ„Ÿå™¨ï¼Œä¸¤ä¸ªç«¯ç‚¹å„ä¸€ä¸ªï¼Œä¸­ç‚¹ä¸€ä¸ªï¼Œã€‚æ€»å…±æœ‰  ä¸ªé«˜é€Ÿä¼ æ„Ÿå™¨ï¼Œæ€»å…±ä¸º ã€‚\nç”¨é‚»æ¥çŸ©é˜µæ¥è¡¨ç¤ºè·ç¦»ï¼Œã€‚\nåœ¨æ—¶é—´  å†…ä¼ æ„Ÿå™¨é‡‡é›†çš„å†å²äº¤é€šæ•°æ®ä¸º ï¼Œæ€»å…±ä¸º ã€‚\nåˆ†å±‚äº¤é€šé¢„æµ‹çš„ç›®æ ‡æ˜¯é¢„æµ‹  æ—¶é—´çš„é“è·¯äº¤é€šçŠ¶å†µ  å’Œé«˜é€Ÿäº¤é€šçŠ¶å†µ ã€‚\nPYRAMID NEURAL NETWORK ç”±éƒ¨ç½²åœ¨è¾¹ç¼˜æœåŠ¡å™¨ä¸Šçš„  å’Œéƒ¨ç½²åœ¨äº‘æœåŠ¡å™¨ä¸Šçš„  ä¸¤ä¸ªä¸»è¦éƒ¨åˆ†ç»„æˆã€‚\n\nLocal Prediction\n\n ç”±  ä¸‰éƒ¨åˆ†ç»„æˆã€‚\nä¹‹å‰è·å–æ—¶ç©ºé“è·¯äº¤é€šç›¸å…³æ€§çš„æ–¹æ³•éƒ½æ˜¯é‡‡ç”¨äº†ä¸¤ä¸ªæ—¶é—´å—å’Œä¸­é—´ä¸€ä¸ªç©ºé—´å—çš„â€œä¸‰æ˜æ²»â€ç»“æ„ã€‚ä½†å †å ä¸‰æ˜æ²»ä¹‹é—´çš„æ—¶é—´å—ä¼šäº§ç”Ÿé¢å¤–çš„å¼€é”€ã€‚é’ˆå¯¹è¯¥é—®é¢˜ï¼Œ é‡‡ç”¨äº†â€œåŒå±‚ä¸‰æ˜æ²»â€ç»“æ„ï¼Œç”±ä¸‰ä¸ªæ—¶é—´å—ä¸ä¸¤ä¸ªç©ºé—´å—äº¤ç»‡ç»„æˆã€‚\nData Modeling\nå°†é“è·¯ä¼ æ„Ÿå™¨æ”¶é›†åˆ°çš„å†å²äº¤é€šæ•°æ®æ”¾å…¥  å¯è¯»çš„çŸ©é˜µä¸­ï¼š\n\n\\mathcal X^r_k = \\begin{bmatrix}  \n  x_{1,1}^r & \\cdots & x_{1,T-1}^r & x_{1,T}^r\\\\  \n  x_{2,1}^r & \\cdots & x_{2,T-1}^r & x_{2,T}^r\\\\  \n  \\vdots & \\ddots & \\vdots & \\vdots\\\\  \n  x_{N_k -1,1}^r & \\cdots & x_{N_k -1,T-1}^r & x_{N_k -1,T}^r\\\\\n  x_{N_k,1}^r & \\cdots & x_{N_k,T-1}^r & x_{N_k,T}^r\\\\\n\\end{bmatrix}Feature Extraction\n é‡‡ç”¨æ—¶é—´å—ä»è¾“å…¥çŸ©é˜µ  ä¸­æå–æ—¶é—´é“è·¯äº¤é€šç‰¹å¾ã€‚æ—¶é—´å—ä¸­åŒ…å« ï¼Œå…¶å¯ä»¥å°†çº¿æ€§å’Œéçº¿æ€§ç‰¹å¾éƒ½ä¼ è¾“åˆ°åç»­å±‚ï¼š\n\n\\mathcal X^{t âˆ’out} = (W \\mathcal X^{t âˆ’in} + b) \\otimes \\sigma (V \\mathcal X^{t âˆ’in} + c)å…¶ä¸­  æ˜¯  æ¿€æ´»å±‚ã€‚\nç©ºé—´å—çš„ä¸»è¦ç»„æˆéƒ¨åˆ†æ˜¯ ï¼Œé€šè¿‡å›¾å·ç§¯æ¥è·å–ç©ºé—´é“è·¯äº¤é€šç›¸å…³æ€§ï¼š\n\n\\mathcal X^{s âˆ’out} = \\tau(W \\mathcal X^{s âˆ’in} \\cdot D^{-\\frac{1}{2}}\\hat A D^{-\\frac{1}{2}})å…¶ä¸­  æ˜¯  æ¿€æ´»å±‚ï¼Œã€‚\nPrediction\næœ€åç”¨ä¸€ä¸ªå…¨è¿æ¥å±‚æ¥å®ç°é¢„æµ‹ï¼š\n\n\\mathcal X^{r-out}=W \\mathcal X^{in}+båŒæ—¶ï¼Œ ä¹Ÿå°†è¢«ä¼ è¾“åˆ°  æ¥æ–¹ä¾¿å…¨å±€é¢„æµ‹ã€‚\nGlobal Prediction\n\n ç”±  ä¸¤éƒ¨åˆ†ç»„æˆã€‚\nFeature Extraction\nè¾“å…¥æ˜¯  æå–çš„é“è·¯äº¤é€šç‰¹å¾ï¼š\n\n\\mathcal X^r = concat_{k=1,\\dots,K}(\\mathcal X^{in}_k) ä»  ä¸­è·å–é“è·¯ä¸é«˜é€Ÿçš„ç©ºé—´ç›¸å…³æ€§ï¼Œé«˜é€Ÿä¹‹é—´çš„ç©ºé—´ç›¸å…³æ€§ï¼Œé«˜é€Ÿçš„æ—¶é—´ç›¸å…³æ€§ã€‚\n é‡‡ç”¨äº†è½¬æ¢å—æ¥å°†é“è·¯äº¤é€šç‰¹å¾  è½¬æ¢ä¸ºé«˜é€Ÿäº¤é€šç‰¹å¾ ã€‚å…¶ç”±ä¸¤ä¸ªç¨€ç–å±‚å’Œä¸­é—´çš„æ‰¹é‡å½’ä¸€åŒ–å±‚ç»„æˆã€‚\nç¬¬ä¸€ä¸ªç¨€ç–å±‚å°†  ç»´é“è·¯äº¤é€šç‰¹å¾  è½¬æ¢ä¸º  ç»´ä¸­é—´ç‰¹å¾ï¼š\n\n\\mathcal X ^{inter}=(E_0 \\odot W_0) \\times \\mathcal X^r + b_0 æ˜¯åµŒå…¥çŸ©é˜µã€‚\nç¬¬äºŒä¸ªç¨€ç–å±‚å°†  ç»´ä¸­é—´ç‰¹å¾è½¬æ¢ä¸º  ç»´é«˜é€Ÿäº¤é€šç‰¹å¾ ï¼š\n\n\\mathcal X ^f=(E_1 \\odot W_1) \\times \\mathcal X^{bn-inter} + b_1 æ˜¯åµŒå…¥çŸ©é˜µã€‚\næ ¹æ®  æ¥æ„å»º  çš„å…¨å±€é“è·¯é«˜é€Ÿé‚»æ¥çŸ©é˜µ ã€‚å…¶ä¸­  è¡¨ç¤ºç¬¬  ä¸ªé“è·¯ä¼ æ„Ÿå™¨æ˜¯å¦ä¸ç¬¬  ä¸ªé“è·¯ä¼ æ„Ÿå™¨ç›¸å…³ã€‚ç„¶åå°†  åˆ†è§£ä¸º  çš„  å’Œ  çš„ ï¼Œå…¶ä¸­ ã€‚\nPrediction\næœ€åç”¨ä¸€ä¸ªå…¨è¿æ¥å±‚æ¥å®ç°é¢„æµ‹ï¼š\n\n\\mathcal X^{f-out}=W \\mathcal X^{f}+bFedEdge: Accelerating Edge-Assisted Federated LearningKaibin Wang, Qiang He, Feifei Chen, Hai Jin, and Yun Yang. â€œFedEdge: Accelerating Edge-Assisted Federated Learningâ€, WWW 2023 (2023): 2895-2904.\n\n å­˜åœ¨ä¸‰ä¸ªç¼ºé™·ï¼š\nä¸¤é˜¶æ®µè®­ç»ƒæœŸé—´æµªè´¹äº†å¤§é‡æ—¶é—´ï¼Œå®¢æˆ·ç«¯åœ¨å‘é€æœ¬åœ°æ¨¡å‹è¿›è¡Œèšåˆååœæ­¢æ¨¡å‹è®­ç»ƒï¼Œç›´åˆ°ä½¿ç”¨æ¥æ”¶åˆ°çš„å…¨å±€æ¨¡å‹æ›´æ–°æœ¬åœ°æ¨¡å‹ã€‚ä»–ä»¬çš„ç­‰å¾…æ—¶é—´å¯ä»¥ç”¨æ¥åŠ é€Ÿæ¨¡å‹è®­ç»ƒã€‚\nç¼ºä¹æ¨¡å‹å¤šæ ·æ€§ï¼Œè€Œæ•°æ®å­˜åœ¨å¤šæ ·æ€§ã€‚\nå­˜åœ¨æ¨¡å‹å—åˆ°ä¸­æ¯’è¢­å‡»çš„æ¼æ´ï¼Œè¾¹ç¼˜æœåŠ¡å™¨å®¹æ˜“å—åˆ°æŸå®³ã€‚\næœ¬æ–‡æå‡ºäº†  æ¥è§£å†³ä»¥ä¸Šé—®é¢˜ã€‚\nPRELIMINARIESFederated Learning\nç ”ç©¶é‡ç‚¹æ˜¯åœ¨  æ–¹æ¡ˆä¸‹ä»¥æœ‰é™å’Œç›®æ ‡è®­ç»ƒç¥ç»ç½‘ç»œæ¨¡å‹ï¼š\n\n\\min_\\omega f(\\omega) \\triangleq \\sum_{k=1}^K \\frac{|\\mathcal D_k|}{|\\mathcal D|}f_k(\\omega)å…¶ä¸­  æ˜¯  ç³»ç»Ÿä¸­å®¢æˆ·ç«¯çš„æ•°é‡ï¼Œæ¯ä¸ªå®¢æˆ·ç«¯éƒ½æœ‰ä¸€ä¸ªæœ¬åœ°è®­ç»ƒæ•°æ®é›† ã€‚ æ˜¯ç¬¬ k ä¸ªå®¢æˆ·çš„å±€éƒ¨æŸå¤±å‡½æ•°ï¼Œè¡¡é‡  çš„å±€éƒ¨ç»éªŒé£é™©ï¼š\n\nf_k(\\omega) \\triangleq \\frac{1}{|\\mathcal D_k|}\\sum_{i=1}^{|\\mathcal D_k|}\\mathcal L(\\omega ; x_i,y_i)å…¶ä¸­  æ˜¯è®­ç»ƒæ ·æœ¬ï¼Œ æ˜¯äº¤å‰ç†µæŸå¤±å‡½æ•°ã€‚\nEdge-Assisted Federated Learning\nè€ƒè™‘ä¸€ä¸ª  ç³»ç»Ÿï¼Œå®¢æˆ·ç«¯ç”¨ ï¼Œ è¡¨ç¤ºï¼Œä»¥åŠä¸€ç»„è¦†ç›–è¿™äº›å®¢æˆ·ç«¯çš„  ä¸ªè¾¹ç¼˜æœåŠ¡å™¨ï¼Œç”¨  è¡¨ç¤ºï¼Œä»¥åŠäº‘æœåŠ¡å™¨ ã€‚æ¯ä¸ªè¾¹ç¼˜æœåŠ¡å™¨  è¦†ç›–å®¢æˆ·ç«¯çš„ä¸€ä¸ªå­é›† ã€‚ æ¯ä¸ªå®¢æˆ·ç«¯  éƒ½æ‹¥æœ‰ä¸€ä¸ªæœ¬åœ°æ•°æ®é›† ã€‚å…¶ä¸­  è¡¨ç¤ºç¬¬  ä¸ªè¾“å…¥æ ·æœ¬ï¼Œ æ˜¯  çš„ç›¸åº”æ ‡è®°è¾“å‡ºã€‚\n ä¸ç°æœ‰çš„è¾¹ç¼˜è¾…åŠ©  æ–¹æ¡ˆæœ‰ç€ç›¸åŒçš„åŸºæœ¬è®­ç»ƒæµç¨‹ï¼š\nï¼Œå®¢æˆ·ç«¯åœ¨è‡ªå·±çš„æ•°æ®é›†ä¸Šè®­ç»ƒæœ¬åœ°æ¨¡å‹ï¼Œç„¶åå°†æœ¬åœ°æ¨¡å‹ä¼ è¾“åˆ°ç›¸åº”çš„è¾¹ç¼˜æœåŠ¡å™¨ã€‚\nï¼Œæ¯ä¸ªè¾¹ç¼˜æœåŠ¡å™¨é€šè¿‡èšåˆå…¶å®¢æˆ·ç«¯çš„æœ¬åœ°æ¨¡å‹æ¥ç”Ÿæˆä¸­é—´æ¨¡å‹ï¼Œå¹¶å°†ä¸­é—´æ¨¡å‹ä¼ è¾“åˆ°äº‘æœåŠ¡å™¨ã€‚\nï¼Œäº‘æœåŠ¡å™¨é€šè¿‡èšåˆä»è¾¹ç¼˜æœåŠ¡å™¨æ¥æ”¶åˆ°çš„ä¸­é—´æ¨¡å‹æ¥ç”Ÿæˆå…¨å±€æ¨¡å‹ã€‚\nï¼Œäº‘æœåŠ¡å™¨å°†å…¨å±€æ¨¡å‹å‘é€è‡³è¾¹ç¼˜æœåŠ¡å™¨ï¼›è¾¹ç¼˜æœåŠ¡å™¨å°†å…¨å±€æ¨¡å‹å‘é€ç»™å…¶å®¢æˆ·ç«¯ï¼›æœ€åï¼Œå®¢æˆ·æ›´æ–°ä»–ä»¬çš„æœ¬åœ°æ¨¡å‹å¹¶è¿›å…¥ä¸‹ä¸€è½®è®­ç»ƒã€‚\nFINDINGS OF OUR EXPLORATIONTraining Time Wasting\n\nLack of Model Diversity Consideration\nåˆ©ç”¨æ¨¡å‹å¤šæ ·æ€§åï¼Œæ¨¡å‹ç²¾åº¦å’Œæ¨¡å‹æ”¶æ•›æ€§å‡æœ‰æå‡ã€‚\nVulnerability to Model Poisoning Attacks\nFEDEDGE DESIGNAsynchronous Local Federated Training\n\nAdaptive Model Aggregation\nPhase 1: Filtering Anomalous Models\n\nPhase 2: Aggregating Models\n\n\\hat d_i =\\frac{d_k}{\\sum_{k=1}^K d_k}\nEdgeMove: Pipelining Device-Edge Model Training for Mobile IntelligenceZeqian Dong, Qiang He, Feifei Chen, Hai Jin, Tao Gu, and Yun Yang. â€œEdgeMove: Pipelining Device-Edge Model Training for Mobile Intelligenceâ€, WWW 2023 (2023): 3142-3153.\nEdgeMove å°†æ¨¡å‹åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªç”¨äºåœ¨è¾¹ç¼˜è®¾å¤‡ä¸Šè¿›è¡Œè®­ç»ƒï¼Œå¦ä¸€ä¸ªç”¨äºåœ¨è¾¹ç¼˜æœåŠ¡å™¨ä¸Šè¿›è¡Œè®­ç»ƒã€‚ä¸­é—´ä¼ è¾“çš„æ˜¯ä¸­é—´ç‰¹å¾ï¼Œè€Œä¸æ˜¯ç”¨æˆ·çš„ç§æœ‰æ•°æ®ã€‚ä¸ç«¯äº‘è®­ç»ƒæ–¹æ¡ˆç›¸æ¯”ï¼ŒEdgeMove æ˜¾è‘—å‡å°‘äº†æœ¬åœ°æ¨¡å‹éƒ¨åˆ†å’Œå¤–éƒ¨æ¨¡å‹éƒ¨åˆ†ä¹‹é—´çš„é€šä¿¡å»¶è¿Ÿå¸¦æ¥çš„è®­ç»ƒè¿‡ç¨‹å»¶è¿Ÿã€‚\nEdgeMove æ¢æµ‹è¾¹ç¼˜è®¾å¤‡é™„è¿‘è¾¹ç¼˜æœåŠ¡å™¨çš„è®­ç»ƒæ€§èƒ½ï¼Œå¹¶é€šè¿‡è¿‘ä¼¼æ¨¡å‹åˆ†åŒºå¼•å¯¼æ¨¡å‹è®­ç»ƒã€‚EdgeMove è‡ªé€‚åº”åœ°æ¢æµ‹é™„è¿‘è¾¹ç¼˜æœåŠ¡å™¨çš„è®­ç»ƒæ€§èƒ½ï¼Œå¹¶æ ¹æ®è¿è¡Œæ—¶çš„ç³»ç»ŸåŠ¨æ€ä¸»åŠ¨è°ƒæ•´è®­ç»ƒç®¡é“ã€‚\nEdgeMove ç›‘æ§å·¥ä½œçº¿ç¨‹ï¼ˆå³å½“å‰æ­£åœ¨è®­ç»ƒ ML æ¨¡å‹çš„è¾¹ç¼˜æœåŠ¡å™¨ï¼‰çš„ç«¯åˆ°ç«¯è®­ç»ƒæ€§èƒ½ï¼Œè‡ªé€‚åº”åœ°æ¢æµ‹é™„è¿‘è¾¹ç¼˜æœåŠ¡å™¨çš„ç«¯åˆ°ç«¯æ€§èƒ½ï¼Œå¹¶è°ƒæ•´è®­ç»ƒä¸»åŠ¨ç®¡é“\nOFFLINE PIPELINE CONSTRUCTIONModel Profiling\nEdgeMove å‘é€ä¸€ä¸ªæµ‹è¯•æ¨¡å‹  å’Œä¸€ä¸ªæµ‹è¯•æ•°æ®é›†  åˆ°æ¯ä¸ªé™„è¿‘çš„è¾¹ç¼˜æœåŠ¡å™¨ç”¨äºè®­ç»ƒï¼Œå®Œæˆè®­ç»ƒå‘¨æœŸå¹¶è¿”å›ç»“æœæ—¶ï¼Œå®¢æˆ·ç«¯å°†è·å¾—å…¶ç«¯åˆ°ç«¯è®­ç»ƒæ€§èƒ½çš„ä¼°è®¡å€¼ã€‚\nModel Partitioning\nä»¤  è¡¨ç¤ºè¾¹ç¼˜è®¾å¤‡åœ¨æ¨¡å‹åˆ†æä¸­å®Œæˆä¸€ä¸ªè®­ç»ƒå‘¨æœŸæ‰€èŠ±è´¹çš„æ—¶é—´ï¼Œ è¡¨ç¤ºé™„è¿‘è¾¹ç¼˜æœåŠ¡å™¨çš„é›†åˆï¼Œ è¡¨ç¤º  ä¸­ç¬¬  ä¸ªé™„è¿‘è¾¹ç¼˜æœåŠ¡å™¨æ‰€èŠ±è´¹çš„æ—¶é—´ã€‚æˆ‘ä»¬è®¡ç®—å®ƒä»¬æ¯å±‚è®­ç»ƒæ—¶é—´å¦‚ä¸‹ï¼š\n\n\\begin{cases}\n\\overline{t_d} = \\frac{t_d}{R \\times L} \\\\\n\\overline{t_{e,n}} = \\frac{t_{e,n}}{R \\times L},\\forall s_n \\in S\n\\end{cases} æ˜¯è®­ç»ƒå¾ªç¯ä¸­çš„è®­ç»ƒè¿­ä»£æ¬¡æ•°ï¼Œ æ˜¯ç›®æ ‡æ¨¡å‹  ä¸­çš„å±‚æ•°ã€‚\nEdgeMove ä¸‹æ¨¡å‹åˆ†åŒºçš„ç›®æ ‡æ˜¯æœ€å¤§åŒ–ç®¡é“ååé‡ï¼Œç±»ä¼¼äºç°æœ‰çš„ç®¡é“æ–¹æ¡ˆã€‚å…³é”®æ˜¯ååé‡å¹³è¡¡ï¼Œå³è¾¹ç¼˜è®¾å¤‡å’Œè¾¹ç¼˜æœåŠ¡å™¨ç»´æŒå¤§è‡´ç›¸åŒçš„ååé‡ã€‚æ³¨æ„åˆ°è¾¹ç¼˜è®¾å¤‡çš„è®­ç»ƒæ€§èƒ½ä½äºè¾¹ç¼˜æœåŠ¡å™¨ï¼ŒEdgeMove åˆ†åŒºç›®æ ‡æ˜¯ç¡®ä¿å¤„ç†ä¸€ä¸ª minibatchï¼ˆåŒ…æ‹¬å‰å‘å’Œåå‘ä¼ é€’ï¼‰æ‰€éœ€çš„æ—¶é—´å¤§è‡´ç­‰äºå®Œæˆå‰ä¸€ä¸ª minibatch çš„åå‘ä¼ é€’æ‰€éœ€çš„æ—¶é—´åŠ ä¸Šä¸‹ä¸€ä¸ªå°æ‰¹é‡çš„å‰å‘ä¼ é€’ã€‚\nONLINE PIPELINE ADAPTATIONåœ¨è¿è¡Œæ—¶ï¼ŒEdgeMove ç›‘æ§ç®¡é“æ€§èƒ½å¹¶ç›¸åº”åœ°è°ƒæ•´è®­ç»ƒç®¡é“ã€‚å®ƒå¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼è°ƒæ•´è®­ç»ƒç®¡é“ï¼š1ï¼‰è°ƒæ•´è·¨å®¢æˆ·ç«¯å’Œå·¥ä½œå™¨çš„æ¨¡å‹åˆ’åˆ†ï¼› 2ï¼‰ä½¿ç”¨æ–°çš„å·¥ä½œå™¨å’Œå¯èƒ½çš„æ–°æ¨¡å‹åˆ†åŒºæ¥è°ƒæ•´æ•´ä¸ªè®­ç»ƒç®¡é“ã€‚\nEdge ResourceA Game-Theoretical Approach for User Allocation in Edge Computing Environmentåº”ç”¨ç¨‹åºä¾›åº”å•†çš„å¦ä¸€ä¸ªé‡è¦ç›®æ ‡æ˜¯æœ€å¤§é™åº¦åœ°é™ä½ä¸ºåº”ç”¨ç¨‹åºç”¨æˆ·æä¾›æœåŠ¡çš„æ€»ä½“ç³»ç»Ÿæˆæœ¬ã€‚è¯¥é—®é¢˜ç§°ä¸ºè¾¹ç¼˜ç”¨æˆ·åˆ†é…ï¼ˆEUAï¼‰é—®é¢˜ã€‚\nä½äºè¾¹ç¼˜æœåŠ¡å‘˜è¦†ç›–çš„äº¤å‰åŒºåŸŸçš„åº”ç”¨ç¨‹åºç”¨æˆ·å¯ä»¥è¿æ¥åˆ°é™„è¿‘å…·æœ‰è¶³å¤Ÿè®¡ç®—èƒ½åŠ›ï¼ˆå®¹é‡çº¦æŸï¼‰ï¼ˆä¾‹å¦‚CPUã€å†…å­˜å’Œå¸¦å®½ï¼‰çš„è¾¹ç¼˜æœåŠ¡å™¨ä¹‹ä¸€ï¼ˆé‚»è¿‘çº¦æŸï¼‰ã€‚\næœ¬æ–‡äº†ä»‹ç» EUAGameï¼Œè¿™æ˜¯ä¸€ç§å¯»æ‰¾ EUA é—®é¢˜è§£å†³æ–¹æ¡ˆçš„åšå¼ˆè®ºæ–¹æ³•ã€‚\nEUAGame å°†åº”ç”¨ç¨‹åºä¾›åº”å•†çš„ EUA é—®é¢˜å»ºæ¨¡ä¸º EUA æ¸¸æˆã€‚åœ¨è¿™ä¸ªæ¸¸æˆä¸­ï¼Œæ¯ä¸ªåº”ç”¨ç¨‹åºç”¨æˆ·éƒ½è¢«æ¨¡æ‹Ÿä¸ºæ¸¸æˆä¸­çš„ç©å®¶ï¼Œå¯»æ‰¾é™„è¿‘çš„è¾¹ç¼˜æœåŠ¡å™¨æ¥å¸è½½å…¶è®¡ç®—ä»»åŠ¡ã€‚ EUAGame ç„¶åé‡‡ç”¨å»ä¸­å¿ƒåŒ–ç®—æ³•ä¸ºåº”ç”¨ç¨‹åºç”¨æˆ·åšå‡ºåˆ†é…å†³ç­–ï¼Œä»¥å®ç°æ¸¸æˆçš„çº³ä»€å‡è¡¡ã€‚\n\nSYSTEM MODELå¯¹äºåº”ç”¨ä¾›åº”å•†ï¼ŒEUA æ—¨åœ¨å°†å…¶  ä¸ªåº”ç”¨ç”¨æˆ·  åˆ†é…ç»™ç‰¹å®šåŒºåŸŸçš„ m ä¸ªè¾¹ç¼˜æœåŠ¡å™¨ ã€‚åº”ç”¨ç”¨æˆ·  çš„å®¹é‡éœ€æ±‚ï¼Œç”¨  è¡¨ç¤ºï¼Œå…¶ä¸­ ã€‚è¾¹ç¼˜æœåŠ¡å™¨  çš„å¯ç”¨å®¹é‡ç”¨  è¡¨ç¤ºï¼Œå…¶ä¸­ ã€‚\n\nMulti-tenancy Benefit Model\næœåŠ¡å™¨  çš„ CPU åˆ©ç”¨ç‡å¯ä»¥è¿‘ä¼¼ä¸ºï¼š\n\nf_{\\text{cpu}}(s_j)=-\\log_x(y)å…¶ä¸­  ç”±è®¡ç®—ä»»åŠ¡å¤§å°å†³å®šï¼Œæ˜¯åˆ†é…ç»™æœåŠ¡å™¨çš„åº”ç”¨ç¨‹åºç”¨æˆ·æ•°ã€‚\nè¾¹ç¼˜æœåŠ¡å™¨  çš„å¤šç§Ÿæˆ·æ”¶ç›Šè®¡ç®—å…¬å¼ä¸ºï¼š\n\nf^k(s_j)=-\\log_{x_k}(y)å…¶ä¸­  ä¸”  ç”±è®¡ç®—ä»»åŠ¡å¤§å°å†³å®šã€‚\nUser Benefit Model\n\nu_i \\in cov(s_j),\\forall u_i \\in U,\\forall s_j \\in Sè¿™æ ·çš„è¾¹ç¼˜æœåŠ¡å™¨  è¢«ç§°ä¸º  çš„é‚»å±…è¾¹ç¼˜æœåŠ¡å™¨ã€‚ çš„é‚»å±…è¾¹ç¼˜æœåŠ¡å™¨é›†ç”±  è¡¨ç¤º\nCost-Effective App Data Distribution in Edge Computingåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬é¦–æ¬¡å°è¯•ä»åº”ç”¨ä¾›åº”å•†çš„è§’åº¦å°†è¾¹ç¼˜æ•°æ®åˆ†å¸ƒ ï¼ˆEDDï¼‰ é—®é¢˜è¡¨è¿°ä¸ºçº¦æŸä¼˜åŒ–é—®é¢˜ï¼Œå¹¶è¯æ˜å…¶ NP-hardnessã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§åä¸º EDD-IP çš„æœ€ä¼˜æ–¹æ³•ï¼Œç”¨æ•´æ•°è§„åˆ’æŠ€æœ¯ç²¾ç¡®åœ°è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚ç„¶åï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§åä¸º EDD-A çš„  é€¼è¿‘ç®—æ³•ï¼Œç”¨äºæœ‰æ•ˆåœ°æ‰¾åˆ°å¤§è§„æ¨¡ EDD é—®é¢˜çš„è¿‘ä¼¼è§£ã€‚\nOnline Collaborative Data Caching in Edge Computingåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº† EC ç¯å¢ƒä¸­çš„ååŒç¼“å­˜é—®é¢˜ï¼Œæ—¨åœ¨æœ€å°åŒ–ç³»ç»Ÿæˆæœ¬ï¼ŒåŒ…æ‹¬æ•°æ®ç¼“å­˜æˆæœ¬ã€æ•°æ®è¿ç§»æˆæœ¬å’ŒæœåŠ¡è´¨é‡ ï¼ˆQoSï¼‰ æŸå¤±ã€‚æˆ‘ä»¬å°†è¯¥ååŒè¾¹ç¼˜æ•°æ®ç¼“å­˜é—®é¢˜ï¼ˆCEDCï¼‰å»ºæ¨¡ä¸ºçº¦æŸä¼˜åŒ–é—®é¢˜ï¼Œå¹¶è¯æ˜å®ƒæ˜¯ NP-complete çš„ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§ç§°ä¸º CEDC-O çš„åœ¨çº¿ç®—æ³•ï¼Œä»¥è§£å†³æ‰€æœ‰æ—¶éš™ä¸­çš„ CEDC é—®é¢˜ã€‚CEDC-O åŸºäº Lyapunov ä¼˜åŒ–å¼€å‘ï¼Œæ— éœ€æœªæ¥ä¿¡æ¯å³å¯åœ¨çº¿å·¥ä½œï¼Œå¹¶å®ç°å¯è¯æ˜çš„æ¥è¿‘æœ€ä½³æ€§èƒ½ã€‚\nEdge SecurityCooperative Assurance of Cache Data Integrity for Mobile Edge Computingä½†æ˜¯ï¼Œåœ¨é«˜åº¦åˆ†å¸ƒå¼çš„ MEC ç¯å¢ƒä¸­ï¼Œç¼“å­˜æ•°æ®å®¹æ˜“æŸåï¼Œå¿…é¡»ç¡®ä¿å…¶å®Œæ•´æ€§ã€‚ç°æœ‰çš„é›†ä¸­å¼æ•°æ®å®Œæ•´æ€§ä¿è¯æ–¹æ¡ˆè¢«MECçš„ç‹¬ç‰¹ç‰¹æ€§æ‰€æ·˜æ±°ï¼Œå³ä¸äº‘æœåŠ¡å™¨ä¸åŒï¼Œè¾¹ç¼˜æœåŠ¡å™¨åªæœ‰æœ‰é™çš„è®¡ç®—å’Œå­˜å‚¨èµ„æºï¼Œå¹¶ä¸”å®ƒä»¬å¤§è§„æ¨¡éƒ¨ç½²å¹¶åˆ†å¸ƒåœ¨åœ°ç†ä¸Šã€‚å› æ­¤ï¼Œåœ¨åœ°ç†ä½ç½®åˆ†æ•£ã€èµ„æºå—é™çš„è¾¹ç¼˜æœåŠ¡å™¨ä¸Šç¡®ä¿ç¼“å­˜æ•°æ®å®Œæ•´æ€§æ˜¯ä¸€é¡¹æ–°çš„é‡å¤§æŒ‘æˆ˜ã€‚è¯¥æ–‡æå‡ºä¸€ç§ä»¥åˆ†å¸ƒå¼æ–¹å¼ä¿è¯è¾¹ç¼˜æ•°æ®å®Œæ•´æ€§çš„CooperEDIæ–¹æ¡ˆã€‚CooperEDIé‡‡ç”¨åˆ†å¸ƒå¼å…±è¯†æœºåˆ¶ï¼Œå½¢æˆè‡ªæˆ‘ç®¡ç†çš„è¾¹ç¼˜ç¼“å­˜ç³»ç»Ÿã€‚åœ¨ç³»ç»Ÿä¸­ï¼Œè¾¹ç¼˜æœåŠ¡å™¨ååŒç¡®ä¿ç¼“å­˜å‰¯æœ¬çš„å®Œæ•´æ€§å¹¶ä¿®å¤æŸåçš„å‰¯æœ¬ã€‚æˆ‘ä»¬æ ¹æ®ä¸‰ç§å…·æœ‰ä»£è¡¨æ€§çš„æ–¹æ¡ˆå¯¹å…¶æ€§èƒ½è¿›è¡Œäº†å®éªŒè¯„ä¼°ã€‚ç»“æœè¡¨æ˜ï¼ŒCooperEDIèƒ½å¤Ÿæœ‰æ•ˆã€é«˜æ•ˆåœ°ä¿è¯MECç¯å¢ƒä¸‹çš„ç¼“å­˜æ•°æ®å®Œæ•´æ€§ã€‚\nA Game-Theoretical Approach for Mitigating Edge DDoS Attackåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬é¦–æ¬¡å°è¯•è§£å†³è¾¹ç¼˜ DDoS ç¼“è§£ ï¼ˆEDMï¼‰ é—®é¢˜ã€‚æˆ‘ä»¬å°†å…¶å»ºæ¨¡ä¸ºçº¦æŸä¼˜åŒ–é—®é¢˜ï¼Œå¹¶è¯æ˜å…¶NPç¡¬åº¦ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§åä¸ºEDMOptiçš„æœ€ä¼˜æ–¹æ³•å’Œä¸€ç§åä¸ºEDMGameçš„æ–°é¢–åšå¼ˆè®ºæ–¹æ³•ï¼Œç”¨äºç¼“è§£è¾¹ç¼˜DDoSæ”»å‡»ã€‚EDMGame å°† EDM é—®é¢˜è¡¨è¿°ä¸ºä¸€ä¸ªæ½œåœ¨çš„ EDM åšå¼ˆï¼Œå®ƒæ‰¿è®¤çº³ä»€å‡è¡¡ï¼Œå¹¶é‡‡ç”¨åˆ†æ•£ç®—æ³•æ¥å¯»æ‰¾çº³ä»€å‡è¡¡ä½œä¸º EDM é—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚é€šè¿‡ç†è®ºåˆ†æå’Œå®éªŒè¯„ä¼°ï¼Œè¯æ˜äº†æˆ‘ä»¬çš„æ–¹æ³•èƒ½å¤Ÿæœ‰æ•ˆã€é«˜æ•ˆåœ°è§£å†³EDMé—®é¢˜ã€‚\nCoopEdge: A Decentralized Blockchain-based Platform for Cooperative Edge Computingæœ¬æ–‡æå‡ºäº†CoopEdgeï¼Œä¸€ç§åŸºäºåŒºå—é“¾çš„æ–°å‹å»ä¸­å¿ƒåŒ–å¹³å°ï¼Œç”¨äºé©±åŠ¨å’Œæ”¯æŒååŒè¾¹ç¼˜è®¡ç®—ã€‚åœ¨ CoopEdge ä¸Šï¼Œè¾¹ç¼˜æœåŠ¡å™¨å¯ä»¥å‘å¸ƒè®¡ç®—ä»»åŠ¡ä¾›å…¶ä»–è¾¹ç¼˜æœåŠ¡å™¨äº‰ç”¨ã€‚è·èƒœè€…æ˜¯æ ¹æ®å…¶å£°èª‰ä»å€™é€‰è¾¹ç¼˜æœåŠ¡å™¨ä¸­é€‰å‡ºçš„ã€‚ä¹‹åï¼Œè¾¹ç¼˜æœåŠ¡å™¨ä¹‹é—´è¾¾æˆå…±è¯†ï¼Œè®°å½•åŒºå—é“¾ä¸Šä»»åŠ¡æ‰§è¡Œçš„æ€§èƒ½ã€‚æˆ‘ä»¬å®ç°äº†åŸºäº Hyperledger Sawtooth çš„ CoopEdgeï¼Œå¹¶åœ¨æ¨¡æ‹Ÿ EC ç¯å¢ƒä¸­æ ¹æ®åŸºçº¿å’Œä¸¤ä¸ªæœ€å…ˆè¿›çš„å®ç°å¯¹å…¶è¿›è¡Œäº†å®éªŒè¯„ä¼°ã€‚ç»“æœéªŒè¯äº† CoopEdge çš„å®ç”¨æ€§å¹¶è¯æ˜äº†å…¶æ€§èƒ½ã€‚\n","categories":["å­¦ä¹ ç¬”è®°"],"tags":["è®ºæ–‡","è¾¹ç¼˜è®¡ç®—"]}]